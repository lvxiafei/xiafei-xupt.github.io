<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiafei-xupt&#39;s blog</title>
  
  <subtitle>汝之意志所向,即吾剑之所指</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-23T04:48:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiafei-xupt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核模块编程入门</title>
    <link href="http://yoursite.com/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/Linux内核模块编程入门/</id>
    <published>2026-09-11T16:00:00.000Z</published>
    <updated>2018-09-23T04:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><h2 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h2><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h2 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h2><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><h2 id="文章分析"><a href="#文章分析" class="headerlink" title="文章分析"></a>文章分析</h2><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00-文章前言&lt;/li&gt;
&lt;li&gt;0x01-知识储备&lt;/li&gt;
&lt;li&gt;0x02-测试环境&lt;/li&gt;
&lt;li&gt;0x03-方案设计&lt;/li&gt;
&lt;li&gt;0x04-实践验证&lt;/li&gt;
&lt;li&gt;0x05-总结分析&lt;/li&gt;
&lt;li&gt;0x06
      
    
    </summary>
    
    
      <category term="模板" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>博客模板</title>
    <link href="http://yoursite.com/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/博客模板/</id>
    <published>2026-01-03T16:00:00.000Z</published>
    <updated>2018-10-08T02:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践操作</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>AI操作系统，以01为基因，内核为灵魂，</p><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>PostgreSQL</li><li>WebStorm</li><li>Node.js</li><li>Git<h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1></li></ul><p>复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。</p><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-实践操作"><a href="#0x04-实践操作" class="headerlink" title="0x04-实践操作"></a>0x04-实践操作</h1><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul><p>考虑到：</p><pre><code>理论与实践抽象与具体现状与未来</code></pre><p>调试优化（折中与平衡）<br>用户体验：<br>应用性能：</p><p>截图时间点（I/O）：</p><p>输入：命令、按钮</p><p>输出：变化、结果</p><p>——&gt;I/O截图法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00-文章前言&lt;/li&gt;
&lt;li&gt;0x01-知识储备&lt;/li&gt;
&lt;li&gt;0x02-测试环境&lt;/li&gt;
&lt;li&gt;0x03-方案设计&lt;/li&gt;
&lt;li&gt;0x04-实践操作&lt;/li&gt;
&lt;li&gt;0x05-总结分析&lt;/li&gt;
&lt;li&gt;0x06
      
    
    </summary>
    
    
      <category term="模板" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Gitbook教程</title>
    <link href="http://yoursite.com/Gitbook%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/Gitbook教程/</id>
    <published>2026-01-03T16:00:00.000Z</published>
    <updated>2018-08-13T18:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>在线文档</p><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><h2 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h2><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><p>pdf – –&gt; md</p><p>md、HTML、world、pdf等格式互相转换</p><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h2 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h2><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><h2 id="文章分析"><a href="#文章分析" class="headerlink" title="文章分析"></a>文章分析</h2><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul><p>考虑到：</p><pre><code>理论与实践抽象与具体现状与未来</code></pre><p>调试优化（折中与平衡）<br>用户体验：<br>应用性能：</p><p>截图时间点（I/O）：</p><p>输入：命令、按钮</p><p>输出：变化、结果</p><p>——&gt;I/O截图法</p><p>#########################</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00-文章前言&lt;/li&gt;
&lt;li&gt;0x01-知识储备&lt;/li&gt;
&lt;li&gt;0x02-测试环境&lt;/li&gt;
&lt;li&gt;0x03-方案设计&lt;/li&gt;
&lt;li&gt;0x04-实践验证&lt;/li&gt;
&lt;li&gt;0x05-总结分析&lt;/li&gt;
&lt;li&gt;0x06
      
    
    </summary>
    
    
      <category term="模板" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核是什么？</title>
    <link href="http://yoursite.com/Linux%E5%86%85%E6%A0%B8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/Linux内核是什么？/</id>
    <published>2019-02-10T12:03:33.000Z</published>
    <updated>2019-02-10T12:31:48.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核定义"><a href="#Linux内核定义" class="headerlink" title="Linux内核定义"></a>Linux内核定义</h1><p><img src="/assets/blogImg/微信图片_20190210200636.png" alt=""></p><h2 id="底层驱动"><a href="#底层驱动" class="headerlink" title="底层驱动"></a>底层驱动</h2><p>Linux内核[kernel]是整个操作系统的最底层，它负责整个硬件的驱动，以及提供各种系统所需的核心功能，包括防火墙机制、是否支持LVM或Quota等文件系统等等，如果内核不认识某个最新的硬件，那么硬件也就无法被驱动，你也就无法使用该硬件。</p><h2 id="芯片控制"><a href="#芯片控制" class="headerlink" title="芯片控制"></a>芯片控制</h2><p>计算机真正工作的东西其实是硬件，例如数值运算要使用到CPU、数据储存要使用到硬盘、图形显示会用到显示适配器、音乐发声要有音效芯片、连接Internet 可能需要网络卡等等。内核就是控制这些芯片如何工作。</p><h1 id="Linux操作系统的三层模型"><a href="#Linux操作系统的三层模型" class="headerlink" title="Linux操作系统的三层模型"></a>Linux操作系统的三层模型</h1><ul><li>最底层的硬件系统，包括CPU、内存、硬盘、网卡等；</li><li>硬件系统之上是内核，这是操作系统的核心，负责管理硬件系统，同时为上层的应用程序提供操作接口；</li><li>用户进程在这表示计算机中运行的所有程序，它们运行于用户空间，由内核统一管理； </li></ul><p><img src="/assets/blogImg/微信图片_20190210200802.png" alt=""></p><h1 id="Linux内核主的五个子系统"><a href="#Linux内核主的五个子系统" class="headerlink" title="Linux内核主的五个子系统"></a>Linux内核主的五个子系统</h1><ul><li>进程调度</li><li>内存管理</li><li>虚拟文件系统</li><li>网络接口</li><li>进程间通信</li></ul><p><img src="/assets/blogImg/微信图片_20190210201005.png" alt=""></p><p>进程调度位于中心位置，所有子系统都依赖于它，因为每个子系统都需要挂起和恢复进程。<br>一般情况下，当一个进程等待硬件操作完成时，它就被挂起；当操作完成时，进程就被恢复执行<br>例如：<br>当一个进程通过网络发送一条消息时，网络接口需要挂起发送进程，直到硬件成功地完成消息的发送，当消息被成功地发送出去后，网络接口给进程返回一个代码，表示操作成功或失败。其它子系统都是与此相似地依赖进程调度</p><h1 id="Linux组成"><a href="#Linux组成" class="headerlink" title="Linux组成"></a>Linux组成</h1><h2 id="kernel的功能"><a href="#kernel的功能" class="headerlink" title="kernel的功能"></a>kernel的功能</h2><ol><li>kernel提供的功能都通过系统调用给用户接口</li><li>kernel包括：进程管理 、内存管理 、网络管理 、驱动程序、安全管理 、文件系统<br><img src="/assets/blogImg/微信图片_20190210201548.png" alt=""></li></ol><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>函数功能模块集合，调用接口是二进制程序，要想运行，必须别其他程序调用，即其他程序面向硬件的一个中间层，有两种情形</p><ol><li>过程调用（procedure）无返回值</li><li>函数调用（function ）：有返回值</li></ol><h2 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h2><p>linux一切皆文件，除了一级文件外，其他文件需要挂载至根文件系统</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="开机过程"><a href="#开机过程" class="headerlink" title="开机过程"></a>开机过程</h3><p>开机 –&gt;内核运行 –&gt; 内核加载根文件系统 –&gt;运行根文件系统上的第一个应用程序init</p><p>init：它是负责后面的总的应用程序的启动回收等，启动可能需要向内核申请，这一切都在用户空间运行，如果init程序终止了，则用户空间的所有程序终止</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>让程序按照我们需要的方式一直运行下去</p><h1 id="Linux内核特点"><a href="#Linux内核特点" class="headerlink" title="Linux内核特点"></a>Linux内核特点</h1><p>结合了unix操作系统的一些基础概念</p><h2 id="支持模块化"><a href="#支持模块化" class="headerlink" title="支持模块化"></a>支持模块化</h2><ul><li><p>linux内核会将其各部分功能模块化，这使得在安装linux内核时，可以仅保持最基本的内核和功能，不过内核中模块数量会变多。linux内核中的.ko（kernel object）文件就是可以被内核调用的内核模块。</p></li><li><p>做以下假设：驱动是内核提供的，编译好一个内核之后，在装在主机上，在未来添加新的硬件设备没有新的驱动的话。是重新编译一次内核？这种设计是一件反人类的设计啊，因此引入了模块设计。</p></li><li><p>模块化设计得以避免这种情况，故各大厂商可以通过模块化的形式开发自己的驱动，只需针对某一特定设备开发自己驱动程序即可，在编译驱动模块。由于linux支持动态装载和卸载模块，因此当我需要和不需要某一功能时，可自行拆卸，此操作并不影响核心的正常运行。</p></li></ul><h1 id="Linux内核的任务"><a href="#Linux内核的任务" class="headerlink" title="Linux内核的任务"></a>Linux内核的任务</h1><ol><li>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</li><li>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</li><li>内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。</li><li>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/TommyMusk/article/details/80714364" target="_blank" rel="noopener">Linux内核简介</a></li><li><a href="https://www.cnblogs.com/zangfans/p/8646013.html" target="_blank" rel="noopener">linux内核管理</a></li><li>深入理解linux内核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux内核定义&quot;&gt;&lt;a href=&quot;#Linux内核定义&quot; class=&quot;headerlink&quot; title=&quot;Linux内核定义&quot;&gt;&lt;/a&gt;Linux内核定义&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/微信图片_20190210200
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Rust语言的优势</title>
    <link href="http://yoursite.com/Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%BF/"/>
    <id>http://yoursite.com/Rust语言的优势/</id>
    <published>2019-02-01T14:23:38.000Z</published>
    <updated>2019-02-01T14:51:37.354Z</updated>
    
    <content type="html"><![CDATA[<p>一门编程语言的开发追求的是快速、安全性、易于编写三个方面，但大多数的编程语言的现状只满足两个方面，安全性和简单的编程语言往往编译速度很慢，比如Python;编译快又满足安全性的却又很难学，比方说C与C++。那么有没有一门语言同时满足快速、安全、简单三个方面呢?</p><p>由Graydon Hoare开发、Mozilla Research赞助的Rust语言一直在致力于快速、安全、简单三方面的追求，虽然谷歌的Go语言近些月以来都被炒得很热，但Rust语言可以说也是新晋黑马的一员，Rust语言为何能与Go相媲美?它的优势在哪里?</p><h1 id="满足更高的速度需求"><a href="#满足更高的速度需求" class="headerlink" title="满足更高的速度需求"></a>满足更高的速度需求</h1><p>Rust代码可跨多个平台编译成本机代码，且二进制文件是自包含的，无需运行。生成的代码意味要执行与C或者C++编写的类似的代码。</p><h1 id="更加注重安全性"><a href="#更加注重安全性" class="headerlink" title="更加注重安全性"></a>更加注重安全性</h1><p>大多数内存错误都是在程序运行时才被发现，其他语言中常见的内存问题——空指针、野指针以及数据竞争等绝不会在Rust中产生。Rust编译器会将这些问题标记出来，在程序运行之前进行修复。</p><h1 id="无需内存管理"><a href="#无需内存管理" class="headerlink" title="无需内存管理"></a>无需内存管理</h1><p>Rust的记忆管理系统在语言语法中通过一个叫做所有权的隐喻进行了阐述语言中的任何给定值都可以被控制或者操纵，且一次只能由一个变量来控制。对象之间传输所有权受到编译器的严格控制，所以在运行时没有内存分配形式的错误。所有权也意味着Rust没有像GO或C#这样的垃圾回收的内存管理。 Rust程序中的所有内存都通过所有权自动跟踪和释放。</p><h1 id="使用简单"><a href="#使用简单" class="headerlink" title="使用简单"></a>使用简单</h1><p>Rust相对于C入门简单，这也是Rust受欢迎的重要原因之一。所有在Rust中生成的二进制文件都会放在一个包里;像GCC那样的外部编译器只有在编译Rust原生系统之外的其他组件(比如从源代码中编译C库)时才需要。Rust同样适用于Linux、MacOS以及Windows。</p><h1 id="其他优势"><a href="#其他优势" class="headerlink" title="其他优势"></a>其他优势</h1><ul><li>支持多架构、多平台</li></ul><p>　　支持三种操作系统，支持交叉编译以及跨架构、平台二进制文件的产生。</p><ul><li><p>强大的语言功能<br>　　Rust拥有 “宏”，泛型，模式匹配等，功能毫不逊色于C++。</p></li><li><p>标准库<br>　　拥有像C和C++的标准库，可使用容器、集合、迭代器等工具，执行字符串操作，管理进程和线程等。</p></li><li><p>IDE工具<br>Visual Studio等工具</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/liigo/article/details/45757123" target="_blank" rel="noopener">为什么我说Rust是靠谱的编程语言</a></li><li><a href="https://www.rust-lang.org" target="_blank" rel="noopener">Rust官网</a>    </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一门编程语言的开发追求的是快速、安全性、易于编写三个方面，但大多数的编程语言的现状只满足两个方面，安全性和简单的编程语言往往编译速度很慢，比如Python;编译快又满足安全性的却又很难学，比方说C与C++。那么有没有一门语言同时满足快速、安全、简单三个方面呢?&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://yoursite.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Docker与虚拟机、物理机的区别？</title>
    <link href="http://yoursite.com/Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/Docker与虚拟机、物理机的区别？/</id>
    <published>2019-01-31T15:22:44.000Z</published>
    <updated>2019-01-31T15:34:49.597Z</updated>
    
    <content type="html"><![CDATA[<p>初次接触Docker时，感觉它就像一种轻量级的虚拟机。Docker最初的成功秘诀是因为它比虚拟机更节省内存，启动更快。然而事实并非如此，Docker并非虚拟机，那么什么是Docker呢？它和虚拟机、物理机又有什么区别呢？</p><h1 id="极简类比"><a href="#极简类比" class="headerlink" title="极简类比"></a>极简类比</h1><h2 id="一、物理机是这样的"><a href="#一、物理机是这样的" class="headerlink" title="一、物理机是这样的"></a>一、物理机是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232444.png" alt=""></p><h2 id="二、虚拟机是这样的"><a href="#二、虚拟机是这样的" class="headerlink" title="二、虚拟机是这样的"></a>二、虚拟机是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232509.png" alt=""></p><h2 id="三、容器是这样的"><a href="#三、容器是这样的" class="headerlink" title="三、容器是这样的"></a>三、容器是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232529.png" alt=""></p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h1><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 </p><h2 id="集装箱比方"><a href="#集装箱比方" class="headerlink" title="集装箱比方"></a>集装箱比方</h2><p>集装箱解决了什么问题呢？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。<br>docker也是类似的理念。我们可以在一台机器上跑多个互相毫无关联的docker容器，每一个容器就相当于一个集装箱。</p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><h2 id="Docker里的几个基本概念"><a href="#Docker里的几个基本概念" class="headerlink" title="Docker里的几个基本概念"></a>Docker里的几个基本概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像可以理解为一堆静态的文件</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器则是镜像run起来之后的一个实例。镜像之于容器就好比面向对象编程里的class之于object。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>镜像需要地方保存，这个地方就是仓库<br>上层建立不同的容器，不同的应用镜像打包在不同的容器中，他们互相隔离。</p><h3 id="理解Docker容器"><a href="#理解Docker容器" class="headerlink" title="理解Docker容器"></a>理解Docker容器</h3><p>使用Docker容器运行多个相互隔离的应用时，如下图:</p><p><img src="/assets/blogImg/微信图片_20190131232714.png" alt=""></p><p>不难发现，相比于虚拟机，Docker要简洁很多。因为我们不需要运行一个臃肿的从操作系统了。<br>从下到上理解上图:</p><ul><li>基础设施(Infrastructure)。</li><li>主操作系统(Host Operating System)。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</li><li>Docker守护进程(Docker Daemon)。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。</li><li>各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</li><li>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li></ul><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>使用虚拟机运行多个相互隔离的应用时，如下图:<br>   <img src="/assets/blogImg/微信图片_20190131232908.png" alt=""></p><p>从下到上理解上图:</p><ul><li>基础设施(Infrastructure)。它可以是你的个人电脑，数据中心的服务器，或者是云主机。</li><li>主操作系统(Host Operating System)。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。</li><li>虚拟机管理系统(Hypervisor)。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。</li><li>从操作系统(Guest Operating System)。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</li><li>各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。</li><li>应用。安装依赖之后，就可以在各个从操作系统分别运行应用了，这样各个应用就是相互隔离的。</li></ul><h1 id="对比虚拟机与Docker"><a href="#对比虚拟机与Docker" class="headerlink" title="对比虚拟机与Docker"></a>对比虚拟机与Docker</h1><p>docker设计小巧，部署迁移快速，运行高效，应用之间相互独立，管理人员可以看到所有容器的内容，虚拟化技术比较臃肿，不论什么应用都需要先创建新的系统，并且并非按照应用隔离，而是按照系统隔离，管理员无法看到系统内部信息。</p><p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。</p><h2 id="APP与某信"><a href="#APP与某信" class="headerlink" title="APP与某信"></a>APP与某信</h2><p>举个例子，Docker就是手机中的各种APP，只需要一个系统就可以下载自己所需的应用，但是虚拟化技术相当于你的苹果手机安装一个庞大软件，这个软件上安装安卓系统、魅族系统等，每个系统上还要安装各类应用，比较麻烦。</p><p>但两者没有绝对的好坏，主要还是看应用场景，根据不同的需求选择不同的解决方案即可。</p><h2 id="具体对比"><a href="#具体对比" class="headerlink" title="具体对比"></a>具体对比</h2><ol><li>docker启动快速属于秒级别，虚拟机通常需要几分钟去启动。</li><li>docker需要的资源更少，docker在操作系统级别进行虚拟化，docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。</li><li>docker更轻量，docker的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker运行的镜像数远多于虚拟机数量。对系统的利用率非常高</li><li>与虚拟机相比，docker隔离性更弱，docker属于进程之间的隔离，虚拟机可实现系统级别隔离；</li><li>安全性： docker的安全性也更弱。Docker的租户root和宿主机root等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</li><li>可管理性：docker的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如VMware vCenter提供完备的虚拟机管理能力。</li><li>高可用和可恢复性：docker对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制，VMware可承诺虚拟机99.999%高可用，保证业务连续性。</li><li>快速创建、删除：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.docker.org.cn/book/docker/what-is-docker-16.html" target="_blank" rel="noopener">docker中文社区</a></li><li><a href="https://diveintodocker.com/blog/comparing-virtual-machines-vs-docker-containers" target="_blank" rel="noopener">comparing-virtual-machines-vs-docker-containers</a></li><li><a href="https://www.zhihu.com/question/48174633" target="_blank" rel="noopener">docker容器与虚拟机有什么区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初次接触Docker时，感觉它就像一种轻量级的虚拟机。Docker最初的成功秘诀是因为它比虚拟机更节省内存，启动更快。然而事实并非如此，Docker并非虚拟机，那么什么是Docker呢？它和虚拟机、物理机又有什么区别呢？&lt;/p&gt;
&lt;h1 id=&quot;极简类比&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="云计算" scheme="http://yoursite.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>什么是“平均负载”(二)？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D(%E4%BA%8C)%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是“平均负载”(二)？/</id>
    <published>2019-01-30T12:23:21.000Z</published>
    <updated>2019-01-30T07:16:56.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平均负载与-CPU-使用率"><a href="#平均负载与-CPU-使用率" class="headerlink" title="平均负载与 CPU 使用率"></a>平均负载与 CPU 使用率</h1><p>现实工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，进行一个区分。</p><p>可能你也会有这样的疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，是不是也就意味着 CPU 使用率高？</p><p>我们来看看平均负载的含义，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><p>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><h1 id="平均负载案例分析"><a href="#平均负载案例分析" class="headerlink" title="平均负载案例分析"></a>平均负载案例分析</h1><p>下面，我们以三个示例分别来看这三种情况，并用 iostat、mpstat、pidstat 等工具，找出平均负载升高的根源。</p><h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><p>下面的案例都是基于 Ubuntu 18.04，案例环境如下所示。</p><ul><li>机器配置：2 CPU，2GB 内存。</li><li>预先安装 stress 和 sysstat 包，如 apt install stress sysstat。</li></ul><p>首先介绍一下 stress 和 sysstat。</p><p>stress 是一个 Linux 系统压力测试工具，这里用作异常进程模拟平均负载升高的场景。而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。</p><ul><li>mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</li><li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</li></ul><p>此外，每个场景都需要开三个终端，登录到同一台 Linux 机器中。</p><p>注意，下面的所有命令，默认以普通用户运行。所以，如果遇到权限不够时，一定要运行 sudo su root 命令切换到 root 用户。</p><p>如果上面的环境准备都已经完成了，先用 uptime 命令，看一下测试前的平均负载情况：</p><p><img src="/assets/blogImg/微信图片_20190130145049.png" alt=""></p><h1 id="场景一：CPU-密集型进程"><a href="#场景一：CPU-密集型进程" class="headerlink" title="场景一：CPU 密集型进程"></a>场景一：CPU 密集型进程</h1><p>首先，在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</p><p><img src="/assets/blogImg/微信图片_20190130145322.png" alt=""></p><p>接着，在第二个终端运行 uptime 查看平均负载的变化情况：</p><pre><code># -d 参数表示高亮显示变化的区域$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130145357.png" alt=""></p><p>最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p><pre><code># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据$ mpstat -P ALL 5</code></pre><p><img src="/assets/blogImg/微信图片_20190130145455.png" alt=""></p><p>从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。<br>那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询：</p><pre><code># 间隔 5 秒后输出一组数据$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145553.png" alt=""></p><p>从这里可以明显看到，stress 进程的 CPU 使用率为 99.60%，接近100%。</p><h1 id="场景二：I-O-密集型进程"><a href="#场景二：I-O-密集型进程" class="headerlink" title="场景二：I/O 密集型进程"></a>场景二：I/O 密集型进程</h1><p>首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync：</p><pre><code>$ stress -i 1 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130145648.png" alt="">    </p><p><strong>注意：</strong></p><p>在虚拟机中<code>$ stress -i 1 --timeout 600</code>iowait无法升高，与理论不符？</p><p>iowait无法升高的问题，是因为物理机中stress使用的是 sync() 系统调用，它的作用是刷新缓冲区内存到磁盘中。对于虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了。所以，只会看到只有系统CPU使用率升高。解决方法是使用stress的下一代stress-ng，它支持更丰富的选项，比如 <code>stress-ng -i 1 --hdd 1 --timeout 600（--hdd表示读写临时文件）</code>。</p><pre><code>stress-ng -i 1 --hdd 1 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130145749.png" alt="">    </p><p>在第二个终端运行 uptime 查看平均负载的变化情况：</p><pre><code>$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130145820.png" alt="">    </p><p>然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p><pre><code># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据$ mpstat -P ALL 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145900.png" alt="">    </p><p>从这里可以看到，1 分钟的平均负载会慢慢增加到 0.95，接近1，其中一个 CPU 的系统 CPU 使用率升高到了 6.16，而 iowait 高达 87.44%。这说明，平均负载的升高是由于 iowait 的升高。<br>那么到底是哪个进程，导致 iowait 这么高呢？使用 pidstat 来查询：</p><pre><code># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145950.png" alt=""></p><p>可以发现，还是 stress 进程导致的。</p><h1 id="场景三：大量进程的场景"><a href="#场景三：大量进程的场景" class="headerlink" title="场景三：大量进程的场景"></a>场景三：大量进程的场景</h1><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。<br>比如，我们还是使用 stress，但这次模拟的是 8 个进程：</p><pre><code>$ stress -c 8 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130150052.png" alt=""></p><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97：</p><pre><code>$ uptime或者$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130150119.png" alt=""></p><p>接着再运行 pidstat 来看一下进程的情况：</p><pre><code># 间隔 5 秒后输出一组数据$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130150159.png" alt=""></p><p>可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%左右。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p><h1 id="案例小结"><a href="#案例小结" class="headerlink" title="案例小结"></a>案例小结</h1><p>分析完这三个案例，归纳一下平均负载的理解。</p><p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，需要注意：</p><ul><li>平均负载高有可能是 CPU 密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li><li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li></ul><h1 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h1><h2 id="一、什么是平均负载"><a href="#一、什么是平均负载" class="headerlink" title="一、什么是平均负载"></a>一、什么是平均负载</h2><ul><li>正确定义：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。</li><li>错误定义：单位时间内的cpu使用率。</li><li>可运行状态的进程：正在使用cpu或者正在等待cpu的进程，即ps aux命令下STAT处于R状态的进程</li><li>不可中断状态的进程：处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令D状态的进程</li><li>理想状态：每个cpu上都有一个活跃进程，即平均负载数等于cpu数</li><li>过载经验值：平均负载高于cpu数量70%的时候</li></ul><h2 id="二、相关命令"><a href="#二、相关命令" class="headerlink" title="二、相关命令"></a>二、相关命令</h2><ul><li>cpu核数: lscpu、 grep ‘model name’ /proc/cpuinfo | wc -l</li><li>显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势</li><li>watch -d uptime: -d会高亮显示变化的区域</li><li>strees: 压测命令，–cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，–timeout 执行时间</li><li>mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu</li><li>pidstat: 进程性能分析工具，-u 显示cpu利用率</li></ul><h2 id="三、平均负载与cpu使用率的区别"><a href="#三、平均负载与cpu使用率的区别" class="headerlink" title="三、平均负载与cpu使用率的区别"></a>三、平均负载与cpu使用率的区别</h2><p>CPU使用率：单位时间内cpu繁忙情况的统计</p><ol><li>情况1：CPU密集型进程，CPU使用率和平均负载基本一致</li><li>情况2：IO密集型进程，平均负载升高，CPU使用率不一定升高</li><li>情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高</li></ol><h2 id="四、平均负载过高时，如何调优"><a href="#四、平均负载过高时，如何调优" class="headerlink" title="四、平均负载过高时，如何调优"></a>四、平均负载过高时，如何调优</h2><p>工具：stress、sysstat</p><h3 id="CPU密集型进程case"><a href="#CPU密集型进程case" class="headerlink" title="CPU密集型进程case"></a>CPU密集型进程case</h3><p>mpstat -P ALL 5: -P ALL表示监控所有CPU，5表示每5秒刷新一次数据，观察是否有某个cpu的%usr会很高，但iowait应很低<br>pidstat -u 5 1：每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低，极有可能就是这个进程导致cpu飚高</p><h3 id="IO密集型进程case"><a href="#IO密集型进程case" class="headerlink" title="IO密集型进程case"></a>IO密集型进程case</h3><p>mpstat -P ALL 5: 观察是否有某个cpu的%iowait很高，同时%usr也较高<br>pidstat -u 5 1：观察哪个进程%wait较高，同时%CPU也较高</p><h3 id="大量进程case"><a href="#大量进程case" class="headerlink" title="大量进程case"></a>大量进程case</h3><p>pidstat -u 5 1：观察那些%wait较高的进程是否有很多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平均负载与-CPU-使用率&quot;&gt;&lt;a href=&quot;#平均负载与-CPU-使用率&quot; class=&quot;headerlink&quot; title=&quot;平均负载与 CPU 使用率&quot;&gt;&lt;/a&gt;平均负载与 CPU 使用率&lt;/h1&gt;&lt;p&gt;现实工作中，我们经常容易把平均负载和 CPU 使用率
      
    
    </summary>
    
    
      <category term="系统优化" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>什么是“平均负载”(一)？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D(%E4%B8%80)%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是“平均负载”(一)？/</id>
    <published>2019-01-29T11:24:27.000Z</published>
    <updated>2019-02-11T02:42:26.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看系统平均负载"><a href="#查看系统平均负载" class="headerlink" title="查看系统平均负载"></a>查看系统平均负载</h1><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><pre><code>ubuntu@localhost:~$ uptime 21:41:11 up 57 min,  1 user,  load average: 0.28, 0.09, 0.24</code></pre><p>命令输出的最后内容表示在过去的1、5、15分钟内运行队列中的平均进程数量。一般来说只要每个 CPU 的当前活动进程数不大于3那么系统的性能就是良好的，如果每个 CPU 的任务数大于5，那么就表示这台机器的性能有严重问题。通过</p><pre><code>ubuntu@localhost:~$ grep &apos;model name&apos; /proc/cpuinfo | wc -l1 </code></pre><p>可知该系统此时只有一个 CPU ，则表示其系统性能是良好的。</p><h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p><img src="/assets/blogImg/微信图片_20190129193440.png" alt=""></p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><img src="/assets/blogImg/微信图片_20190129193653.png" alt=""></p><h2 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h2><p><img src="/assets/blogImg/微信图片_20190129193745.png" alt=""> </p><h2 id="tload"><a href="#tload" class="headerlink" title="tload"></a>tload</h2><p><img src="/assets/blogImg/微信图片_20190129200544.png" alt=""> </p><h2 id="loadavg"><a href="#loadavg" class="headerlink" title="loadavg"></a>loadavg</h2><p>这些工具中的平均负载是从 /proc/loadavg 文件中读取的，也可以直接使用 cat 命令查看：</p><pre><code>ubuntu@localhost:~$ cat /proc/loadavg0.48 0.69 0.42 5/452 6570</code></pre><h1 id="“平均负载”是什么？"><a href="#“平均负载”是什么？" class="headerlink" title="“平均负载”是什么？"></a>“平均负载”是什么？</h1><p>当系统变慢时，我们做的第一件事就是在Linux系统终端中输入uptime、w、top、glances、tload等命令来了解系统的负载情况，这几个命令都会有系统平均负载load average的输出，那么系统平均负载是什么呢？</p><h2 id="运行队列中的平均进程数"><a href="#运行队列中的平均进程数" class="headerlink" title="运行队列中的平均进程数"></a>运行队列中的平均进程数</h2><p>Load Average是 CPU 的Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。</p><p>也就是说： </p><p>系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。<br>如果一个进程满足以下条件则其就会位于运行队列中：</p><ul><li>它没有在等待I/O操作的结果</li><li>它没有主动进入等待状态(也就是没有调用’wait’)</li><li>没有被停止(例如：等待终止)</li></ul><h2 id="平均活跃进程数"><a href="#平均活跃进程数" class="headerlink" title="平均活跃进程数"></a>平均活跃进程数</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 利用率并没有直接关系。这里先解释下，可运行状态和不可中断状态这俩词儿。</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p><h3 id="不可中断状态"><a href="#不可中断状态" class="headerlink" title="不可中断状态"></a>不可中断状态</h3><p>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p><p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。</p><p>所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p><p>因此，你可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。</p><h1 id="理解系统平均负载和-CPU-核心数的关系"><a href="#理解系统平均负载和-CPU-核心数的关系" class="headerlink" title="理解系统平均负载和 CPU 核心数的关系"></a>理解系统平均负载和 CPU 核心数的关系</h1><p>考虑了 CPU 核心数的影响，才能解释系统负载。</p><h2 id="多处理器-Vs-多核处理器"><a href="#多处理器-Vs-多核处理器" class="headerlink" title="多处理器 Vs 多核处理器"></a>多处理器 Vs 多核处理器</h2><ul><li>多处理器 – 一个计算机系统中集成两个或多个物理 CPU</li><li>多核处理器 – 单个物理 CPU 有两个或多个单独的核并行工作（也叫处理单元）。双核意味着有两个处理单元，4核有4个处理单元，以此类推。</li></ul><p>此外，Intel 引入了超线程技术用来提高并行计算能力。<br>通过超线程技术，在操作系统中，单个物理 CPU 表现的和两个逻辑 CPU 一样。（实际在硬件上只有一个 CPU）。</p><p>注意，单个 CPU 核同一时间只能执行一个任务，于是产生了多 CPU/处理器、多核 CPU，以及多线程技术。</p><p>多 CPU 时，多个程序可以同时执行。如今的 Intel CPU 使用了多核心和超线程技术。<br>可以使用 nproc 或 lscpu 命令查看系统中的处理器单元数量。</p><pre><code>ubuntu@localhost:~$ nproc4# 或者lscpu也可以使用 grep 命令：ubuntu@localhost:~$ grep &apos;model name&apos; /proc/cpuinfo | wc -l4</code></pre><p>为了进一步理解系统负载，需要做一些假设。假设系统负载如下：</p><pre><code>23:16:49 up  10:49,  5 user,  load average: 1.00, 0.40, 3.35</code></pre><h3 id="在单核系统中意味着："><a href="#在单核系统中意味着：" class="headerlink" title="在单核系统中意味着："></a>在单核系统中意味着：</h3><p>•    CPU 被充分利用（100%）；最近的 1 分钟有 1 个进程在运行。</p><p>•    CPU 有 60% 处于空闲状态；在最近的 5 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均过载了 235%；最近的 15 分钟平均有 2.35 个进程在等待 CPU 时间。</p><h3 id="在双核系统中意味着："><a href="#在双核系统中意味着：" class="headerlink" title="在双核系统中意味着："></a>在双核系统中意味着：</h3><p>•    有一个 CPU 处于完全空闲状态，另一个 CPU 被使用；最近的 1 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均 160% 处于空闲状态；最近的 5 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均过载了 135%；最近的 15 分钟有 1.35 个进程等待 CPU 时间。</p><h1 id="Load-average的算法"><a href="#Load-average的算法" class="headerlink" title="Load average的算法"></a>Load average的算法</h1><p>上面的输出数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以 CPU 的数目，结果高于5的时候就表明系统在超负荷运转了。其算法(摘自Linux 2.6 的内核代码)如下：</p><p><strong>文件: include/linux/sched.h:</strong></p><pre><code>#define FSHIFT        11        /* nr of bits of precision */#define FIXED_1        (1&lt;&lt;FSHIFT)    /* 1.0 as fixed-point */#define LOAD_FREQ    (5*HZ)        /* 5 sec intervals */#define EXP_1        1884        /* 1/exp(5sec/1min) as fixed-point */#define EXP_5        2014        /* 1/exp(5sec/5min) */#define EXP_15        2037        /* 1/exp(5sec/15min) */#define CALC_LOAD(load,exp,n) \    load *= exp; \    load += n*(FIXED_1-exp); \    load &gt;&gt;= FSHIFT;</code></pre><p><strong>文件: kernel/timer.c:</strong></p><pre><code>unsigned long avenrun[3];/* * calc_load - given tick count, update the avenrun load estimates. * This is called while holding a write_lock on xtime_lock. */static inline void calc_load(unsigned long ticks){    unsigned long active_tasks; /* fixed-point */    static int count = LOAD_FREQ;    count -= ticks;    if (count &lt; 0) {        count += LOAD_FREQ;        active_tasks = count_active_tasks();        CALC_LOAD(avenrun[0], EXP_1, active_tasks);        CALC_LOAD(avenrun[1], EXP_5, active_tasks);        CALC_LOAD(avenrun[2], EXP_15, active_tasks);    }}</code></pre><p><strong>文件: fs/proc/proc_misc.c:</strong></p><pre><code>#define LOAD_INT(x) ((x) &gt;&gt; FSHIFT)#define LOAD_FRAC(x) LOAD_INT(((x) &amp; (FIXED_1-1)) * 100)/* * Warning: stuff below (imported functions) assumes that its output will fit * into one page. For some of those functions it may be wrong. Moreover, we * have a way to deal with that gracefully. Right now I used straightforward * wrappers, but this needs further analysis wrt potential overflows. */extern int get_hardware_list(char *);extern int get_stram_list(char *);extern int get_chrdev_list(char *);extern int get_filesystem_list(char *);extern int get_exec_domain_list(char *);extern int get_dma_list(char *);extern int get_locks_status (char *, char **, off_t, int);static int proc_calc_metrics(char *page, char **start, off_t off,                 int count, int *eof, int len){    if (len &lt;= off+count) *eof = 1;    *start = page + off;    len -= off;    if (len&gt;count) len = count;    if (len&lt;0) len = 0;    return len;}static int loadavg_read_proc(char *page, char **start, off_t off,                 int count, int *eof, void *data){    int a, b, c;    int len;    a = avenrun[0] + (FIXED_1/200);    b = avenrun[1] + (FIXED_1/200);    c = avenrun[2] + (FIXED_1/200);    len = sprintf(page,&quot;%d.%02d %d.%02d %d.%02d %ld/%d %d\n&quot;,        LOAD_INT(a), LOAD_FRAC(a),        LOAD_INT(b), LOAD_FRAC(b),        LOAD_INT(c), LOAD_FRAC(c),        nr_running(), nr_threads, last_pid);    return proc_calc_metrics(page, start, off, count, eof, len);}</code></pre><h1 id="平均负载的意义"><a href="#平均负载的意义" class="headerlink" title="平均负载的意义"></a>平均负载的意义</h1><p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p><ul><li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li><li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li><li>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</li></ul><h1 id="平均负载为多少时合理"><a href="#平均负载为多少时合理" class="headerlink" title="平均负载为多少时合理"></a>平均负载为多少时合理</h1><p>回到前面的例子，不知道能否判断出，在那些命令的结果里，其中三个时间段的平均负载数，多大的时候能说明系统负载高？或是多小的时候就能说明系统负载很低呢？</p><p>我们知道，平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时，首先需要知道系统有几个 CPU，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取。有了 CPU 个数，我们就可以判断出，当平均负载比 CPU 个数还大的时候，系统已经出现了过载。</p><p>不过，新的问题又来了。在前面的例子中可以看到，平均负载有三个数值，到底该参考哪一个呢？<br>实际上，都要看。三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，可以更全面、更立体地理解目前的负载状况。</p><h2 id="平均负载的三个时间段"><a href="#平均负载的三个时间段" class="headerlink" title="平均负载的三个时间段"></a>平均负载的三个时间段</h2><p>打个比方，就像初秋时北京的天气，如果只看中午的温度，你可能以为还在 7 月份的大夏天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。<br>同样的，前面说到的 CPU 的三个负载时间段也是这个道理。</p><ul><li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li><li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li><li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。</li></ul><p>这里举个例子，假设在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。</p><h2 id="实际环境中的平均负载"><a href="#实际环境中的平均负载" class="headerlink" title="实际环境中的平均负载"></a>实际环境中的平均负载</h2><p>在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>一般情况，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p><p>但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，再去做分析和调查。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://time.geekbang.org/column/140" target="_blank" rel="noopener">Linux性能优化实战 倪朋飞</a> </li><li><a href="https://www.cnblogs.com/pangguoping/p/5589027.html" target="_blank" rel="noopener">什么是系统平均负载(Load average)</a></li><li><a href="https://linux.cn/article-8632-1.html" target="_blank" rel="noopener">理解 Linux 的平均负载和性能监控</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看系统平均负载&quot;&gt;&lt;a href=&quot;#查看系统平均负载&quot; class=&quot;headerlink&quot; title=&quot;查看系统平均负载&quot;&gt;&lt;/a&gt;查看系统平均负载&lt;/h1&gt;&lt;h2 id=&quot;uptime&quot;&gt;&lt;a href=&quot;#uptime&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="系统优化" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>任务安排</title>
    <link href="http://yoursite.com/%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/"/>
    <id>http://yoursite.com/任务安排/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2018-10-08T03:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境<br>PostgreSQL环境搭建:原理、安装</p><p>2018/7/16    熟悉数据库操作基本流程、数据操作命令、编程接口<br>PostgreSQL语法学习：操作教程、命令语法、编程接口</p><p>2018/7/23    研究HTML界面开发框架数据库操作以及相关开发语言<br>前端学习：Electron开源库+blur-admin响应式模板学习、安装、介绍、接口</p><p>2018/7/30    分析应用场景（场景1：日志分析）数据操作以及数据展示要求，设计数据库表、字段，设计服务程序，创造数据，写入数据库<br>表格创建：应用场景</p><p>2018/8/6    应用场景1：日志分析 中展示要求1，2 界面框架数据库查询接口<br>PostgreSQL连接接口（一）：实现</p><p>2018/8/13    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版以及查询接口”<br>自测功能（一）：</p><p>2018/8/20    应用场景1：日志分析 中展示要求3 界面框架数据库查询接口<br>PostgreSQL接口封装（二）：封装</p><p>2018/8/27    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版、更新查询接口”<br>自测功能（二）：</p><p>2018/9/3    配合HTML界面调试<br>全栈调试（一）：</p><p>2018/9/10    配合HTML界面调试<br>全栈调试（二）：</p><p>2018/9/17    测试、优化<br>测试优化（一）：</p><p>2018/9/24    测试、优化<br>测试优化（二）：</p><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><h2 id="一周：9-10-表格设计与查询显示"><a href="#一周：9-10-表格设计与查询显示" class="headerlink" title="一周：9.10  表格设计与查询显示"></a>一周：9.10  表格设计与查询显示</h2><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><ol><li>从数据表server中获取所有服务器并显示</li><li>可筛选查看</li></ol><h3 id="日志查询"><a href="#日志查询" class="headerlink" title="日志查询"></a>日志查询</h3><ol><li>通过条件从warning中查询日志并显示</li><li>多条件查询，时间、消息类型、电厂名称等</li></ol><h2 id="一周：9-17-实时警告模块设计与实现"><a href="#一周：9-17-实时警告模块设计与实现" class="headerlink" title="一周：9.17 实时警告模块设计与实现"></a>一周：9.17 实时警告模块设计与实现</h2><h3 id="实时告警"><a href="#实时告警" class="headerlink" title="实时告警"></a>实时告警</h3><ol><li>实时（通过定时器）从数据表warning中获取最新的日志显示</li><li>可选择要显示的日志类型、可清空、对日志可以操作状态（已解决、未解决）</li><li>根据重要性统计以饼状图显示（紧急、重要、一般）、并以线性图显示趋势（近一周、近一月、近一年）</li><li>上面显示图表，下面以列表显示日志</li></ol><h2 id="二周：10-1"><a href="#二周：10-1" class="headerlink" title="二周：10.1"></a>二周：10.1</h2><h3 id="系统运行统计图"><a href="#系统运行统计图" class="headerlink" title="系统运行统计图"></a>系统运行统计图</h3><p>9.24<br>柱状图设计与显示：</p><ol><li>按消息类型统计，以柱状图显示</li><li>按操作类型统计，以柱状图显示</li></ol><p>10.1<br>饼状图显示与统计：</p><ol><li>按电厂属性统计，以饼状图显示</li><li>在线统计</li><li>按告警级别统计，以饼状图统计</li></ol><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>10.8  MariaDB数据库学习</p><p>10.15 BLurAdmin界面设计</p><p>系统时间、</p><p>10.22 </p><h1 id="内核基础"><a href="#内核基础" class="headerlink" title="内核基础"></a>内核基础</h1><p>4月初-7月初</p><p>Linux基本操作</p><p>Linux C编程基础：</p><pre><code>工具：gcc、gdb</code></pre><p>c primer plus 源码</p><p>c++ primer plus 原理、实验、心得</p><p>Unix实践编程</p><h1 id="内核代码阅读"><a href="#内核代码阅读" class="headerlink" title="内核代码阅读"></a>内核代码阅读</h1><ol><li><p>多版本源码注释</p></li><li><p>新旧版本知识点对比-&gt;内核演化</p></li></ol><p>09-12</p><p>Linux内核模块编程入门</p><p>list.h</p><p>分页</p><p>进程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;p&gt;2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境&lt;br&gt;PostgreSQL环境搭建:原理、安装&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="安排" scheme="http://yoursite.com/tags/%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E9%98%BF%E9%87%8C%E4%BA%919.9%E5%85%83%E5%AD%A6%E7%94%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%B4%AD%E4%B9%B0%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/阿里云9.9元学生服务器的购买和配置/</id>
    <published>2018-11-21T13:52:32.466Z</published>
    <updated>2018-11-21T13:54:24.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云9-9元学生服务器的购买和配置"><a href="#阿里云9-9元学生服务器的购买和配置" class="headerlink" title="阿里云9.9元学生服务器的购买和配置"></a>阿里云9.9元学生服务器的购买和配置</h1><p><a href="https://blog.csdn.net/luckilywm/article/details/54388494" target="_blank" rel="noopener">https://blog.csdn.net/luckilywm/article/details/54388494</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里云9-9元学生服务器的购买和配置&quot;&gt;&lt;a href=&quot;#阿里云9-9元学生服务器的购买和配置&quot; class=&quot;headerlink&quot; title=&quot;阿里云9.9元学生服务器的购买和配置&quot;&gt;&lt;/a&gt;阿里云9.9元学生服务器的购买和配置&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/IPFS%E5%8E%86%E5%8F%B2%E3%80%81%E7%8E%B0%E7%8A%B6%E5%8F%8A%E6%9C%AA%E6%9D%A5/"/>
    <id>http://yoursite.com/IPFS历史、现状及未来/</id>
    <published>2018-11-06T14:11:57.383Z</published>
    <updated>2018-11-06T14:24:35.754Z</updated>
    
    <content type="html"><![CDATA[<p>IPFS初探</p><p>是什么？</p><p>历史</p><p>现状</p><p>未来</p><p>IPFS  vs   HTTP</p><p>网络文件系统 vs  传统文件系统</p><p>IPFS 协议层</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IPFS初探&lt;/p&gt;
&lt;p&gt;是什么？&lt;/p&gt;
&lt;p&gt;历史&lt;/p&gt;
&lt;p&gt;现状&lt;/p&gt;
&lt;p&gt;未来&lt;/p&gt;
&lt;p&gt;IPFS  vs   HTTP&lt;/p&gt;
&lt;p&gt;网络文件系统 vs  传统文件系统&lt;/p&gt;
&lt;p&gt;IPFS 协议层&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/IPFS%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/IPFS私有网络搭建/</id>
    <published>2018-11-06T14:11:27.870Z</published>
    <updated>2018-11-06T14:25:03.508Z</updated>
    
    <content type="html"><![CDATA[<p>搭建自己的ipfs私有网络<br><a href="https://blog.csdn.net/oscube/article/details/80598790" target="_blank" rel="noopener">https://blog.csdn.net/oscube/article/details/80598790</a></p><p>Linux系统中两种安装go环境的方法<br><a href="https://blog.csdn.net/qq_27278957/article/details/77180365" target="_blank" rel="noopener">https://blog.csdn.net/qq_27278957/article/details/77180365</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建自己的ipfs私有网络&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/oscube/article/details/80598790&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/osc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/IPFS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/IPFS环境搭建与入门教程/</id>
    <published>2018-11-06T14:10:47.279Z</published>
    <updated>2018-11-06T14:27:42.707Z</updated>
    
    <content type="html"><![CDATA[<p>IPFS环境搭建与入门教程</p><p>安装：<a href="https://docs.ipfs.io/introduction/install/" target="_blank" rel="noopener">https://docs.ipfs.io/introduction/install/</a></p><p>上传文件：ipfs  add  index.html</p><p>查看文件： ipfs cat hash_addr</p><p>eg :        ipfs cat  QmSiKZ4kXZEdhsQpXaEyXWiEnp2nwmpNuXWkZhhnoXzgSN</p><p><a href="https://ipfs.io/ipfs/" target="_blank" rel="noopener">https://ipfs.io/ipfs/</a><br><a href="https://localhost:8080/ipfs/" target="_blank" rel="noopener">https://localhost:8080/ipfs/</a></p><p>上传目录：ipfs add -r index.html</p><p>查看视频：<br><a href="http://localhost:8080/ipfs/QmfZTpaNwJTx9qEYGNzFvEFdc1T7ieyNeqWDrKD2PgsQPp" target="_blank" rel="noopener">http://localhost:8080/ipfs/QmfZTpaNwJTx9qEYGNzFvEFdc1T7ieyNeqWDrKD2PgsQPp</a></p><p><a href="http://localhost:8080/ipfs/QmfA1KVT47g8L9fPS3AT9JSAufL6P9pigX6jtnrLFXK6ZE" target="_blank" rel="noopener">http://localhost:8080/ipfs/QmfA1KVT47g8L9fPS3AT9JSAufL6P9pigX6jtnrLFXK6ZE</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IPFS环境搭建与入门教程&lt;/p&gt;
&lt;p&gt;安装：&lt;a href=&quot;https://docs.ipfs.io/introduction/install/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.ipfs.io/introduc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/IPFS%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%A1%E5%88%92%E5%88%B6%E5%AE%9A/"/>
    <id>http://yoursite.com/IPFS学习方法与计划制定/</id>
    <published>2018-11-06T04:14:31.951Z</published>
    <updated>2018-11-06T14:09:53.254Z</updated>
    
    <content type="html"><![CDATA[<p>IPFS文档：</p><pre><code>IPFS历史、现状及未来IPFS学习方法与计划制定IPFS环境搭建与入门教程IPFS搭建私有网络IPFS私有网络存储研究</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IPFS文档：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPFS历史、现状及未来
IPFS学习方法与计划制定
IPFS环境搭建与入门教程
IPFS搭建私有网络
IPFS私有网络存储研究
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E8%AE%A1%E5%88%92%E8%A1%A8/"/>
    <id>http://yoursite.com/第一阶段计划表/</id>
    <published>2018-11-03T05:02:48.000Z</published>
    <updated>2018-10-08T00:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一周：9-10"><a href="#一周：9-10" class="headerlink" title="一周：9.10"></a>一周：9.10</h1><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><ol><li>从数据表server中获取所有服务器并显示</li><li>可筛选查看</li></ol><h3 id="日志查询"><a href="#日志查询" class="headerlink" title="日志查询"></a>日志查询</h3><ol><li>通过条件从warning中查询日志并显示</li><li>多条件查询，时间、消息类型、电厂名称等</li></ol><h1 id="一周：9-17"><a href="#一周：9-17" class="headerlink" title="一周：9.17"></a>一周：9.17</h1><h3 id="实时告警"><a href="#实时告警" class="headerlink" title="实时告警"></a>实时告警</h3><ol><li>实时（通过定时器）从数据表warning中获取最新的日志显示</li><li>可选择要显示的日志类型、可清空、对日志可以操作状态（已解决、未解决）</li><li>根据重要性统计以饼状图显示（紧急、重要、一般）、并以线性图显示趋势（近一周、近一月、近一年）</li><li>上面显示图表，下面以列表显示日志</li></ol><h1 id="二周：10-1"><a href="#二周：10-1" class="headerlink" title="二周：10.1"></a>二周：10.1</h1><h3 id="系统运行统计图"><a href="#系统运行统计图" class="headerlink" title="系统运行统计图"></a>系统运行统计图</h3><ol><li>按消息类型统计，以柱状图显示</li><li>按操作类型统计，以柱状图显示</li><li>按电厂属性统计，以饼状图显示</li><li>在线统计</li><li>按告警级别统计，以饼状图统计</li></ol><p>第二阶段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一周：9-10&quot;&gt;&lt;a href=&quot;#一周：9-10&quot; class=&quot;headerlink&quot; title=&quot;一周：9.10&quot;&gt;&lt;/a&gt;一周：9.10&lt;/h1&gt;&lt;h3 id=&quot;服务器管理&quot;&gt;&lt;a href=&quot;#服务器管理&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E5%A4%A7%E5%AD%A6/"/>
    <id>http://yoursite.com/开源大学/</id>
    <published>2018-11-03T05:02:48.000Z</published>
    <updated>2018-10-01T23:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>开源大学</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开源大学&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/编译和链接/</id>
    <published>2018-11-03T05:02:48.000Z</published>
    <updated>2018-08-28T22:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-编译和链接"><a href="#第一章-编译和链接" class="headerlink" title="第一章 编译和链接"></a>第一章 编译和链接</h1><p>C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编译和链接，形成可执行文件在操作系统下执行时，我们是否会发出以下疑问：</p><ol><li>C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？</li><li>C代码中经常会包含头文件，那么，什么是头文件？什么又是C语言库？</li><li>我们经常说main函数是C语言程序的入口，难道不能把其它函数当入口？</li><li>不同的操作系统上编译好的程序可以直接拷贝过去运行吗？</li></ol><p>如果上面的问题你都能回答的话，那么就可以跳过本节。如果你不知道或者不是很清楚，那么我们就顺着这个思路探究下去。</p><h2 id="1-C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？"><a href="#1-C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？" class="headerlink" title="1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？"></a>1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？</h2><p>我们以最经典的HelloWorld程序为例。先使用vim等文本编辑器写好代码，接着在终端执行编译命令（使用的Linux系统是Debian）：</p><pre><code>gcc HelloWorld.c -o HelloWorld </code></pre><p>这条命令在编译的同时进行了链接，形成了可执行文件HelloWorld，最后我们在终端执行 ./HelloWorld，顺利地显示了输出结果。</p><pre><code>debian@bogon:~/Documents/HelloWorld$ vim HelloWorld.cdebian@bogon:~/Documents/HelloWorld$ gcc HelloWorld.c -o HelloWorlddebian@bogon:~/Documents/HelloWorld$ ./HelloWorld Hello World!debian@bogon:~/Documents/HelloWorld$</code></pre><p>可是，简单的命令背后经过了什么样的处理过程？gcc真的就“直接”生成了最后的可执行文件了？当然不是，我们在gcc编译命令行加上参数 –verbose要求gcc输出完整的处理过程(命令行加上 -v 也行)，我们看到了一段较长的过程输出。</p><pre><code>debian@bogon:~/Documents/HelloWorld$ gcc --verbose HelloWorld.c -o HelloWorldUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapperTarget: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion=&apos;Debian 6.3.0-18+deb9u1&apos; --with-bugurl=file:///usr/share/doc/gcc-6/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-6 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-6-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-6-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-6-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; /usr/lib/gcc/x86_64-linux-gnu/6/cc1 -quiet -v -imultiarch x86_64-linux-gnu HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/ccKizfOU.sGNU C11 (Debian 6.3.0-18+deb9u1) version 6.3.0 20170516 (x86_64-linux-gnu)    compiled by GNU C version 6.3.0 20170516, GMP version 6.1.2, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15GGC heuristics: --param ggc-min-expand=62 --param ggc-min-heapsize=60678ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/include&quot;#include &quot;...&quot; search starts here:#include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/6/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/6/include-fixed /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.GNU C11 (Debian 6.3.0-18+deb9u1) version 6.3.0 20170516 (x86_64-linux-gnu)    compiled by GNU C version 6.3.0 20170516, GMP version 6.1.2, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15GGC heuristics: --param ggc-min-expand=62 --param ggc-min-heapsize=60678Compiler executable checksum: b8e5d7f3c4236757ee0871869b8330f3COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; as -v --64 -o /tmp/ccyb9gCU.o /tmp/ccKizfOU.sGNU assembler version 2.28 (x86_64-linux-gnu) using BFD version (GNU Binutils for Debian) 2.28COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../:/lib/:/usr/lib/COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; /usr/lib/gcc/x86_64-linux-gnu/6/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/6/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapper -plugin-opt=-fresolution=/tmp/ccj2W1uU.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o HelloWorld /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/6/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/6 -L/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/6/../../.. /tmp/ccyb9gCU.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/6/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/crtn.oCOLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos;debian@bogon:~/Documents/HelloWorld$</code></pre><p>在此，我们不截取输出结果的完整图了，但你可以自己试验，然后试着分析整个流程。</p><p>图1是gcc编译过程的分解图：</p><p><img src="https://i.imgur.com/adD90hj.png" alt=""></p><p>从图中我们大致可以看出gcc处理HelloWorld.c的大致过程：</p><p>预处理(Prepressing)—&gt;编译(Compilation)—&gt;汇编(Assembly)—&gt;链接(Linking)</p><p>括号中注明了各个过程中实际执行任务的程序名称：预处理器cpp、编译器cc1、汇编器as以及最后的链接器ld。</p><h2 id="2-预处理到底做什么？"><a href="#2-预处理到底做什么？" class="headerlink" title="2. 预处理到底做什么？"></a>2. 预处理到底做什么？</h2><p>我们在终端输入命令 <code>gcc -E HelloWorld.c -o HelloWorld.i</code>，然后打开输出文件HelloWorld.i：</p><pre><code># 1 &quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot; 1 3 4# 28 &quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot; 2 3 4typedef unsigned char __u_char;typedef unsigned short int __u_short;typedef unsigned int __u_int;typedef unsigned long int __u_long;</code></pre><p>首先是大段的变量和函数的声明，我们的代码找不到了，到底去哪了？在vim编辑环境的普通模式中按下shift+g(大写G)跳到文件的底部，终于在几千行以后看到了我们可怜兮兮的几行代码。   </p><pre><code>int main(){ printf(&quot;Hello World!\n&quot;); return 0;}</code></pre><p>前面几千行代码是做什么的？其实它就是 /usr/include/stdio.h 文件的所有内容，预处理器把所有的#include替换为实际文件的内容了。这个过程是递归进行的，所以stdio.h里面的#include也被实际内容所替换了。</p><p>而且我在HelloWorld.c里面的所有注释被预处理器全部删除了。就连printf语句前的Tab缩进也被替换为一个空格了，显得代码都不美观了。</p><p>通过观察这些内容，我们梳理出预处理器处理的大致所做的事情：</p><ul><li>展开所有的宏定义并删除 #define</li><li>处理所有的条件编译指令，例如 #if #else #endif #ifndef …</li><li>把所有的 #include 替换为头文件实际内容，递归进行</li><li>把所有的注释 // 和 / / 替换为空格</li><li>添加行号和文件名标识以供编译器使用</li><li>保留所有的 #pragma 指令，因为编译器要使用</li></ul><p>基本上就是这些内容。（在这里顺便插播一个小技巧，在代码中有时候宏定义比较复杂的时候我们很难判断其处理后的结构是否正确。这个时候我们就可以使用gcc的-E参数输出处理结果来判断）</p><p>前文中我们提到头文件中存放的是变量定义和函数声明等等内容。这些内容到底是什么？其实在早期调用函数时并不需要声明，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，所有编译器开始要求对所有使用的变量或者函数给出声明，以支持编译器进行参数检查和类型匹配。头文件包含的基本上就是这些东西和一些预先的宏定义来方便程序员编程。其实对于我们的HelloWorld.c程序来说不需要这个庞大的头文件，只需要在main函数前声明printf函数，不需要#include即可通过编译。</p><p>声明如下：</p><pre><code>int printf(const char *format, ...);</code></pre><p>大家可以自行测试。另外再补充一点，gcc其实并不要求函数一定要在被调用之前定义或者声明，因为gcc在处理到某个未知类型的函数时，会为其创建一个隐式声明，并假设该函数返回值类型为int。但gcc此时无法检查传递给该函数的实参类型和个数是否正确，不利于编译器为我们排除错误（而且如果该函数的返回值不是int的话也会出错）。所以还是建议大家在函数调用前，先对其定义或声明。</p><h2 id="3-编译做什么？"><a href="#3-编译做什么？" class="headerlink" title="3. 编译做什么？"></a>3. 编译做什么？</h2><p>了解了预处理之后，我们接着看编译和汇编。什么是编译？一句话描述：编译就是把预处理之后的文件进行一系列词法分析、语法分析、语义分析以及优化后生成的相应汇编代码文件。</p><p>怎么查看编译后的汇编代码？命令：</p><pre><code>gcc -S HelloWorld.c -o HelloWorld.s</code></pre><p>这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意。顺便说一句，这里生成的汇编是AT&amp;T风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 -masm=intel ,这样gcc就会生成Intel风格的汇编代码了（如图）。不过gcc的内联汇编只支持AT&amp;T风格，我们在第二章会给予介绍。</p><pre><code>    .file    &quot;HelloWorld.c&quot;    .intel_syntax noprefix    .section    .rodata.LC0:    .string    &quot;Hello World!&quot;    .text    .globl    main    .type    main, @functionmain:.LFB0:    .cfi_startproc    push    rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    mov    rbp, rsp    .cfi_def_cfa_register 6    lea    rdi, .LC0[rip]    call    puts@PLT    mov    eax, 0    pop    rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc.LFE0:    .size    main, .-main    .ident    &quot;GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516&quot;    .section    .note.GNU-stack,&quot;&quot;,@progbits</code></pre><h2 id="4-汇编做什么？"><a href="#4-汇编做什么？" class="headerlink" title="4. 汇编做什么？"></a>4. 汇编做什么？</h2><p>我们继续用一句话来描述：汇编就是将编译后的汇编代码翻译为机器码，几乎每一条汇编指令对应一句机器码。</p><p>命令：</p><pre><code>gcc -c HelloWorld.c </code></pre><p>可以让编译器只进行到生成目标文件这一步，这样我们就能在目录下看到HelloWorld.o文件了。</p><p>Linux下的可执行文件以及目标文件的格式叫作ELF(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，Linux下的ELF也罢，都是COFF(Common file format)格式的一种变种，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因不只是这一点，不同的操作系统接口（windows API和Linux的API不同）以及相关的类库不同也是原因之一。</p><p>更详细的内容可以参看《程序员的自我修养》了解。</p><h2 id="5-链接做什么？"><a href="#5-链接做什么？" class="headerlink" title="5. 链接做什么？"></a>5. 链接做什么？</h2><p>这一步是将汇编产生的目标文件和所使用的库函数的目标文件链接生成一个可执行文件的过程。在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一是链接造成的错误通常难以理解和处理，二是在开发中使用第三方库越来越常见了，大家可能更需要稍微了解一些细节。</p><p>首先介绍一下gnu binutils工具包，这是一整套的二进制分析处理工具包。详细介绍请大家参考维基百科：<a href="http://zh.wikipedia.org/wiki/GNU_Binutils" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/GNU_Binutils</a></p><p>一般系统安装包中都带了这套工具包，如果你的发行版没有，请自行搜索进行安装。</p><p>这套工具包含了足够多的工具，我们甚至可以用来研究ELF文件的格式等内容。不过本节只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。</p><p>链接这个话题涉及的内容相当广泛，为了避免本节牵扯到过多的话题导致言之泛泛，我们先设定本节讨论的范围。在这里只讨论链接进行的大致步骤及其规则、静态链接库与动态链接库的创建和使用这两大问题。至于可执行文件的加载、可执行文件的运行时储存器映像之类的内容我们暂时不讨论。<br>那么，什么是链接？我们引用《深入理解计算机系统》中的定义：链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。</p><p>需要强调的是，链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时（run time），由应用程序来执行。</p><p>那么，了解链接到底有什么用？继续引用《深入理解计算机系统》的说法，如下：</p><ol><li>理解链接器将帮助你构造大型程序。</li><li>理解链接器将帮助你避免一些危险的编程错误。</li><li>理解链接将帮助你理解语言的作用域是如何实现的。</li><li>理解链接将帮助你理解其他重要的系统概念。</li><li>理解链接将使你能够利用共享库。</li></ol><p>言归正传。为了避免我们的描述过于枯燥，我们还是以C语言为例。大家通过我们前面的描述，已经知道C代码编译后的目标文件了。目标文件最终要和标准库进行链接生成最后的可执行文件。那么，标准库和我们生成的目标文件是什么关系？</p><p>其实，任何一个程序，它的背后都有一套庞大的代码在支撑着它，以使得该程序能够正常运行。这套代码至少包括入口函数、以及其所依赖的函数构成的函数集合。当然，它还包含了各种标准库函数的实现。</p><p>这个“支撑模块”就叫做运行时库（Runtime Library）。而C语言的运行库，即被称为C运行时库（CRT）。</p><p>CRT大致包括：启动与退出相关的代码（包括入口函数及入口函数所依赖的其他函数）、标准库函数（ANSI C标准规定的函数实现）、I/O相关、堆的封装实现、语言特殊功能的实现以及调试相关。其中标准库函数的实现占据了主要地位。标准库函数比如我们平时常用的printf，scanf函数等。C语言标准库在不同的平台上实现了不同的版本，我们只要依赖其接口定义，就能保证程序在不同平台上的一致行为。C语言标准库有24个，囊括标准输入输出、文件操作、字符串操作、数学函数以及日期等等内容。大家有兴趣的可以自行搜索。</p><h3 id="5-1-静态链接库"><a href="#5-1-静态链接库" class="headerlink" title="5.1 静态链接库"></a>5.1 静态链接库</h3><p>既然C语言提供了标准库函数供我们使用，那么以什么形式提供？是源代码吗？当然不是。下面引入静态链接库的概念。我们几乎每一次写程序都难免去使用库函数，那么每一次去编译岂不是太麻烦了。干嘛不把标准库函数提前编译好，需要的时候直接链接？是的，标准库就是这么做的。<br>那么，标准库以什么形式存在？是一个目标文件？我们知道，链接的最小单位就是一个个目标文件，如果我们只用到一个printf函数，但需要和整个库链接的话岂不是太浪费资源了么？但是，如果把库函数分别定义在彼此独立的代码文件中，这样编译出后就形成一大堆目标文件。所以，编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库（static library）。当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。这样就解决了资源浪费的问题。</p><p>Linux/Unix系统下ANSI C的库名叫做libc.a，另外数学函数单独在libm.a库中。当了解以上相关知识后，我们试着自己做一个静态库。为了简单起见我们就做一个只有两个函数的私有库。</p><p>在swap.c里定义一个swap函数，在add.c里定义了一个add函数。最后还有含有它们声明的calc.h头文件。</p><pre><code>// swap.cvoid swap(int *num1, int *num2){    int tmp = *num1;    *num1 = *num2;    *num2 = tmp;}// add.cint add(int a, int b){    return a + b;}// calc.h#ifndef CALC_H_#define CALC_H_#ifdef _cplusplusextern &quot;C&quot;{#endifvoid swap(int *, int *);int add(int, int);#ifdef _cplusplus}#endif#endif // CALC_H_</code></pre><p>我们分别编译它们得到了swap.o和add.o这两个目标文件，最后使用ar命令将其打包为一个静态库。</p><pre><code>debian@bogon:~/Documents/link$ gcc add.c -c -o add.odebian@bogon:~/Documents/link$ gcc swap.c -c -o swap.odebian@bogon:~/Documents/link$ lsadd.c  add.o  calc.h  swap.c  swap.odebian@bogon:~/Documents/link$ ar rcs libcalc.a swap.o add.odebian@bogon:~/Documents/link$ lsadd.c  add.o  calc.h  libcalc.a  swap.c  swap.odebian@bogon:~/Documents/link$ </code></pre><p>现在我们怎么使用这个静态库呢？我们写一个test.c使用这个库中的swap函数。代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;calc.h&quot;int main(int argc, char *argv[]){    int a = 1, b = 2;    swap(&amp;a, &amp;b);    printf(&quot;%d %d\n&quot;, a, b);    return EXIT_SUCCESS;}</code></pre><p>下来是编译执行，命令行执行gcc test.c ./libcalc.a -o test编译，执行。如图，我们输出了预期的结果。</p><pre><code>debian@bogon:~/Documents/link$ gcc test.c ./libcalc.a -o testdebian@bogon:~/Documents/link$ ./test2 1debian@bogon:~/Documents/link$ </code></pre><p>可能你会问，我们使用C语言标准库的时候，编译时并不需要加库名。是的，的确不需要，那是因为标准库已经是标准了，所以会被默认链接。不过因为数学函数库libm.a没有默认链接，所以我们使用了数学函数的代码在编译时需要在命令行指定 -lm 链接（-l是指定链接库，m是去掉lib之后的库名），不过现在好多gcc都默认链接libm.c库了。</p><p>正如我们所看到的，静态链接库解决了一些问题，但是它同时带来了另一些问题。比如说每一个使用了相同的C标准函数的程序都需要和相关目标文件进行链接，浪费磁盘空间；当一个程序有多个副本执行时，相同的库代码部分被载入内存，浪费内存；当库代码更新之后，使用这些库的函数必须全部重新编译等等。</p><h3 id="5-2-动态链接库"><a href="#5-2-动态链接库" class="headerlink" title="5.2 动态链接库"></a>5.2 动态链接库</h3><p>是否有更好的办法？当然有。我们接下来引入动态链接库/共享库（shared library）。</p><p>动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。这个过程就是动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序完成的。</p><p>Unix/Linux中共享库的后缀名通常是.so（微软就是DLL文件）。那么，如何建立一个动态链接库？</p><p>我们还是以上面的代码为例，首先删除之前的静态库和目标文件。要建立动态链接库，在命令行输入：</p><pre><code>gcc swap.c add.c -shared -o libcalc.so </code></pre><p>顺便说一下，最好在gcc命令行加上一句-fPIC让其生成与位置无关的代码（PIC），具体原因超出本文范围，故暂不予讨论。</p><pre><code>debian@bogon:~/Documents/link$ gcc swap.c add.c -shared -o libcalc.sodebian@bogon:~/Documents/link$ lsadd.c  add.o  calc.h  libcalc.a  libcalc.so  swap.c  swap.o  test  test.cdebian@bogon:~/Documents/link$ </code></pre><p>如何使用动态链接库？我们继续编译测试代码，执行<code>gcc test.c -o test ./libcalc.so</code>即可。运行后我们仍旧得到了预期的结果。</p><pre><code>debian@bogon:~/Documents/link$ gcc test.c -o test ./libcalc.sodebian@bogon:~/Documents/link$ ./test 2 1debian@bogon:~/Documents/link$</code></pre><p>这看起来也没什么不一样的。其实不然，我们用ldd命令（ldd是我们推荐的GNU binutils工具包的组成之一）检查test文件的依赖。</p><pre><code>debian@bogon:~/Documents/link$ ldd ./test    linux-vdso.so.1 (0x00007fff3d3fb000)    ./libcalc.so (0x00007f61c97de000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61c943f000)    /lib64/ld-linux-x86-64.so.2 (0x00007f61c9be2000)debian@bogon:~/Documents/link$ </code></pre><p>我们看到这个文件能顺利运行需要依赖libcalc.so这个动态库，我们还能看到C语言的标准库默认也是动态链接的（在gcc编译的命令行加上 -static 可以要求静态链接）。</p><p>好处何在？第一，库更新之后，只需要替换掉动态库文件即可，无需编译所有依赖库的可执行文件。第二，程序有多个副本执行时，内存中只需要一份库代码，节省空间。</p><p>大家想想，C语言标准库好多程序都在用，但内存只有一份代码，这样节省的空间就相当可观了，而且假如库代码发现bug，只需要更新libc.so即可，所有程序即可使用新的代码，代码的可维护性提高。</p><p>关于库的内容还很多，就此介绍到这里。</p><h3 id="5-3-链接的步骤"><a href="#5-3-链接的步骤" class="headerlink" title="5.3 链接的步骤"></a>5.3 链接的步骤</h3><p>我们来看看链接过程中具体做的事情<strong>。链接的步骤大致包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等主要步骤。</strong></p><p>首先是地址和空间分配，我们之前提到的目标文件其实全称叫做可重定位目标文件（这只是一种名称，还有其他名称）。目标文件的格式已经无限度接近可执行文件了，Unix/Linux下的目标文件的格式叫做ELF（Executable and Linkable Format，可执行连接格式）。本节暂不详细讨论可执行文件的格式，我们只需要知道可执行文件中代码，数据，符号等内容分别存储在不同的段中就可以，这也和第二章保护模式下的内存分段是有一定关系的。我们简单叙述了地址和空间分配以及重定位，但是稍微详细说明一下符号决议。</p><p><strong>什么是符号（symbol）？简单说我们在代码中定义的函数和变量可以统称为符号。符号名（symbol name）就是函数名和变量名了。</strong></p><p>目标文件的拼合其实也就是对目标文件之间相互的符号引用的一个修正。我们知道一个C语言代码文件只要所有的符号被声明过就可以通过编译了，可是对某符号的引用怎么知道位置呢？比如我们调用了printf函数，编译时留下了要填入的函数地址，那么printf函数的实际地址在哪里？这个空位什么时候修正呢？当然是链接的时候，重定位那一步就是做这个的。但是在修改地址之前需要做符号决议，那什么是符号决议？正如前文所说，编译期间留下了很多需要重新定位的符号，所以目标文件中会有一块区域专门保存符号表。链接器如何知道具体位置？其实链接器并不知道，所以链接器会搜索全部的待链接的目标文件，寻找这个符号的位置，然后修正每一个符号的地址。</p><p><strong>在此我们要重点介绍一下在编译程序时几乎所有人会遇见的问题——符号查找问题。在编译时通常会碰到两种编译错误，即找不到某符号或者符号重定义。</strong></p><p>首先介绍找不到符号的情况，比如，当我们声明了一个swap函数却没有定义它的时候，我们调用这个函数的代码可以通过编译，但是在链接期间却会遇到错误。形如“test.c:(.text+0x29): undefined reference to ‘swap’”这样，特别的，MSVC编译器报错是找不到符号_swap。这个下划线从哪里来的？这得从C语言刚诞生说起。当C语言刚面世的时候，已经存在不少用汇编语言写好的库了，因为链接器的符号唯一规则，假如该库中存在main函数，我们就不能在C代码中出现main函数了，因为会遭遇符号重定义错误，倘若放弃这些库又是一大损失。所以当时的编译器会对代码中的符号进行修饰（name decoration），C语言的代码会在符号前加下划线，fortran语言在符号前后都加下划线，这样各个目标文件就不会同名了，就解决了符号冲突的问题。随着时间的流逝，操作系统和编译器都被重写了好多遍，当前的这个问题已经可以忽略。所以新版的gcc一般不会再加下划线做符号修饰（也可以在编译的命令行加上-fleading-underscore/-fno-fleading-underscore开打开/关闭这个是否加下划线）。而MSVC依旧保留了这个传统，所以我们可以看到_swap这样的修饰。</p><p>顺便说一下，符号冲突是很常见的事情，特别是在大型项目的开发中，所以我们需要一个约定良好的命名规则。C++也引入了命名空间来帮助我们解决这些问题，因为C++中存在函数重载，所以C++的符号修饰更加复杂难懂（Linux下有c++filt命令帮助我们翻译一个被C++编译器修饰过的符号）。</p><p>那么，当出现同名符号时链接器到底如何处理。刚才说过会报告重名错误，为什么还要进行探讨？实际上，不仅仅这么简单。在编译时，编译器会向汇编器输出每个全局符号，分为强（strong）符号和弱符号（weak），汇编器把这个信息隐含的编码在可重定位目标文件的符号表里。其中函数和已初始化过的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义，GNU链接器采用的规则如下：</p><ol><li>不允许多个强符号</li><li>如果有一个强符号和一个或多个弱符号，则选择强符号</li><li>如果有多个弱符号，则随机选择一个</li></ol><p>其中，第一条会报符号重名错误的，而后两条默认情况下甚至连警告都不会有。关键就在这里，默认甚至连警告都没有。</p><p>我们来个实验具体说一下：</p><pre><code>// link1.c#include &lt;stdio.h&gt;int n;int main(int argc, char *argv[]){    printf(&quot;It is %d\n&quot;, n);    return 0;}// link2.cint n = 5;</code></pre><p>这两个文件编译运行会输出什么呢？想必你已经知道了结果，没错，就是5</p><pre><code>debian@bogon:~/Documents/link$ vim link1.cdebian@bogon:~/Documents/link$ vim link2.cdebian@bogon:~/Documents/link$ gcc link1.c link2.c -o linkdebian@bogon:~/Documents/link$ ./link It is 5debian@bogon:~/Documents/link$ </code></pre><p>初始化过的n是强符号，被优先选择了。但是，在很复杂的项目代码中，这样的错误很难发现，特别是多线程的代码，不过当我们怀疑代码中的bug可能是因为此原因引起的时候，我们可以在gcc命令行加上-fno-common这个参数，这样链接器在遇到多重定义的符号时，都会给出一条警告信息，而无关强弱符号。如下所示：</p><pre><code>debian@bogon:~/Documents/link$ gcc link1.c link2.c -o link -fno-common/tmp/ccJnlWp9.o:(.data+0x0): multiple definition of `n&apos;/tmp/ccM5uYLR.o:(.bss+0x0): first defined herecollect2: error: ld returned 1 exit statusdebian@bogon:~/Documents/link$ </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-编译和链接&quot;&gt;&lt;a href=&quot;#第一章-编译和链接&quot; class=&quot;headerlink&quot; title=&quot;第一章 编译和链接&quot;&gt;&lt;/a&gt;第一章 编译和链接&lt;/h1&gt;&lt;p&gt;C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编译和链接，形成可执行文件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    <id>http://yoursite.com/编译、链接与装载/</id>
    <published>2018-11-03T05:02:48.000Z</published>
    <updated>2018-09-02T02:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-编译、链接与装载"><a href="#第一章-编译、链接与装载" class="headerlink" title="第一章 编译、链接与装载"></a>第一章 编译、链接与装载</h1><p>C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编译和链接，形成可执行文件在操作系统下执行时，我们是否会发出以下疑问：</p><ol><li>C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？</li><li>C代码中经常会包含头文件，那么，什么是头文件？什么又是C语言库？</li><li>我们经常说main函数是C语言程序的入口，难道不能把其它函数当入口？</li><li>不同的操作系统上编译好的程序可以直接拷贝过去运行吗？</li></ol><p>如果上面的问题你都能回答的话，那么就可以跳过本节。如果你不知道或者不是很清楚，那么我们就顺着这个思路探究下去。</p><h2 id="1-C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？"><a href="#1-C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？" class="headerlink" title="1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？"></a>1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？</h2><p>我们以最经典的HelloWorld程序为例。先使用vim等文本编辑器写好代码，接着在终端执行编译命令（使用的Linux系统是Debian）：</p><pre><code>gcc HelloWorld.c -o HelloWorld </code></pre><p>这条命令在编译的同时进行了链接，形成了可执行文件HelloWorld，最后我们在终端执行 ./HelloWorld，顺利地显示了输出结果。</p><pre><code>debian@bogon:~$ vim HelloWorld.cdebian@bogon:~$ gcc HelloWorld.c -o HelloWorlddebian@bogon:~$ ./HelloWorld Hello World!debian@bogon:~$</code></pre><p>可是，简单的命令背后经过了什么样的处理过程？gcc真的就“直接”生成了最后的可执行文件了？当然不是，我们在gcc编译命令行加上参数 –verbose要求gcc输出完整的处理过程(命令行加上 -v 也行)，我们看到了一段较长的过程输出。</p><pre><code>debian@bogon:~$ gcc --verbose HelloWorld.c -o HelloWorldUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapperTarget: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion=&apos;Debian 6.3.0-18+deb9u1&apos; ......</code></pre><p>在此，我们不截取输出结果的完整图了，但你可以自己试验，然后试着分析整个流程。</p><p>图1是gcc编译过程的分解图：</p><p><img src="https://i.imgur.com/adD90hj.png" alt=""></p><p>从图中我们大致可以看出gcc处理HelloWorld.c的大致过程：</p><p>预处理(Prepressing)—&gt;编译(Compilation)—&gt;汇编(Assembly)—&gt;链接(Linking)</p><p>括号中注明了各个过程中实际执行任务的程序名称：预处理器cpp、编译器cc1、汇编器as以及最后的链接器ld。</p><h2 id="2-预处理到底做什么？"><a href="#2-预处理到底做什么？" class="headerlink" title="2. 预处理到底做什么？"></a>2. 预处理到底做什么？</h2><p>我们在终端输入命令 <code>gcc -E HelloWorld.c -o HelloWorld.i</code>，然后打开输出文件HelloWorld.i：</p><pre><code># 1 &quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot; 1 3 4# 28 &quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot; 2 3 4typedef unsigned char __u_char;typedef unsigned short int __u_short;typedef unsigned int __u_int;typedef unsigned long int __u_long;</code></pre><p>首先是大段的变量和函数的声明，我们的代码找不到了，到底去哪了？在vim编辑环境的普通模式中按下shift+g(大写G)跳到文件的底部，终于在几千行以后看到了我们可怜兮兮的几行代码。   </p><pre><code>int main(){ printf(&quot;Hello World!\n&quot;); return 0;}</code></pre><p>前面几千行代码是做什么的？其实它就是 /usr/include/stdio.h 文件的所有内容，预处理器把所有的#include替换为实际文件的内容了。这个过程是递归进行的，所以stdio.h里面的#include也被实际内容所替换了。</p><p>而且我在HelloWorld.c里面的所有注释被预处理器全部删除了。就连printf语句前的Tab缩进也被替换为一个空格了，显得代码都不美观了。</p><p>通过观察这些内容，我们梳理出预处理器处理的大致所做的事情：</p><ul><li>展开所有的宏定义并删除 #define</li><li>处理所有的条件编译指令，例如 #if #else #endif #ifndef …</li><li>把所有的 #include 替换为头文件实际内容，递归进行</li><li>把所有的注释 // 和 / / 替换为空格</li><li>添加行号和文件名标识以供编译器使用</li><li>保留所有的 #pragma 指令，因为编译器要使用</li></ul><p>基本上就是这些内容。（在这里顺便插播一个小技巧，在代码中有时候宏定义比较复杂的时候我们很难判断其处理后的结构是否正确。这个时候我们就可以使用gcc的-E参数输出处理结果来判断）</p><p>前文中我们提到头文件中存放的是变量定义和函数声明等等内容。这些内容到底是什么？其实在早期调用函数时并不需要声明，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，所有编译器开始要求对所有使用的变量或者函数给出声明，以支持编译器进行参数检查和类型匹配。头文件包含的基本上就是这些东西和一些预先的宏定义来方便程序员编程。其实对于我们的HelloWorld.c程序来说不需要这个庞大的头文件，只需要在main函数前声明printf函数，不需要#include即可通过编译。</p><p>声明如下：</p><pre><code>int printf(const char *format, ...);</code></pre><p>大家可以自行测试。另外再补充一点，gcc其实并不要求函数一定要在被调用之前定义或者声明，因为gcc在处理到某个未知类型的函数时，会为其创建一个隐式声明，并假设该函数返回值类型为int。但gcc此时无法检查传递给该函数的实参类型和个数是否正确，不利于编译器为我们排除错误（而且如果该函数的返回值不是int的话也会出错）。所以还是建议大家在函数调用前，先对其定义或声明。</p><h2 id="3-编译做什么？"><a href="#3-编译做什么？" class="headerlink" title="3. 编译做什么？"></a>3. 编译做什么？</h2><p>了解了预处理之后，我们接着看编译和汇编。什么是编译？一句话描述：编译就是把预处理之后的文件进行一系列词法分析、语法分析、语义分析以及优化后生成的相应汇编代码文件。</p><p>怎么查看编译后的汇编代码？命令：</p><pre><code>gcc -S HelloWorld.c -o HelloWorld.s</code></pre><p>这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意。顺便说一句，这里生成的汇编是AT&amp;T风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 -masm=intel ,这样gcc就会生成Intel风格的汇编代码了（如图）。不过gcc的内联汇编只支持AT&amp;T风格，我们在第二章会给予介绍。</p><pre><code>    .file    &quot;HelloWorld.c&quot;    .intel_syntax noprefix    .section    .rodata.LC0:    .string    &quot;Hello World!&quot;    .text    .globl    main    .type    main, @functionmain:.LFB0:    .cfi_startproc    push    rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    mov    rbp, rsp    .cfi_def_cfa_register 6    lea    rdi, .LC0[rip]    call    puts@PLT    mov    eax, 0    pop    rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc.LFE0:    .size    main, .-main    .ident    &quot;GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516&quot;    .section    .note.GNU-stack,&quot;&quot;,@progbits</code></pre><h2 id="4-汇编做什么？"><a href="#4-汇编做什么？" class="headerlink" title="4. 汇编做什么？"></a>4. 汇编做什么？</h2><p>我们继续用一句话来描述：汇编就是将编译后的汇编代码翻译为机器码，几乎每一条汇编指令对应一句机器码。</p><p>命令：</p><pre><code>gcc -c HelloWorld.c </code></pre><p>可以让编译器只进行到生成目标文件这一步，这样我们就能在目录下看到HelloWorld.o文件了。</p><p>Linux下的可执行文件以及目标文件的格式叫作ELF(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，Linux下的ELF也罢，都是COFF(Common file format)格式的一种变种，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因不只是这一点，不同的操作系统接口（windows API和Linux的API不同）以及相关的类库不同也是原因之一。</p><p>更详细的内容可以参看《程序员的自我修养》了解。</p><h2 id="5-链接做什么？"><a href="#5-链接做什么？" class="headerlink" title="5. 链接做什么？"></a>5. 链接做什么？</h2><p>这一步是将汇编产生的目标文件和所使用的库函数的目标文件链接生成一个可执行文件的过程。在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一是链接造成的错误通常难以理解和处理，二是在开发中使用第三方库越来越常见了，大家可能更需要稍微了解一些细节。</p><p>首先介绍一下gnu binutils工具包，这是一整套的二进制分析处理工具包。详细介绍请大家参考维基百科：<a href="http://zh.wikipedia.org/wiki/GNU_Binutils" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/GNU_Binutils</a></p><p>一般系统安装包中都带了这套工具包，如果你的发行版没有，请自行搜索进行安装。</p><p>这套工具包含了足够多的工具，我们甚至可以用来研究ELF文件的格式等内容。不过本节只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。</p><p>链接这个话题涉及的内容相当广泛，为了避免本节牵扯到过多的话题导致言之泛泛，我们先设定本节讨论的范围。在这里只讨论链接进行的大致步骤及其规则、静态链接库与动态链接库的创建和使用这两大问题。至于可执行文件的加载、可执行文件的运行时储存器映像之类的内容我们暂时不讨论。<br>那么，什么是链接？我们引用《深入理解计算机系统》中的定义：链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。</p><p>需要强调的是，链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时（run time），由应用程序来执行。</p><p>那么，了解链接到底有什么用？继续引用《深入理解计算机系统》的说法，如下：</p><ol><li>理解链接器将帮助你构造大型程序。</li><li>理解链接器将帮助你避免一些危险的编程错误。</li><li>理解链接将帮助你理解语言的作用域是如何实现的。</li><li>理解链接将帮助你理解其他重要的系统概念。</li><li>理解链接将使你能够利用共享库。</li></ol><p>言归正传。为了避免我们的描述过于枯燥，我们还是以C语言为例。大家通过我们前面的描述，已经知道C代码编译后的目标文件了。目标文件最终要和标准库进行链接生成最后的可执行文件。那么，标准库和我们生成的目标文件是什么关系？</p><p>其实，任何一个程序，它的背后都有一套庞大的代码在支撑着它，以使得该程序能够正常运行。这套代码至少包括入口函数、以及其所依赖的函数构成的函数集合。当然，它还包含了各种标准库函数的实现。</p><p>这个“支撑模块”就叫做运行时库（Runtime Library）。而C语言的运行库，即被称为C运行时库（CRT）。</p><p>CRT大致包括：启动与退出相关的代码（包括入口函数及入口函数所依赖的其他函数）、标准库函数（ANSI C标准规定的函数实现）、I/O相关、堆的封装实现、语言特殊功能的实现以及调试相关。其中标准库函数的实现占据了主要地位。标准库函数比如我们平时常用的printf，scanf函数等。C语言标准库在不同的平台上实现了不同的版本，我们只要依赖其接口定义，就能保证程序在不同平台上的一致行为。C语言标准库有24个，囊括标准输入输出、文件操作、字符串操作、数学函数以及日期等等内容。大家有兴趣的可以自行搜索。</p><h3 id="5-1-静态链接库"><a href="#5-1-静态链接库" class="headerlink" title="5.1 静态链接库"></a>5.1 静态链接库</h3><p>既然C语言提供了标准库函数供我们使用，那么以什么形式提供？是源代码吗？当然不是。下面引入静态链接库的概念。我们几乎每一次写程序都难免去使用库函数，那么每一次去编译岂不是太麻烦了。干嘛不把标准库函数提前编译好，需要的时候直接链接？是的，标准库就是这么做的。<br>那么，标准库以什么形式存在？是一个目标文件？我们知道，链接的最小单位就是一个个目标文件，如果我们只用到一个printf函数，但需要和整个库链接的话岂不是太浪费资源了么？但是，如果把库函数分别定义在彼此独立的代码文件中，这样编译出后就形成一大堆目标文件。所以，编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库（static library）。当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。这样就解决了资源浪费的问题。</p><p>Linux/Unix系统下ANSI C的库名叫做libc.a，另外数学函数单独在libm.a库中。当了解以上相关知识后，我们试着自己做一个静态库。为了简单起见我们就做一个只有两个函数的私有库。</p><p>在swap.c里定义一个swap函数，在add.c里定义了一个add函数。最后还有含有它们声明的calc.h头文件。</p><pre><code>// swap.cvoid swap(int *num1, int *num2){    int tmp = *num1;    *num1 = *num2;    *num2 = tmp;}// add.cint add(int a, int b){    return a + b;}// calc.h#ifndef CALC_H_#define CALC_H_#ifdef _cplusplusextern &quot;C&quot;{#endifvoid swap(int *, int *);int add(int, int);#ifdef _cplusplus}#endif#endif // CALC_H_</code></pre><p>我们分别编译它们得到了swap.o和add.o这两个目标文件，最后使用ar命令将其打包为一个静态库。</p><pre><code>debian@bogon:~/link$ gcc add.c -c -o add.odebian@bogon:~/link$ gcc swap.c -c -o swap.odebian@bogon:~/link$ lsadd.c  add.o  calc.h  swap.c  swap.odebian@bogon:~/link$ ar rcs libcalc.a swap.o add.odebian@bogon:~/link$ lsadd.c  add.o  calc.h  libcalc.a  swap.c  swap.odebian@bogon:~/link$ </code></pre><p>现在我们怎么使用这个静态库呢？我们写一个test.c使用这个库中的swap函数。代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;calc.h&quot;int main(int argc, char *argv[]){    int a = 1, b = 2;    swap(&amp;a, &amp;b);    printf(&quot;%d %d\n&quot;, a, b);    return EXIT_SUCCESS;}</code></pre><p>下来是编译执行，命令行执行gcc test.c ./libcalc.a -o test编译，执行。如图，我们输出了预期的结果。</p><pre><code>debian@bogon:~/link$ gcc test.c ./libcalc.a -o testdebian@bogon:~/link$ ./test2 1debian@bogon:~/link$ </code></pre><p>可能你会问，我们使用C语言标准库的时候，编译时并不需要加库名。是的，的确不需要，那是因为标准库已经是标准了，所以会被默认链接。不过因为数学函数库libm.a没有默认链接，所以我们使用了数学函数的代码在编译时需要在命令行指定 -lm 链接（-l是指定链接库，m是去掉lib之后的库名），不过现在好多gcc都默认链接libm.c库了。</p><p>正如我们所看到的，静态链接库解决了一些问题，但是它同时带来了另一些问题。比如说每一个使用了相同的C标准函数的程序都需要和相关目标文件进行链接，浪费磁盘空间；当一个程序有多个副本执行时，相同的库代码部分被载入内存，浪费内存；当库代码更新之后，使用这些库的函数必须全部重新编译等等。</p><h3 id="5-2-动态链接库"><a href="#5-2-动态链接库" class="headerlink" title="5.2 动态链接库"></a>5.2 动态链接库</h3><p>是否有更好的办法？当然有。我们接下来引入动态链接库/共享库（shared library）。</p><p>动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。这个过程就是动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序完成的。</p><p>Unix/Linux中共享库的后缀名通常是.so（微软就是DLL文件）。那么，如何建立一个动态链接库？</p><p>我们还是以上面的代码为例，首先删除之前的静态库和目标文件。要建立动态链接库，在命令行输入：</p><pre><code>gcc swap.c add.c -shared -o libcalc.so </code></pre><p>顺便说一下，最好在gcc命令行加上一句-fPIC让其生成与位置无关的代码（PIC），具体原因超出本文范围，故暂不予讨论。</p><pre><code>debian@bogon:~/link$ gcc swap.c add.c -shared -o libcalc.sodebian@bogon:~/link$ lsadd.c  add.o  calc.h  libcalc.a  libcalc.so  swap.c  swap.o  test  test.cdebian@bogon:~/link$ </code></pre><p>如何使用动态链接库？我们继续编译测试代码，执行<code>gcc test.c -o test ./libcalc.so</code>即可。运行后我们仍旧得到了预期的结果。</p><pre><code>debian@bogon:~/link$ gcc test.c -o test ./libcalc.sodebian@bogon:~/link$ ./test 2 1debian@bogon:~/link$</code></pre><p>这看起来也没什么不一样的。其实不然，我们用ldd命令（ldd是我们推荐的GNU binutils工具包的组成之一）检查test文件的依赖。</p><pre><code>debian@bogon:~/link$ ldd ./test    linux-vdso.so.1 (0x00007fff3d3fb000)    ./libcalc.so (0x00007f61c97de000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61c943f000)    /lib64/ld-linux-x86-64.so.2 (0x00007f61c9be2000)debian@bogon:~/link$ </code></pre><p>我们看到这个文件能顺利运行需要依赖libcalc.so这个动态库，我们还能看到C语言的标准库默认也是动态链接的（在gcc编译的命令行加上 -static 可以要求静态链接）。</p><p>好处何在？第一，库更新之后，只需要替换掉动态库文件即可，无需编译所有依赖库的可执行文件。第二，程序有多个副本执行时，内存中只需要一份库代码，节省空间。</p><p>大家想想，C语言标准库好多程序都在用，但内存只有一份代码，这样节省的空间就相当可观了，而且假如库代码发现bug，只需要更新libc.so即可，所有程序即可使用新的代码，代码的可维护性提高。</p><p>关于库的内容还很多，就此介绍到这里。</p><h3 id="5-3-链接的步骤"><a href="#5-3-链接的步骤" class="headerlink" title="5.3 链接的步骤"></a>5.3 链接的步骤</h3><p>我们来看看链接过程中具体做的事情<strong>。链接的步骤大致包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等主要步骤。</strong></p><p>首先是地址和空间分配，我们之前提到的目标文件其实全称叫做可重定位目标文件（这只是一种名称，还有其他名称）。目标文件的格式已经无限度接近可执行文件了，Unix/Linux下的目标文件的格式叫做ELF（Executable and Linkable Format，可执行连接格式）。本节暂不详细讨论可执行文件的格式，我们只需要知道可执行文件中代码，数据，符号等内容分别存储在不同的段中就可以，这也和第二章保护模式下的内存分段是有一定关系的。我们简单叙述了地址和空间分配以及重定位，但是稍微详细说明一下符号决议。</p><p><strong>什么是符号（symbol）？简单说我们在代码中定义的函数和变量可以统称为符号。符号名（symbol name）就是函数名和变量名了。</strong></p><p>目标文件的拼合其实也就是对目标文件之间相互的符号引用的一个修正。我们知道一个C语言代码文件只要所有的符号被声明过就可以通过编译了，可是对某符号的引用怎么知道位置呢？比如我们调用了printf函数，编译时留下了要填入的函数地址，那么printf函数的实际地址在哪里？这个空位什么时候修正呢？当然是链接的时候，重定位那一步就是做这个的。但是在修改地址之前需要做符号决议，那什么是符号决议？正如前文所说，编译期间留下了很多需要重新定位的符号，所以目标文件中会有一块区域专门保存符号表。链接器如何知道具体位置？其实链接器并不知道，所以链接器会搜索全部的待链接的目标文件，寻找这个符号的位置，然后修正每一个符号的地址。</p><p><strong>在此我们要重点介绍一下在编译程序时几乎所有人会遇见的问题——符号查找问题。在编译时通常会碰到两种编译错误，即找不到某符号或者符号重定义。</strong></p><p>首先介绍找不到符号的情况，比如，当我们声明了一个swap函数却没有定义它的时候，我们调用这个函数的代码可以通过编译，但是在链接期间却会遇到错误。形如“test.c:(.text+0x29): undefined reference to ‘swap’”这样，特别的，MSVC编译器报错是找不到符号_swap。这个下划线从哪里来的？这得从C语言刚诞生说起。当C语言刚面世的时候，已经存在不少用汇编语言写好的库了，因为链接器的符号唯一规则，假如该库中存在main函数，我们就不能在C代码中出现main函数了，因为会遭遇符号重定义错误，倘若放弃这些库又是一大损失。所以当时的编译器会对代码中的符号进行修饰（name decoration），C语言的代码会在符号前加下划线，fortran语言在符号前后都加下划线，这样各个目标文件就不会同名了，就解决了符号冲突的问题。随着时间的流逝，操作系统和编译器都被重写了好多遍，当前的这个问题已经可以忽略。所以新版的gcc一般不会再加下划线做符号修饰（也可以在编译的命令行加上-fleading-underscore/-fno-fleading-underscore开打开/关闭这个是否加下划线）。而MSVC依旧保留了这个传统，所以我们可以看到_swap这样的修饰。</p><p>顺便说一下，符号冲突是很常见的事情，特别是在大型项目的开发中，所以我们需要一个约定良好的命名规则。C++也引入了命名空间来帮助我们解决这些问题，因为C++中存在函数重载，所以C++的符号修饰更加复杂难懂（Linux下有c++filt命令帮助我们翻译一个被C++编译器修饰过的符号）。</p><p>那么，当出现同名符号时链接器到底如何处理。刚才说过会报告重名错误，为什么还要进行探讨？实际上，不仅仅这么简单。在编译时，编译器会向汇编器输出每个全局符号，分为强（strong）符号和弱符号（weak），汇编器把这个信息隐含的编码在可重定位目标文件的符号表里。其中函数和已初始化过的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义，GNU链接器采用的规则如下：</p><ol><li>不允许多个强符号</li><li>如果有一个强符号和一个或多个弱符号，则选择强符号</li><li>如果有多个弱符号，则随机选择一个</li></ol><p>其中，第一条会报符号重名错误的，而后两条默认情况下甚至连警告都不会有。关键就在这里，默认甚至连警告都没有。</p><p>我们来个实验具体说一下：</p><pre><code>// link1.c#include &lt;stdio.h&gt;int n;int main(int argc, char *argv[]){    printf(&quot;It is %d\n&quot;, n);    return 0;}// link2.cint n = 5;</code></pre><p>这两个文件编译运行会输出什么呢？想必你已经知道了结果，没错，就是5</p><pre><code>debian@bogon:~/link$ vim link1.cdebian@bogon:~/link$ vim link2.cdebian@bogon:~/link$ gcc link1.c link2.c -o linkdebian@bogon:~/link$ ./link It is 5debian@bogon:~/link$ </code></pre><p>初始化过的n是强符号，被优先选择了。但是，在很复杂的项目代码中，这样的错误很难发现，特别是多线程的代码，不过当我们怀疑代码中的bug可能是因为此原因引起的时候，我们可以在gcc命令行加上-fno-common这个参数，这样链接器在遇到多重定义的符号时，都会给出一条警告信息，而无关强弱符号。如下所示：</p><pre><code>debian@bogon:~/link$ gcc link1.c link2.c -o link -fno-common/tmp/ccJnlWp9.o:(.data+0x0): multiple definition of `n&apos;/tmp/ccM5uYLR.o:(.bss+0x0): first defined herecollect2: error: ld returned 1 exit statusdebian@bogon:~/link$ </code></pre><h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><p>每个程序被运行起来以后，将拥有独立的虚拟地址空间（virtual address space），该虚拟地址空间的大小由计算机的硬件平台决定，具体的说由CPU的位数决定。硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为 0 到 2^32 - 1 ，即0x00000000 ~ 0xFFFFFFFF，也就是常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了 2^64 字节，即0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，总共17 179 869 184 GB.</p><p>从程序的角度看，可以通过判断C语言程序中的指针所占的空间来计算虚拟地址空间的大小，一般来说，C语言指针大小的位数与虚拟空间的位数相同，如 32 位平台下的指针为 32 位，即 4字节； 64位平台下的指针为64位，即8字节。有些特殊情况这种规则不成立。 </p><p>对于32平台来说，4GB的虚拟内存空间，只有较低的3GB（从虚地址0x00000000 到 0xBFFFFFFF）供各个进程自己使用，称为用户空间；而最高的1GB（从虚地址0xC0000000 到 0xFFFFFFFF）供内核使用（所有的进程共享），称为内核空间，如下图所示。 </p><p><img src="https://img-blog.csdn.net/20170706161644890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHlfbGF1cmVs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>程序执行时所需要的指令和数据必须在内存中才能正常运行，最简单的就是将程序运行所需要的指令和数据全都装入内存中，这就是最简单的静态装入的办法。但是大多数情况程序所需的内存大于物理内存，内存昂贵，希望在不添加内存时让更多的程序运行起来。研究发现，程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><p>覆盖装入在没有虚拟存储之前使用广泛，现在已经淘汰，跳过。</p><h2 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h2><p>页映射是虚拟存储机制的一部分，随着虚拟存储的发明而诞生。将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页。</p><p><strong>实例</strong>：假设有台32位机器，共16KB内存，每个页为4KB（4096字节）。假设程序所有的指令和数据总和为32KB，那么程序总共被分为8个页，编号P0~P7.16KB的物理内存无法同时装入32KB程序，按照动态装入的原理进行整个装入过程。若程序刚开始执行时的入口地址在P0，这时装载管理器发现程序的P0不在内存中，于是将物理内存F0分配给P0，，并且将P0的内容装入F0；运行一段时间后，程序需要用到P5，于是装载管理器将P5装入F1；当程序用到P3、P6时，分别被装入F2和F3，如下映射：</p><p><img src="https://img-blog.csdn.net/20170706153929330?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHlfbGF1cmVs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>如图此时程序用到了P0、P3、P5和P6，占据了所有的物理内存，若程序需要访问P4，那么装载管理器（OS的存储管理器）必须做出抉择，它必须放弃目前正在使用的4个内存页中的一个来装载P4。至于选择哪个页，有多种算法可以选择，比如可以选择F0，因为它是第一个被分配掉的内存页（FIFO，先进先出算法）；假设装载管理器发现F2很少被访问到，那么可以选择F2（LRU，Least Recently Used，最少使用算法）。目前主流的操作系统都是按照这种方式装载可执行文件。</p><h2 id="从操作系统角度看可执行文件的装载"><a href="#从操作系统角度看可执行文件的装载" class="headerlink" title="从操作系统角度看可执行文件的装载"></a>从操作系统角度看可执行文件的装载</h2><p>从OS角度看，一个进程最关键的特征是它拥有独立的虚拟地址空间，使得它有别于其他进程。很多时候一个程序被执行同时伴随着一个新进程的创建：创建一个进程，装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间。</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><h3 id="1-创建虚拟地址空间"><a href="#1-创建虚拟地址空间" class="headerlink" title="1.创建虚拟地址空间"></a>1.创建虚拟地址空间</h3><p>  一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。 </p><h3 id="2-读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"><a href="#2-读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系" class="headerlink" title="2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"></a>2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</h3><p>上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。当操作系统捕获到缺页错误时，应该知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。这是整个装载过程中最重要的一步。</p><p>可执行文件在装载时实际上是被映射到虚拟空间，所以可执行文件又被叫做映像文件image。<br>Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。VMA是一个很重要的概念，对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。</p><h3 id="3-将CPU指令寄存器设置成可执行文件入口，启动运行"><a href="#3-将CPU指令寄存器设置成可执行文件入口，启动运行" class="headerlink" title="3.将CPU指令寄存器设置成可执行文件入口，启动运行"></a>3.将CPU指令寄存器设置成可执行文件入口，启动运行</h3><p>操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步在操作系统层面上比较复杂，涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。在进程的角度看可以简单地认为操作系统执行了一条跳转指令，直接跳转至可执行文件的入口地址，也就是ELF文件头保存的地址。</p><h2 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h2><p>上面的步骤执行完以后，实际上可执行文件的真正指令和数据都没有被转入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。当CPU准备执行某个地址的指令时，发现其是个空页面，就认为是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况，这时候转载过程的第二步建立的数据结构起到了关键作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权交还给进程，进程从刚才页错误的位置重新开始执行。 </p><p><img src="https://img-blog.csdn.net/20170706162009883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHlfbGF1cmVs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h2 id="进程虚存空间分布"><a href="#进程虚存空间分布" class="headerlink" title="进程虚存空间分布"></a>进程虚存空间分布</h2><p>操作系统只关心一些跟装载相关的问题，最主要的就是段的权限（可读、可写、可执行）。ELF问减重往往只有为数不多的几种组合，基本如下三种：</p><ul><li>以代码段为代表的权限为可读可执行的段。</li><li>以数据段和BSS段为代表的权限为可读可写的段。</li><li>以只读数据段为代表的权限为只读的段。</li></ul><p>操作系统通过使用VMA来对进程的地址空间进行管理，栈、堆在进程的虚拟空间中同样也是以VMA的形式存在。在Linux下，可以通过查看/proc/$PID/maps获取指定进程的虚拟空间分布： </p><p><img src="https://img-blog.csdn.net/20170706161356343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHlfbGF1cmVs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><ul><li>第一列是VMA的地址范围； </li><li>第二列是VMA的权限，r-读，w-写，x-可执行，p-表示私有（COW,Copy on Write），s-共享； </li><li>第三列是偏移，表示VMA对应的Segment在映像文件中的偏移； </li><li>第四列表示映像文件所在设备的主设备号和次设备号； </li><li>第五列表示映像文件的节点号； </li><li>最后一列是映像文件的路径。</li></ul><p>该进程的5个VMA中，只有前两个是映射到可执行文件中的两个segment，另外3个主次设备号和节点号都是0，没有映射到文件中，这种VMA叫做匿名虚拟内存区域（Anonymous Virtual Memory Area）。堆占140KB，栈占88KB，这两个VMA几乎所有的进程都存在，malloc内存分配就是从堆里分配，堆由系统库管理。最后一个VMA叫做“vdso”，它的地址已经位于内核空间（即大于0xC0000000的地址），事实上它是一个内核模块，进程可以通过访问这个VMA来跟内核进行一些通信。 </p><p>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几个VMA区域：</p><ul><li>代码VMA，只读、可执行；有映像文件。</li><li>数据VMA，可读写、可执行；有映像文件。</li><li>堆VMA，可读写，可执行；无映像文件，匿名，可向上扩展。</li><li>栈VMA，可读写、不可执行；无映像文件，匿名，可向下扩展。</li></ul><p><img src="https://img-blog.csdn.net/20170706161255264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHlfbGF1cmVs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h2 id="Linux内核装载ELF过程"><a href="#Linux内核装载ELF过程" class="headerlink" title="Linux内核装载ELF过程"></a>Linux内核装载ELF过程</h2><p>在Linux的bash下输入一个命令执行某个ELF程序时，首先在用户层面，bash进程会调用fork系统调用创建一个新的进程，然后新的进程调用execve系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。<br>  <br>在进入execve系统调用之后，Linux内核就开始进行真正的装载工作。在内核中，execve系统调用相应函数定义在exec.c(3.14版内核)文件中：</p><pre><code>SYSCALL_DEFINE3(execve,        const char __user *, filename,        const char __user *const __user *, argv,        const char __user *const __user *, envp){    return do_execve(getname(filename), argv, envp);}</code></pre><p>最终调用do_execve会查找被执行的文件，如果找到文件检查权限，则读取文件的前128字节(BINPRM_BUF_SIZE)。 </p><h3 id="为什么要读取前128字节呢"><a href="#为什么要读取前128字节呢" class="headerlink" title="为什么要读取前128字节呢?"></a>为什么要读取前128字节呢?</h3><p>众所周知，Linux支持的可执行文件不止ELF一种，还有a.out、Java程序和以“#！”开始的脚本程序，读取文件的前128字节目的是判断文件的格式，每种可执行文件的格式开头几个字节都是很特殊的，特别是开头4个字节，常常被称为魔数（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如ELF的可执行文件格式的头4个字节为0x7F、e、l、f；而java的可执行文件格式头4个字节为c、a、f、e；如果被执行的是Shell或者perl、python等解释型脚本语言，那么他的第一行往往是”#!/bin/bash”或“#!/usr/bin/perl”或“#!/usr/bin/python”，这时候前两个字节‘#’和“！”就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p><p>当do_execve()读取了前128字节的文件头部之后，然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handle()会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做load_elf_bingary()；a.out可执行文件的装载处理过程叫做load_aout_binary()；而装载可执行脚本程序的处理过程叫做load_script()。ELF的load_elf_binary()被定义在fs/Binfmt_elf.c，主要步骤是：</p><ol><li>检查ELF可执行文件格式的有效性。比如魔数、程序头表中段（segment）的数量；</li><li>寻找动态链接的“.interp”段，设置动态链接器路径（与动态链接有关）。</li><li>根据ELF可执行文件程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是iELFwenjian的文件头中e_entry所指的地址了对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li></ol><p>当load_elf_binary()执行完毕，返回至do_execve，上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了。所以当execve()系统调用从内核态返回到用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-编译、链接与装载&quot;&gt;&lt;a href=&quot;#第一章-编译、链接与装载&quot; class=&quot;headerlink&quot; title=&quot;第一章 编译、链接与装载&quot;&gt;&lt;/a&gt;第一章 编译、链接与装载&lt;/h1&gt;&lt;p&gt;C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90-%E5%AD%9F%E5%AE%81/"/>
    <id>http://yoursite.com/Linux内核分析-孟宁/</id>
    <published>2018-11-03T05:02:46.000Z</published>
    <updated>2018-06-13T16:15:42.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/Hello%20Docker%20World/"/>
    <id>http://yoursite.com/Hello Docker World/</id>
    <published>2018-11-03T05:02:46.000Z</published>
    <updated>2018-09-28T05:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装Docker命令：</p><p>#wget -qO- <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | sh</p><p>允许非root用户：</p><p>#usermod -aG docker xxx //把xxx用户添加到docker用户组中</p><p>拉docker镜像：</p><p>#docker pull nginx  </p><p>查看已安装docker镜像：</p><p>#docker images</p><p>启动nginx服务</p><p>#docker run -p 8080:80 -d nginx </p><p>列出运行中的容器</p><p>#docker ps</p><p>编辑html文件，添加Hello Docker World</p><p>#vim index.html</p><p>拷贝文件：</p><p>#docker cp index.html 容器id://usr/share/nginx/html</p><p>查看主页：<br>localhost:8080</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装Docker命令：&lt;/p&gt;
&lt;p&gt;#wget -qO- &lt;a href=&quot;https://get.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://get.docker.com&lt;/a&gt; | sh&lt;/p&gt;
&lt;p&gt;允许非r
      
    
    </summary>
    
    
  </entry>
  
</feed>
