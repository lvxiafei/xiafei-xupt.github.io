<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiafei-xupt&#39;s blog</title>
  
  <subtitle>汝之意志所向,即吾剑之所指</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-14T16:52:56.787Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiafei-xupt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netdata开源产品分析</title>
    <link href="http://yoursite.com/Netdata%E5%BC%80%E6%BA%90%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/Netdata开源产品分析/</id>
    <published>2020-06-14T16:45:57.000Z</published>
    <updated>2020-06-14T16:52:56.787Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/80839230-b034a800-8baf-11ea-9cb2-99c1e10f0f85.gif" alt><br><a href="https://london.my-netdata.io/" target="_blank" rel="noopener">Live Demo Site（点我）</a></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><ul><li>Netdata是针对系统和应用程序的分布式，实时性能和运行状况监视。它是您在所有系统和容器上安装的高度优化的监视代理。</li><li>Netdata 使用高度互动的Web仪表板实时提供了无与伦比的洞察力，可实时了解运行在其上的系统（包括Web服务器，数据库，应用程序）上发生的一切。</li><li>高效的数据库以1秒的粒度存储几天，几周或几个月的长期历史指标。自动运行此长期存储，或将Netdata与您现有的监视工具链（Prometheus，Graphite，OpenTSDB，Kafka，Grafana等）集成。</li><li>Netdata是快速和有效的，旨在对所有的系统（永久运行物理和虚拟服务器， 集装箱，物联网设备），而不会破坏其核心功能。</li><li>Netdata是免费的开源软件，目前可在Linux，FreeBSD和macOS以及从它们衍生的其他系统（例如Kubernetes和Docker）上运行。</li><li>Netdata不是由CNCF托管的，而是Cloud Native Computing Foundation（CNCF）领域中排名第四的开源项目。</li></ul><p>/*该产品主要解决用户的什么问题；使用的用户是那些，有什么特征；该产品分为那几个部分；功能模块有那些，视觉表现上怎么样。<br>*/</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>优美的界面：bootstrap框架下的控制界面, 酷炫（主要是dark主题，light主题就没这感觉了）</li><li>自定义的控制界面：你可以使用简单的HTML代码去自定义控制界面(不需要使用javascript)</li><li>极其的快速而高效：程序使用C进行编写(默认安装下，预计只有2%的单核CPU使用率和少许的内存使用率)</li><li>零配置：你只需要去安装它，接着它就会自动地监测一切数据</li><li>零依赖：它的静态网络文件和网络接口拥有自己的网络服务器. netdata有自己的web server， 提供静态web文件和web API</li><li>可扩展：用它自身的插件API(可以使用许多方式来制作它的插件，从bash到node.js),你可以检测任何可以衡量的数据。</li><li>可嵌入：它可以在任何Linux内核可以运行的地方运行</li><li>零维护：只管跑    </li><li>匪夷所思的快。。。所有请求每个metreic都在0.5ms内响应，即便是一台烂机器</li><li>非常高效，每秒采集数千个指标，但仅占cpu单核1%，少量MB的内存以及完全没有磁盘IO</li><li>提供复杂的、各种类型的告警，支持动态阈值、告警模板、多种通知方式等</li><li>支撑多种时间序列后端服务，比如graphite, opentsdb, prometheus, json document DBs</li></ul><p><strong>注：</strong>老版本的，仅供参考</p><h2 id="监测内容"><a href="#监测内容" class="headerlink" title="监测内容"></a>监测内容</h2><p>下面是Netdata目前检测的内容（大多数都不需要进行配置，安装后即可开始监测）</p><ol><li>CPU的使用率,中断，软中断和频率(总量和每个单核)</li><li>RAM，互换和内核内存的使用率（包括KSM和内核内存deduper）</li><li>硬盘输入/输出(每个硬盘的带宽，操作，整理，利用等)</li><li>IPv4网络（数据包，错误，分片）：<br>TCP：连接，数据包，错误，握手<br>UDP:数据包，错误<br>广播：带宽，数据包<br>组播：带宽，数据包</li><li>Netfilter/iptables Linux防火墙(连接，连接跟踪事件，错误等)</li><li>进程(运行，受阻，分叉，活动等)</li><li>NFS文件服务器，v2,v3,v4(输入/输出，缓存，预读，RPC调用)</li><li>网络服务质量（唯一一个可实时可视化网络状况的工具）</li><li>应用程序，通过对进程树进行分组（CPU,内存，硬盘读取，硬盘写入，交换，线程，管道，套接字等）</li><li>Apache Web服务器状态(v2.2, v2.4)</li><li>Nginx Web服务器状态</li><li>Mysql数据库（多台服务器，单个显示：带宽，查询/s, 处理者，锁，问题，临时操作，连接，二进制日志，线程，innodb引擎等）</li><li>ISC Bind域名服务器（多个服务器，单个显示：客户，请求，查询，更新，失败等）</li><li>Postfix邮件服务器的消息队列（条目，大小）</li><li>Squid代理服务器（客户带宽和请求，服务带宽和请求）</li><li>硬件传感器（温度，电压，风扇，电源，湿度等）</li><li>NUT UPSes（负载，充电，电池电压，温度，使用指标，输出指标）</li></ol><p>可以监测任意数量的SNMP服务，不过你需要进行配置，还可以对此软件进行扩展，可以使用任何语言编写插件，以此来从任何来源收集数据</p><p><strong>注：</strong>老版本的，仅供参考</p><h2 id="参考效果"><a href="#参考效果" class="headerlink" title="参考效果"></a>参考效果</h2><p><img src="/assets/blogImg/907596-20170807172707487-897415577.gif" alt></p><h2 id="秒级数据检测"><a href="#秒级数据检测" class="headerlink" title="秒级数据检测"></a>秒级数据检测</h2><p>支持粒度自定义，以单个进程CPU使用率为例：</p><p><strong>进程CPU使用率（1s粒度）：</strong></p><p><img src="/assets/blogImg/WeChatImage20200614210601.png" alt></p><p><strong>进程CPU使用率（2s粒度）：</strong></p><p><img src="/assets/blogImg/WeChatScreenshot_20200614210634.png" alt></p><h1 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h1><p><img src="/assets/blogImg/60951037-8ba5d180-a2f8-11e9-906e-e27356f168bc.png" alt></p><h2 id="Netdata-backend"><a href="#Netdata-backend" class="headerlink" title="Netdata backend"></a>Netdata backend</h2><p>支持数据库持久化存储<br><img src="/assets/blogImg/29f182ba-b4ce-11e6-97c8-ab2c0ab59833.png" alt></p><ul><li>Netdata可以将其指标以相同或更低的分辨率归档到Graphite，OpenTSDB，Prometheus，AWS Kinesis，MongoDB，JSON文档DB（较低：防止由于收集到的数据量而阻塞这些服务器） 。</li><li>Netdata还支持Prometheus远程写入API，该API允许将指标存储到Elasticsearch，Gnocchi，InfluxDB，Kafka，PostgreSQL / TimescaleDB， Splunk，VictoriaMetrics以及许多其他存储提供商。</li></ul><h2 id="grafana-influxdb数据展示"><a href="#grafana-influxdb数据展示" class="headerlink" title="grafana + influxdb数据展示"></a>grafana + influxdb数据展示</h2><p><img src="/assets/blogImg/WeChatScreenshot_20200614221127.png" alt><br><strong>注：</strong>亲测阿里云服务器运行时数据</p><h1 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h1><p><img src="/assets/blogImg/WeChatScreenshot_20200615000721.png" alt></p><h1 id="SWOT分析"><a href="#SWOT分析" class="headerlink" title="SWOT分析"></a>SWOT分析</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="多平台支持"><a href="#多平台支持" class="headerlink" title="多平台支持"></a>多平台支持</h3><p>目前可在Linux，FreeBSD和macOS以及从它们衍生的其他系统（例如Kubernetes和Docker）上运行。</p><p><strong>扩：</strong>网上流传的<a href="https://apkpure.com/cn/netdata-app-server-monitoring-tool/com.kpots.netdata/versions" target="_blank" rel="noopener">netdata安卓客户端 </a>  （待测试）</p><h3 id="实时"><a href="#实时" class="headerlink" title="实时"></a>实时</h3><p>Netdata可在<strong>3毫秒</strong>内将图表查询结果反馈给到网页上。在3毫秒内，Netdata完成了计算图表结果，生成json文本，压缩并发送到web浏览器这些操作。查看access.log可看到这些操作各花费了多少时间。</p><h3 id="无需管理员身份运行"><a href="#无需管理员身份运行" class="headerlink" title="无需管理员身份运行"></a>无需管理员身份运行</h3><p>Netdata无需管理员身份。如果以管理员身份启动Netdata，它会切换到netdata使用者身份来运行。</p><h3 id="高精度无限指标"><a href="#高精度无限指标" class="headerlink" title="高精度无限指标"></a>高精度无限指标</h3><p>1s粒度 -所有指标的最高（？）可能分辨率。<br>无限指标 -Netdata收集所有可用指标</p><h3 id="低资源消耗"><a href="#低资源消耗" class="headerlink" title="低资源消耗"></a>低资源消耗</h3><p>单核的CPU利用率为1％ -令人难以置信的优化。<br>由系统管理员，DevOps工程师和开发人员设计的，不仅用于可视化指标，而且还可以解决复杂的性能问题。</p><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ul><li>实时可视化展示的目的是什么？是否有更近的路可走？</li><li>…</li></ul><h2 id="机会"><a href="#机会" class="headerlink" title="机会"></a>机会</h2><ul><li>机器学习</li><li>ebpf事件触发<br>…</li></ul><h2 id="威胁"><a href="#威胁" class="headerlink" title="威胁"></a>威胁</h2><ul><li>平台原生监控软件对比</li><li>…</li></ul><h1 id="可参与性分析："><a href="#可参与性分析：" class="headerlink" title="可参与性分析："></a>可参与性分析：</h1><h2 id="性能方向："><a href="#性能方向：" class="headerlink" title="性能方向："></a>性能方向：</h2><h2 id="安全方向："><a href="#安全方向：" class="headerlink" title="安全方向："></a>安全方向：</h2><h2 id="算法方向："><a href="#算法方向：" class="headerlink" title="算法方向："></a>算法方向：</h2><p><a href="https://www.netdata.cloud/blog/contribute-machine-learning/" target="_blank" rel="noopener">机器学习</a></p><p><img src="/assets/blogImg/contribute-machine-learning.png" alt></p><p><img src="/assets/blogImg/contribute-machine-learning-charts-980x494.jpg" alt></p><h2 id="运维方向："><a href="#运维方向：" class="headerlink" title="运维方向："></a>运维方向：</h2><ul><li>容器</li><li>内核指标？</li><li><a href="https://learn.netdata.cloud/docs/agent/collectors/ebpf.plugin/" target="_blank" rel="noopener">使用Netdata进行eBPF监视</a><br><a href="https://github.com/netdata/netdata/issues/8195" target="_blank" rel="noopener">初步测试</a>表明，尽管收集并显示了更复杂的指标，但eBPF收集器的性能几乎与apps.plugin收集器相同。现在，您可以使用eBPF收集更深的数据，而不会影响任何负载下复杂应用程序的性能。 </li></ul><p><strong>优势：</strong>有价值的未知指标</p><ul><li>…</li></ul><h2 id="Web方向："><a href="#Web方向：" class="headerlink" title="Web方向："></a>Web方向：</h2><ul><li>Bootstrap框架</li><li>…</li></ul><h2 id="存储方向："><a href="#存储方向：" class="headerlink" title="存储方向："></a>存储方向：</h2><ul><li>数据库</li><li>…</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul><li><a href="https://www.netdata.cloud/blog/linux-ebpf-monitoring-with-netdata/" target="_blank" rel="noopener">Linux eBPF monitoring with Netdata</a></li><li><a href="https://www.netdata.cloud/blog/docker-monitoring-netdata/" target="_blank" rel="noopener">Docker container monitoring with Netdata</a></li><li><a href="https://www.netdata.cloud/blog/contribute-machine-learning/" target="_blank" rel="noopener">Contribute to Netdata’s machine learning efforts!</a></li><li><a href="https://www.wware.org/wide/yw/backups/servernetdata.html" target="_blank" rel="noopener">Netdata性能分析_cn</a></li><li><a href="https://github.com/netdata/netdata/blob/master/collectors/COLLECTORS.md" target="_blank" rel="noopener">collectors list</a></li></ul><h1 id="改进建议"><a href="#改进建议" class="headerlink" title="改进建议"></a>改进建议</h1><ul><li>定制化/个性化/场景化？</li><li>半自动化-&gt;自动化？</li><li>提取数据种类？</li><li>机器学习？</li><li>轻量级？</li><li>性能?</li><li>安全？</li><li>…</li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">netdata开源地址</a></li><li><a href="https://learn.netdata.cloud/docs/agent" target="_blank" rel="noopener">netdata官方文档</a></li><li><a href="https://www.cnblogs.com/kevingrace/p/7300191.html" target="_blank" rel="noopener">Netdata—Linux系统性能实时监控平台部署记录</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/blogImg/80839230-b034a800-8baf-11ea-9cb2-99c1e10f0f85.gif&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;https://london.my-netdata.io/&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="Product" scheme="http://yoursite.com/tags/Product/"/>
    
  </entry>
  
  <entry>
    <title>什么是“平均负载”(三)？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D(%E4%B8%89)%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是“平均负载”(三)？/</id>
    <published>2019-10-08T12:53:00.000Z</published>
    <updated>2019-10-09T03:58:41.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码分析（2-6-gt-5-2）"><a href="#源码分析（2-6-gt-5-2）" class="headerlink" title="源码分析（2.6-&gt;5.2）"></a>源码分析（2.6-&gt;5.2）</h1><p><strong>注：</strong>源码位置变化，计算方式未变，以  版本为例</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>用户角度：平均活跃进程数</li><li>进程角度： 进程队列的长度</li><li>源码角度：nr_running（）+nr_uninterruptible（），一分钟、五分钟和十五分钟内系统的负载总量平均值按照指数比例压缩得到的结果</li><li>命令角度：uptime、tload等，cat /proc/loadavg | awk ‘{print $1,$2,$3}’</li><li>脚本角度：</li><li>程序角度：procps软件包中uptime.c源码中print_uptime（）函数</li><li>系统角度：系统负荷度量，R、D状态平均进程数</li></ul><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul><li>调优方法</li><li>高故障时打印进程堆栈-谢老师</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/weixin_34223655/article/details/92562329" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34223655/article/details/92562329</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;源码分析（2-6-gt-5-2）&quot;&gt;&lt;a href=&quot;#源码分析（2-6-gt-5-2）&quot; class=&quot;headerlink&quot; title=&quot;源码分析（2.6-&amp;gt;5.2）&quot;&gt;&lt;/a&gt;源码分析（2.6-&amp;gt;5.2）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/
      
    
    </summary>
    
    
      <category term="系统优化" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>恺撒密码代码简单实现加密解密</title>
    <link href="http://yoursite.com/%E6%81%BA%E6%92%92%E5%AF%86%E7%A0%81%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/恺撒密码代码简单实现加密解密/</id>
    <published>2019-05-09T00:26:08.000Z</published>
    <updated>2019-05-09T00:29:07.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密代码"><a href="#加密代码" class="headerlink" title="加密代码"></a>加密代码</h1><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX 100int main(){    char C[MAX];    char S[MAX];    int K=3,i;    printf(&quot;Enter passage\n&quot;);    gets(S);    for(i=0; S[i]!=&apos;\0&apos;; i++)    {        C[i]=(S[i]-&apos;a&apos;+K)%26+&apos;a&apos;;    }    C[i]=&apos;\0&apos;;    for(i=0; S[i]!=&apos;\0&apos;; i++)    {        C[i]=(S[i]-&apos;A&apos;+K)%26+&apos;A&apos;;    }    C[i]=&apos;\0&apos;;    printf(&quot;Password\n%s\n&quot;,C);    return 0;}</code></pre><h1 id="加密效果"><a href="#加密效果" class="headerlink" title="加密效果"></a>加密效果</h1><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190509082756.png" alt></p><h1 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h1><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX 100int main(){    char C[MAX];    char S[MAX];    int K=3,i;    printf(&quot;Password\n&quot;);    gets(C);    for(i=0; C[i]!=&apos;\0&apos;; i++)    {         S[i]=(C[i]-&apos;a&apos;-K)%26+&apos;a&apos;;    }    S[i]=&apos;\0&apos;;    for(i=0; C[i]!=&apos;\0&apos;; i++)    {         S[i]=(C[i]-&apos;A&apos;-K)%26+&apos;A&apos;;    }    S[i]=&apos;\0&apos;;    printf(&quot;Output passage\n%s\n&quot;,S);    return 0;}</code></pre><h1 id="解密效果"><a href="#解密效果" class="headerlink" title="解密效果"></a>解密效果</h1><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190509082850.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/dyw_666666/article/details/82466958" target="_blank" rel="noopener">恺撒密码代码简单实现加密解密</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密代码&quot;&gt;&lt;a href=&quot;#加密代码&quot; class=&quot;headerlink&quot; title=&quot;加密代码&quot;&gt;&lt;/a&gt;加密代码&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#de
      
    
    </summary>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>ARM核心和架构的关系</title>
    <link href="http://yoursite.com/ARM%E5%86%85%E6%A0%B8%E5%92%8C%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/ARM内核和架构的关系/</id>
    <published>2019-04-28T11:38:03.000Z</published>
    <updated>2019-04-28T13:40:48.716Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/u011784994/article/details/80497832" target="_blank" rel="noopener">https://blog.csdn.net/u011784994/article/details/80497832</a></p><p>好比你盖房子 刚开始因为水平低 流行盖平房 这就是一种架构（V5T）；然后这种平房架构你可以设计出一款独立卫生间的款式 这叫ARM7内核（很重要的核心）；然后其他人（芯片设计公司）想盖房子的就买你这个图纸去盖；然后过一段时间，有人觉得光独立卫生间还不够啊 我还想有个小院子，好吧，那ARM就满足你们，就出个带小院子的款式（ARM9）； 又过了很久，这种平房的架构就随着大伙的需求一直改啊改啊。</p><p>后来经过ARM研究发现 现在大伙盖房子的能力duang duang直升啊（包括工艺、设计能力、时钟主频） 只盖这种平房施展不开啊 好吧ARM为了不让这帮设计的人闲着 就推出一种二三层楼房的样式 这因为跟平房设计结构完全不一样嘛 那就叫一种新的架构（V6） 同样这种楼房样式ARM也为大家准备了带游泳池的和带车库的款式（ARM11各种）。</p><p>好吧继续改啊改啊，改到后来大家已经开始有能力盖十层以上的大楼了 ARM一如既往地出了新的款式（V7架构） 这时ARM觉得以前尼玛名字都太土鳖了，什么ARM5 ARM6 ARM7又难听又难记，劳资要取个看起来牛逼的名字，咱至少也算个能设计摩天大楼的主了 于是后面的内核都叫cortex。</p><p>改名只是一部分 随着这个架构出来后 ARM发现 以前用咱们图纸盖出的楼也就做个民宅，民宅图个啥，实惠嘛（功耗低） 现在不一样了，现在咱的图纸盖得楼不仅可以做民宅 还可以做军事基地，还可以做高档写字楼，以前这些高级功能的楼房可是只有小英（英特尔）才设计得来的啊，为了满足这些不同的需求 ARM把这个架构设计出来的款式分成3个系列（M系列、R系列、A系列）。</p><p>M系列是为民宅设计的 因为老百姓图实惠嘛 这种设计就设计个十层左右（功耗低） R系列是为军事基地设计的 这种楼设计的也不高 十层左右吧 但是关键是要对特殊情况要有快速反应的能力（中断快） 最后A系列是给商业大佬用的 那当然是要高端大气上档次 就是要高（性能高）各种LED灯灯光秀啊都给我上。</p><p>扩展：</p><p><a href="http://m.elecfans.com/article/678193.html" target="_blank" rel="noopener">一文看懂arm架构和x86架构有什么区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/u011784994/article/details/80497832&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u011784994/ar
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>订阅Linux内核邮件列表</title>
    <link href="http://yoursite.com/%E8%AE%A2%E9%98%85Linux%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/订阅Linux邮件列表/</id>
    <published>2019-04-01T07:51:08.000Z</published>
    <updated>2019-04-01T07:58:02.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载：</strong><a href="http://www.wowotech.net/linux_application/lkml.html" target="_blank" rel="noopener">新技能get: 订阅Linux内核邮件列表</a>  作者：wowo </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文给小伙伴们分享一下怎么订阅Linux内核邮件列表（Linux kernel mailing list，LKML）。</p><h1 id="LKML用来做什么的"><a href="#LKML用来做什么的" class="headerlink" title="LKML用来做什么的"></a>LKML用来做什么的</h1><p>先贴一段来自维基百科的定义：</p><pre><code>The Linux kernel mailing list (LKML) is the main electronic mailing list for Linux kernel development,[1][2] where the majority of the announcements, discussions, debates, and flame wars over the kernel take place.[3]</code></pre><p>大家知道，Linux kernel是由分布在世界各地的大牛们共同开发、维护的，这就需要一种交流工具，这种工具就是LKML。因而LKML主要有如下功能：</p><ul><li>patch的提交、审查</li><li>patch、版本等发布公告</li><li>技术讨论、辩论</li><li>打口水仗</li></ul><h1 id="订阅LKML的好处"><a href="#订阅LKML的好处" class="headerlink" title="订阅LKML的好处"></a>订阅LKML的好处</h1><p>订阅LKML的好处包括：</p><ul><li>接近大牛（经常可以看到Linus同学的发言哦），享受大牛亲笔给自己发送邮件的快感</li><li>了解kernel发展的最新动态</li><li>关注功能模块的演进过程</li><li>我们在学习、分析Linux kernel时，总觉得很复杂，觉得能写出这些代码的人有多么了不起。其实，罗马也是一块一块砖盖起来的，kernel的发展也是渐进的、一点一点积累的。这可以从每天上百封的邮件交流中体会到。因此技术的积累和进步，要有耐心，要有一定的环境，而不是喊三五年口号就出来的。希望和路过的蜗牛们共勉！</li><li>熟悉参与kernel开发的基本流程，以便日后能够提交patch</li><li>学习国外软件开发的方法和态度</li><li>这一点可以从每一封信（讨论、patch的review意见、提议等等）中看到<h1 id="有没有什么坏处？"><a href="#有没有什么坏处？" class="headerlink" title="有没有什么坏处？"></a>有没有什么坏处？</h1>绝对有！如果你不想你的邮箱被撑爆的话，一定要忍住，不要订阅！因为邮件太多了！</li></ul><p>如果你真的想清楚了，决定需要，那就继续吧。</p><h1 id="怎么订阅"><a href="#怎么订阅" class="headerlink" title="怎么订阅"></a>怎么订阅</h1><p>下面网址为LKML的主要列表：</p><p><a href="http://vger.kernel.org/vger-lists.html" target="_blank" rel="noopener">http://vger.kernel.org/vger-lists.html</a></p><p>它有很多分类，如alsa、PM、PWM、USB、GIT等等，大家可以选择感兴趣的订阅。点击指定分类的超链接（这里以linux-pm为例），会看到如下的表格：</p><pre><code>List: linux-pm; ( subscribe / unsubscribe )Info:This is the mailing list for Linux Power Management development. Archives: http://marc.info/?l=linux-pm http://dir.gmane.org/gmane.linux.power-management.general Footer:--- To unsubscribe from this list: send the line &quot;unsubscribe linux-pm&quot; in the body of a message to majordomo@vger.kernel.org More majordomo info at  http://vger.kernel.org/majordomo-info.html </code></pre><p>该表格有4个字段：</p><pre><code>List为邮件列表分类的名字，这里为“linux-pm”；Info描述了该邮件列表的内容，这里主要是Linux电源管理相关的；Archives为该分类所有邮件列表的归档，记录了该主题有关的所有的交流过程；注1：有了这个归档链接，其实可以不用订阅的，实时的去看一下就行了。另外，这些邮件列表的归档，对我们理解某个模块的设计理念是非常有帮助的，因为代码只是最终结论的展示，而为什么要这样设计，可以在邮件列表中的讨论中看到。Footer是一个提示，告诉大家怎么退订（如果你后悔的话，想相信会的，哈哈！）。</code></pre><p>订阅的方法很简单：</p><p>1）发送订阅邮件，格式如下</p><pre><code>收件人：majordomo@vger.kernel.org标题：可以为空。邮件正文：subscribe linux-pm xxx@xxx.com注2：subscribe为订阅关键字，linux-pm为分类名称，后面为需要订阅的邮箱地址。</code></pre><p>2）发送后，订阅邮箱会收到一封邮件，要求你回复一个鉴权字符串。回复即可，格式如下（红色为鉴权字符串，要替换为自己收到的，另外注意自己的邮箱地址要正确）：</p><pre><code>auth 25415058 subscribe linux-pm xxx@xxx.com</code></pre><p>3）回复后，会收到欢迎邮件，订阅成功</p><p><strong>注2：</strong>订阅邮箱尽量使用正常邮箱，比如工作邮箱。有些邮箱，如qq邮箱，可能会订阅失败。另外，一旦订阅成功，一定要及时查看、清理，否则会把邮箱撑爆。</p><p>原创文章，转发请注明出处。蜗窝科技，<a href="http://www.wowotech.net。" target="_blank" rel="noopener">www.wowotech.net。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;a href=&quot;http://www.wowotech.net/linux_application/lkml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新技能get: 订阅Linux内核邮件列表&lt;/a
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>EndNote X9推荐</title>
    <link href="http://yoursite.com/EndNote%20X9%E6%8E%A8%E8%8D%90/"/>
    <id>http://yoursite.com/EndNote X9推荐/</id>
    <published>2019-03-21T11:43:42.000Z</published>
    <updated>2019-03-21T11:43:54.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>EndNote X9是一款来自国外的主流文献管理软件，是一款优秀的文献管理软件，广泛使用于数以百万计的研究人员、学生和图书管理员等人员。软件具有在线搜索文献、建立文献库和图片库、定制文稿、引文编排等功能特点，拥有文献检索工具、文摘及全文的管理工具、引文编排工具等诸多实用工具，帮助用户更好的使用EndNote X9软件。</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><ul><li><a href="https://www.cnblogs.com/liuhuanhuan123456/p/9614539.html" target="_blank" rel="noopener">EndNote X9教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;EndNote X9是一款来自国外的主流文献管理软件，是一款优秀的文献管理软件，广泛使用于数以百万计的研究人员、学生和图书管理员等人员。软件
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>图片去水印教程</title>
    <link href="http://yoursite.com/%E5%9B%BE%E7%89%87%E5%8E%BB%E6%B0%B4%E5%8D%B0%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/图片去水印教程/</id>
    <published>2019-03-20T05:30:11.000Z</published>
    <updated>2019-03-20T06:07:24.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里我们使用 <a href="https://pan.baidu.com/s/1vR__gbh8y-aETPXow7mOoA" target="_blank" rel="noopener">Inpaint 5.6</a> <strong>提取码</strong>：<code>9vbp</code> 进行图片去水印操作</p><p><strong>序列号：</strong><code>ODMK-AALG-CODY-CFPA-YAYA-YAYA-YGUC-QCQC</code> 若失效可自行谷歌</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>以<img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320140644.png" alt> 为例</p><p><strong>步骤1：</strong></p><p>双击打开该软件，点击左上角的“文件”，打开图片或者直接把图片拖进去<br><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320133711.png" alt><br>此图片底部有水印</p><p><strong>步骤2：</strong></p><p>打开后的界面，可以看到图片底部有水印</p><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320133208.png" alt></p><p><strong>步骤3：</strong></p><p>通过滑动鼠标滑轮，能够将某一区域放大，如上图，点击后便可在图上涂抹<br><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320134924.png" alt></p><p><strong>步骤4：</strong></p><p>点击处理图像即可完成去除水印的目的<br><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320135531.png" alt></p><p><strong>步骤5：</strong></p><p>保存导出<br><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190320134954.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这里我们使用 &lt;a href=&quot;https://pan.baidu.com/s/1vR__gbh8y-aETPXow7mOoA&quot; targe
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《分布式文件系统I/O拥塞控制研究》论文阅读</title>
    <link href="http://yoursite.com/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FIO%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%A0%94%E7%A9%B6%E3%80%8B%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/《分布式文件系统IO拥塞控制研究》论文阅读/</id>
    <published>2019-03-15T06:07:36.000Z</published>
    <updated>2019-03-15T06:08:45.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h1><p>设计了一种端到端自动I/O拥塞控制机制，针对不同类型的负载，从分布式文件系统的客户端和服务器端对系统I/O请求的发送和处理进行控制。根据调控目标和系统当前运行状况自动调整相关控制参数，从而有效应对I/O拥塞问题，提高系统吞吐。</p><h1 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h1><p>在分布式文件系统中，为了实现高性能和高并行，一个I/O操作通常被分割为若干个请求序列［１,２］，这些请求被并行地发送到服务器端，导致存储系统中涌现大量资源竞争，如存储带宽、磁盘访问时间片等。在分布式文件系统中，设计一种I/O拥塞控制机制来协调和控制集群的I/O请 求，保证系统高效运行就显得尤为重要。通过参数来控制分布式文件系统客户端请求发送窗口，并基于机器学习进行参数调优，从客户端和服务器端同时入手，实现端到端的 拥塞控制。 </p><p>针对分布式文件系统服务器端拥塞控制方案主要分为三部分：第一，客户端发送窗口值分配算法，即如何根据服务器端负载的和资源情况，动态地以客户端粒度计算发送窗口值，保证客户端间的公平性；第二，根据第一步计算的总体发送窗口值和应用效率评估模型，评估各应用的效率；第三，基于相应的策略模型，保证应用粒度的公平性</p><h1 id="论文启发"><a href="#论文启发" class="headerlink" title="论文启发"></a>论文启发</h1><p>文件系统+机器学习，将两种技术融合，对文件系统进行优化，提高其性能</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对分布式文件系统集群中的部分负载导致的I/O拥塞问题行之有效，对于写I/O操作为主的负载提高系统吞吐，降低吞吐的性能偏差，有效降低I/O任务完成时延达，同时不会持续对轻载状态的分布式文件系统集群产生负面影响，性能开销也在可控范围内。</p><h1 id="论文链接"><a href="#论文链接" class="headerlink" title="论文链接"></a>论文链接</h1><ul><li><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDLAST2019&filename=LVKJ201824067&v=MjYxMjIxTHV4WVM3RGgxVDNxVHJXTTFGckNVUkxPZlpPZHFGeTNrVkw3SUtUdkFaTEc0SDluT3E0OURZNFI4ZVg=" target="_blank" rel="noopener">分布式文件系统I/O拥塞控制研究</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文章简介&quot;&gt;&lt;a href=&quot;#文章简介&quot; class=&quot;headerlink&quot; title=&quot;文章简介&quot;&gt;&lt;/a&gt;文章简介&lt;/h1&gt;&lt;p&gt;设计了一种端到端自动I/O拥塞控制机制，针对不同类型的负载，从分布式文件系统的客户端和服务器端对系统I/O请求的发送和处理进
      
    
    </summary>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>华为多次承认有研发手机系统，为什么不推广？</title>
    <link href="http://yoursite.com/%E5%8D%8E%E4%B8%BA%E5%A4%9A%E6%AC%A1%E6%89%BF%E8%AE%A4%E6%9C%89%E7%A0%94%E5%8F%91%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E5%B9%BF%EF%BC%9F/"/>
    <id>http://yoursite.com/华为多次承认有研发手机系统，为什么不推广？/</id>
    <published>2019-03-15T04:50:56.000Z</published>
    <updated>2019-04-01T07:53:08.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载：</strong><a href="http://www.wowotech.net/linux_application/lkml.html" target="_blank" rel="noopener">新技能get: 订阅Linux内核邮件列表</a> 作者：wowo </p><ol><li><p>前言<br>本文给小伙伴们分享一下怎么订阅Linux内核邮件列表（Linux kernel mailing list，LKML）。</p></li><li><p>LKML用来做什么的<br>先贴一段来自维基百科的定义：</p></li></ol><p>The Linux kernel mailing list (LKML) is the main electronic mailing list for Linux kernel development,[1][2] where the majority of the announcements, discussions, debates, and flame wars over the kernel take place.[3]</p><p>大家知道，Linux kernel是由分布在世界各地的大牛们共同开发、维护的，这就需要一种交流工具，这种工具就是LKML。因而LKML主要有如下功能：</p><p>patch的提交、审查<br>patch、版本等发布公告<br>技术讨论、辩论<br>打口水仗</p><ol start="3"><li>订阅LKML的好处<br>订阅LKML的好处包括：</li></ol><p>接近大牛（经常可以看到Linus同学的发言哦），享受大牛亲笔给自己发送邮件的快感<br>了解kernel发展的最新动态<br>关注功能模块的演进过程<br>我们在学习、分析Linux kernel时，总觉得很复杂，觉得能写出这些代码的人有多么了不起。其实，罗马也是一块一块砖盖起来的，kernel的发展也是渐进的、一点一点积累的。这可以从每天上百封的邮件交流中体会到。因此技术的积累和进步，要有耐心，要有一定的环境，而不是喊三五年口号就出来的。希望和路过的蜗牛们共勉！<br>熟悉参与kernel开发的基本流程，以便日后能够提交patch<br>学习国外软件开发的方法和态度<br>这一点可以从每一封信（讨论、patch的review意见、提议等等）中看到</p><ol start="4"><li>有没有什么坏处？<br>绝对有！如果你不想你的邮箱被撑爆的话，一定要忍住，不要订阅！因为邮件太多了！</li></ol><p>如果你真的想清楚了，决定需要，那就继续吧。</p><ol start="5"><li>怎么订阅<br>下面网址为LKML的主要列表：</li></ol><p><a href="http://vger.kernel.org/vger-lists.html" target="_blank" rel="noopener">http://vger.kernel.org/vger-lists.html</a></p><p>它有很多分类，如alsa、PM、PWM、USB、GIT等等，大家可以选择感兴趣的订阅。点击指定分类的超链接（这里以linux-pm为例），会看到如下的表格：</p><p>List: linux-pm;     ( subscribe / unsubscribe )</p><p>Info:</p><p>This is the mailing list for Linux Power Management development. </p><p>Archives:<br><a href="http://marc.info/?l=linux-pm" target="_blank" rel="noopener">http://marc.info/?l=linux-pm</a><br><a href="http://dir.gmane.org/gmane.linux.power-management.general" target="_blank" rel="noopener">http://dir.gmane.org/gmane.linux.power-management.general</a> </p><p>Footer:</p><hr><p>To unsubscribe from this list: send the line “unsubscribe linux-pm” in<br>the body of a message to <a href="mailto:majordomo@vger.kernel.org" target="_blank" rel="noopener">majordomo@vger.kernel.org</a><br>More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html" target="_blank" rel="noopener">http://vger.kernel.org/majordomo-info.html</a> </p><p>该表格有4个字段：</p><p>List为邮件列表分类的名字，这里为“linux-pm”；</p><p>Info描述了该邮件列表的内容，这里主要是Linux电源管理相关的；</p><p>Archives为该分类所有邮件列表的归档，记录了该主题有关的所有的交流过程；</p><p>注1：有了这个归档链接，其实可以不用订阅的，实时的去看一下就行了。另外，这些邮件列表的归档，对我们理解某个模块的设计理念是非常有帮助的，因为代码只是最终结论的展示，而为什么要这样设计，可以在邮件列表中的讨论中看到。</p><p>Footer是一个提示，告诉大家怎么退订（如果你后悔的话，想相信会的，哈哈！）。</p><p>订阅的方法很简单：</p><p>1）发送订阅邮件，格式如下</p><p>收件人：<a href="mailto:majordomo@vger.kernel.org" target="_blank" rel="noopener">majordomo@vger.kernel.org</a></p><p>标题：可以为空。</p><p>邮件正文：subscribe linux-pm <a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a></p><p>注2：subscribe为订阅关键字，linux-pm为分类名称，后面为需要订阅的邮箱地址。</p><p>2）发送后，订阅邮箱会收到一封邮件，要求你回复一个鉴权字符串。回复即可，格式如下（红色为鉴权字符串，要替换为自己收到的，另外注意自己的邮箱地址要正确）：</p><p>auth 25415058 subscribe linux-pm <a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a></p><p>3）回复后，会收到欢迎邮件，订阅成功</p><p>注2：订阅邮箱尽量使用正常邮箱，比如工作邮箱。有些邮箱，如qq邮箱，可能会订阅失败。另外，一旦订阅成功，一定要及时查看、清理，否则会把邮箱撑爆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;a href=&quot;http://www.wowotech.net/linux_application/lkml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新技能get: 订阅Linux内核邮件列表&lt;/a
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>羽毛球攻略</title>
    <link href="http://yoursite.com/%E7%BE%BD%E6%AF%9B%E7%90%83%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/羽毛球攻略/</id>
    <published>2019-03-14T03:12:01.000Z</published>
    <updated>2019-03-14T03:29:41.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><p>各种招式学会，超能量消耗最低方向灵活运用</p><h1 id="招式"><a href="#招式" class="headerlink" title="招式"></a>招式</h1><ul><li><a href="http://www.ctsports.com.cn/article-95415.html" target="_blank" rel="noopener">http://www.ctsports.com.cn/article-95415.html</a></li><li><a href="http://www.sohu.com/a/253794399_99921299" target="_blank" rel="noopener">http://www.sohu.com/a/253794399_99921299</a></li></ul><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>充分利用空间位置（上下左右前后）和场地、器械等环境 和 对手状况与其打优势差，记住，你的对手是人！</p><h1 id="羽毛球的步法和手法傻子口诀"><a href="#羽毛球的步法和手法傻子口诀" class="headerlink" title="羽毛球的步法和手法傻子口诀"></a>羽毛球的步法和手法傻子口诀</h1><p><strong>参考：</strong><a href="https://wenku.baidu.com/view/1a7f7e7e0722192e4536f6c7.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/1a7f7e7e0722192e4536f6c7.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路线&quot;&gt;&lt;a href=&quot;#路线&quot; class=&quot;headerlink&quot; title=&quot;路线&quot;&gt;&lt;/a&gt;路线&lt;/h1&gt;&lt;p&gt;各种招式学会，超能量消耗最低方向灵活运用&lt;/p&gt;
&lt;h1 id=&quot;招式&quot;&gt;&lt;a href=&quot;#招式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="运动" scheme="http://yoursite.com/tags/%E8%BF%90%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>文件系统理论学习</title>
    <link href="http://yoursite.com/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/文件系统理论学习/</id>
    <published>2019-03-07T10:56:49.000Z</published>
    <updated>2019-03-07T14:06:44.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><p>计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p><p>文件系统通常使用硬盘和光盘这样的存储设备，并维护文件在设备中的物理位置。但是，实际上文件系统也可能仅仅是一种访问数据的界面而已，实际的数据是通过网络协议（如NFS、SMB、9P等）提供的或者内存上，甚至可能根本没有对应的文件（如proc文件系统）。</p><p>严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）</p><h2 id="LKPA"><a href="#LKPA" class="headerlink" title="LKPA"></a>LKPA</h2><p>从系统角度看，文件系统是对文件存储器空间进行组织和分配，负责文件的存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等</p><p>文件系统指文件存在的物理空间，Linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。Linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件系统是一种用于向用户提供底层数据访问的机制！</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>庞大的数据结构</li><li>一切皆文件</li><li>文件系统的目录组织是一个树形结构</li><li>文件本身是无结构的字符流</li><li>文件系统把外部设备做成特殊文件,与普通文件一并进行管理</li></ul><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>每个分区是一棵树/根目录</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190307192332.jpg" alt></p><ul><li>/bin 二进制可执行命令</li><li>/dev 设备特殊文件</li><li>/etc 系统管理和配置文件</li><li>/home 用户主目录的基点，比如用户user的主目录就是/home/user。</li><li>/lib 标准程序设计库，又叫动态链接共享库。</li><li>/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序</li><li>/tmp 公用的临时文件存储点</li><li>/root 系统管理员的主目录</li><li>/mnt 用户临时安装其他文件系统的目录。</li><li>/proc 虚拟的目录，不占用磁盘空间，是系统内存的映射。可直接访问这个目录来获取系统信息。</li><li>/var 某些大文件的溢出区，例如各种服务的日志文件</li><li>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录下。</li></ul><p><strong>总结：</strong>整个文件系统只有一棵树，根目录是公共地方，家目录你随便折腾（体现了多用户的特点）</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>每个分区都是一个文件系统  </p><h2 id="索引节点号"><a href="#索引节点号" class="headerlink" title="索引节点号"></a>索引节点号</h2><p>标识一个文件<br>eg:</p><pre><code>ls -li  cat /proc/filesystems</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>mount：</strong>一般挂载到/mnt目录下</p><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190307191152.png" alt></p><h2 id="常规文件"><a href="#常规文件" class="headerlink" title="常规文件"></a>常规文件</h2><p>存放数据、程序等信息的文件，一般分为文本文件和二进制文件</p><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>将文件的名称和它的索引节点号结合在一起的一张表</p><h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><p>每种I/O设备对应一个设备文件，存放在/dev目录中</p><h2 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h2><p>主要用于在进程间传递数据的媒介，Linux对管道的操作与文件操作相同，将管道作为文件进行处理，又称为先进先出文件  </p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>又称为符号链接文件，提供了共享文件的一种方法。使用链接文件可以访问常规文件，目录文件和其它文件</p><p><strong>注意：</strong>通过<code>ls /dev -l</code>命令可以看到fifo为管道文件，d为目录文件，c为字符文件，l为链接文件</p><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>虚拟文件系统（简称VFS）为用户程序提供了具体文件系统的接口，它对每个具体文件系统的细节进行抽象，使所有文件系统依赖于VFS且可以通过VFS协同工作。要注意VFS与具体文件系统的区别，VFS只存在于内存中，在系统启动时创建，在系统关闭时消亡。</p><h2 id="虚拟含义"><a href="#虚拟含义" class="headerlink" title="虚拟含义"></a>虚拟含义</h2><ol><li>在同一个目录结构中, 可以挂载着若干种不同的文件系统. VFS隐藏了它们的实现细节, 为使用者提供统一的接口;</li><li>目录结构本身并不是绝对的, 每个进程可能会看到不一样的目录结构. 目录结构是由”地址空间(namespace)”来描述的, 不同的进程可能拥有不同的namespace, 不同的namespace可能有着不同的目录结构(因为它们可能挂载了不同的文件系统).</li></ol><h2 id="VFS中四个主要对象"><a href="#VFS中四个主要对象" class="headerlink" title="VFS中四个主要对象"></a>VFS中四个主要对象</h2><p>超级块对象：描述已安装文件系统。</p><p>索引节点对象：描述一个文件。</p><p>目录项对象：描述一个目录项，是路径的组成部分。</p><p>文件对象：描述由进程打开的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;h2 id=&quot;wiki&quot;&gt;&lt;a href=&quot;#wiki&quot; class=&quot;headerlink&quot; title=&quot;wiki&quot;&gt;&lt;/a&gt;wiki&lt;/h
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>空循环引起的问题</title>
    <link href="http://yoursite.com/%E7%A9%BA%E5%BE%AA%E7%8E%AF%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/空循环引起的问题/</id>
    <published>2019-03-07T03:48:53.000Z</published>
    <updated>2019-03-07T03:48:54.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输出为-1"><a href="#输出为-1" class="headerlink" title="输出为-1"></a>输出为-1</h1><p>下列程序的输出结果是（ ）</p><pre><code>int main(void){        int Y=1;        while(Y--);        printf(&quot;Y=%d&quot;,Y);}</code></pre><p>A.Y=0    B.Y=1    C.Y=-1    D.Y=随机数</p><h1 id="输出为0"><a href="#输出为0" class="headerlink" title="输出为0"></a>输出为0</h1><p>那么</p><pre><code>int main(void){        int Y=1;        while(Y--)        printf(&quot;Y=%d&quot;,Y);}</code></pre><p>呢？</p><p><strong>解析：</strong></p><ul><li>第一个程序由于是空循环，当Y为0时还要判断一下，故结果为-1</li><li>第二个程序直接输出，结果为0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输出为-1&quot;&gt;&lt;a href=&quot;#输出为-1&quot; class=&quot;headerlink&quot; title=&quot;输出为-1&quot;&gt;&lt;/a&gt;输出为-1&lt;/h1&gt;&lt;p&gt;下列程序的输出结果是（ ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(void)
{
        int 
      
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>中断发展史</title>
    <link href="http://yoursite.com/%E4%B8%AD%E6%96%AD%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>http://yoursite.com/中断发展史/</id>
    <published>2019-03-06T03:40:16.000Z</published>
    <updated>2019-03-06T03:44:01.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>首先，中断上下部分是为了避免中断嵌套时关中断太长有些中断得不到响应引出的一种机制，中断既能让程序运行的快，又能让程序完成的多个工作，即有效利用时间和空间，中断上半部分是特点是快速可以及时快速响应所有中断（避免了有些中断得不到响应这种情况的发生），中断下半部分执行的比较慢，它才是中断主要执行的有用部分，相对于上半部分而言，下半部分执行时可以被中断，也就是允许并发，考虑到中断下半部分的执行，引出了小任务机制，不可睡眠，工作队列，可睡眠， </p><p>引出软中断实现中断下半部分，随着中断数的不停增加，软中断不够用了，于是下半部又做了进化，为了提高中断处理数量，顺道改进处理效率，于是产生了tasklet机制（小任务机制）</p><p>由于之前机制中的中断不可挂起，串行执行，也就是说只要有一个处理时间较长，则会导致其他中断响应的延迟，为了完成这些不可能完成的任务，引出了工作队列，工作队列的本质是一组内核线程，作为中断守护线程来使用。</p><p>操作系统显然不能任由每个中断各自为政，为了对所有中断进行统一管理，引入软中断<br>我们不可中断部分的共同部分放在函数do_IRQ中，需要添加中断处理函数时，通过request_irq实现。下半部放在do_softirq中，也就是软中断，通过open_softirq添加对应的处理函数。</p><p>旧事物跟不上历史的发展时，总会有新事物出现。随着中断数的不停增加，软中断不够用了，于是下半部又做了进化。软中断用轮询的方式处理。假如正好是最后一种中断，则必须循环完所有的中断类型，才能最终执行对应的处理函数。显然当年开发人员为了保证轮询的效率，于是限制中断个数为32个。</p><p>为了提高中断处理数量，顺道改进处理效率，于是产生了tasklet机制。</p><p><strong>工作队列：</strong>由于之前机制中的中断不可挂起，串行执行，也就是说只要有一个处理时间较长，则会导致其他中断响应的延迟，为了完成这些不可能完成的任务，引出了工作队列，工作队列的本质是一组内核线程，作为中断守护线程来使用。</p><p><img src="/assets/blogImg/%E5%9B%BEfdefef1.png" alt></p><h1 id="中断的栈和进程的栈是一个么？"><a href="#中断的栈和进程的栈是一个么？" class="headerlink" title="中断的栈和进程的栈是一个么？"></a>中断的栈和进程的栈是一个么？</h1><p>不是，因为每个进程都有属于自己的栈（每个进程都有自己的虚拟空间，虚拟空间中有栈，在执行时通过页机制转换），假设中断栈和进程栈是同一个栈，那么每个进程的栈地址都不一样，这样恢复中断时将变得非常麻烦。中断栈应该公有，因为中断最后是要中断CPU的，而内核是管理硬件的，所以猜测中断栈应该在内核态，内核空间也有自己的栈，那么内核栈是否和中断栈是同一个栈？<br>查阅资料得知在2.4版本中，中断栈和内核栈共享，优点是代码简单，缺点是共享有时可能会导致内核栈空间不够用（内核栈和中断栈数据共享），为了改善这个缺点，要么扩大内核栈大小，要么在内核空间重新开辟一个栈，称为中断栈，考虑到中断栈如果发生嵌套，可能会破坏内核栈数据（可能会造成栈溢出），所以现在Linux内核采用内核栈和中断栈分离的设计</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Quartu_flag/article/details/78339318" target="_blank" rel="noopener">Linux中的中断处理机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发展过程&quot;&gt;&lt;a href=&quot;#发展过程&quot; class=&quot;headerlink&quot; title=&quot;发展过程&quot;&gt;&lt;/a&gt;发展过程&lt;/h1&gt;&lt;p&gt;首先，中断上下部分是为了避免中断嵌套时关中断太长有些中断得不到响应引出的一种机制，中断既能让程序运行的快，又能让程序完成的多
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Level DB和Couch DB的区别？</title>
    <link href="http://yoursite.com/Level%20DB%E5%92%8CCouch%20DB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/Level DB和Couch DB的区别？/</id>
    <published>2019-03-06T02:47:10.000Z</published>
    <updated>2019-03-06T02:59:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p>Level DB：(是fabric默认的db），Level DB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</p><p>Counch DB：支持副查询（更加丰富），Couch DB 是一种可选的替代 level DB 的状态数据库。</p><p>与 Level DB 键值存储一样，Couch DB 不仅可以根据 key 进行相应的查询，还可以根据不同的应用场景需求实现复杂查询。</p><h1 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h1><p><img src="/assets/blogImg/%E5%9B%BE%E7%89%871.png" alt> </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://db-engines.com/en/system/CouchDB%3BLevelDB" target="_blank" rel="noopener">CouchDB vs. LevelDB Comparison - DB-Engines</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关定义&quot;&gt;&lt;a href=&quot;#相关定义&quot; class=&quot;headerlink&quot; title=&quot;相关定义&quot;&gt;&lt;/a&gt;相关定义&lt;/h1&gt;&lt;p&gt;Level DB：(是fabric默认的db），Level DB 是嵌入在 Peer 中的默认键值对（key-value）状
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>文件描述符</title>
    <link href="http://yoursite.com/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/文件描述符/</id>
    <published>2019-03-05T13:41:51.000Z</published>
    <updated>2019-03-06T02:44:22.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h1><p>1.对于内核而言，所有打开文件都由文件描述符引用<br>2.文件描述符是一个非负整数<br>3.当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符<br>4.当读、写一个文件时，用open或create返回的文件描述符标书该文件，将其作为参数传送给read或write</p><h1 id="代码体现"><a href="#代码体现" class="headerlink" title="代码体现"></a>代码体现</h1><p><strong>fs_test.c：</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc,char *argv[]){        int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);        printf(&quot;fd : %d\n&quot;,fd);        return 0;}</code></pre><p>执行上面代码，返回值是3</p><p><strong>注：</strong>fcntl.h，是unix标准中通用的头文件，其中包含的相关函数有 open，fcntl，shutdown，unlink，fclose等！</p><h1 id="为什么是3？"><a href="#为什么是3？" class="headerlink" title="为什么是3？"></a>为什么是3？</h1><p>当一个进程启动时，它会自动打开三个文件，这三个文件分别是：标准输入、标准输出、标准出错，它们对应的文件描述符分别是0、1、2，所以当打开/etc/passwd这个文件时，它就接着以3开始计数了。</p><p>POSIX.1应用程序中，整数0、1、2营被代换成符号常数STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，这些常数都定义在头文件&lt;unistd.h&gt;（可在/usr/include目录下找到，或使用<code>cat unistd.h | grep STDIN_FILENO</code>查看）中。</p><p>文件描述符范围0-OPEN_MAX。早期UNIX版本采用的上限值是19（允许每个进程打开20个文件），现在很多系统将其增加至63，Linux为1024。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关说明&quot;&gt;&lt;a href=&quot;#相关说明&quot; class=&quot;headerlink&quot; title=&quot;相关说明&quot;&gt;&lt;/a&gt;相关说明&lt;/h1&gt;&lt;p&gt;1.对于内核而言，所有打开文件都由文件描述符引用&lt;br&gt;2.文件描述符是一个非负整数&lt;br&gt;3.当打开一个现存文件或创建一个
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>C语言中fprintf和printf的区别？</title>
    <link href="http://yoursite.com/C%E8%AF%AD%E8%A8%80%E4%B8%ADfprintf%E5%92%8Cprintf%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/C语言中fprintf和printf的区别？/</id>
    <published>2019-03-05T13:36:40.000Z</published>
    <updated>2019-03-05T13:39:26.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>fprintf的函数原型为：</p><pre><code>int fprintf( FILE *stream, const char *format, [ argument ]...)；</code></pre><p>而printf的函数原型为：</p><pre><code>int printf( const char *format [, argument]... );</code></pre><p>因此fprintf是将字符输出到流（文件）的，而printf是输出到标准输出设备（stdout）的，一般就是屏幕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h1&gt;&lt;p&gt;fprintf的函数原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int fprintf( FILE *stream, const char *f
      
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>假期论文阅读汇总</title>
    <link href="http://yoursite.com/%E5%81%87%E6%9C%9F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/假期论文阅读汇总/</id>
    <published>2019-03-01T06:09:17.000Z</published>
    <updated>2019-03-01T06:34:24.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《分布式文件系统性能测试和优化研究》"><a href="#《分布式文件系统性能测试和优化研究》" class="headerlink" title="《分布式文件系统性能测试和优化研究》"></a>《分布式文件系统性能测试和优化研究》</h1><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>文章对分布式文件系统的关键技术和GlusterFS的系统架构进行了研究，然后对GlusterFS的文件系统进行了测试，根据测试结果，设计了一套在LevelDB上存储GlusterFS元数据及其扩展属性的方案，使系统的元数据性能得到了提高。</p><h2 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h2><p>互联网的高速发展使得对大数据的存储需求越来越高，应对高并发的数据访问是互联网技术很大的挑战。分布式系统通过计算机网络把不一定连接在本地的物理存储资源连接成集群，其文件系统管理元数据的方式有三种：一是集中式元数据服务模型，二是分布式元数据服务模型，三是无元数据服务模型。GlusterFS采用了无元数据服务模型。这使得GlusterFS避开了前两种模型不能彻底解决的问题，消除了元数据性能瓶颈、单点故障、数据一致性等一系列相关问题，并且使得系统的扩展性显著提高，获得了接近线性的高扩展性。但是，这也导致了GlusterFS部分元数据操作的缓慢。文章修改了LevelDB存储部分元数据的存储方式，让一部分元数据操作通过LevelDB进行，加快元数据操作的速度，从而能提升了性能。</p><h2 id="论文启发"><a href="#论文启发" class="headerlink" title="论文启发"></a>论文启发</h2><ol><li>其他分布式文件系统是否也可以使用数据库保存元数据来加快元数据操作速度？</li><li>数据库的选取对元数据操作速度有影响吗？如果有可否选取合适的数据库进行调优？</li><li>在集中式元数据服务模型和分布式元数据服务模型中应该怎样优化呢？</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章对GlusterFS分布式文件系统进行了详细的分析。试图通过使用<strong>LevelDB保存GlusterFS元数据</strong>来加快GlusterFS元数据操作的速度。</p><h1 id="《分布式文件系统海量小文件性能优化技术研究》"><a href="#《分布式文件系统海量小文件性能优化技术研究》" class="headerlink" title="《分布式文件系统海量小文件性能优化技术研究》"></a>《分布式文件系统海量小文件性能优化技术研究》</h1><h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>文章的主要研究对象是实验室自主独立开发的分布式文件系统Cappella，将小文件访问主要耗时定位到元数据或数据访问时的<strong>磁盘I/O</strong>，对该点进行相关优化可以提高系统对小文件的访问性能。通过本文的研究，证实通过改善小文件的访问性能可以有效提高分布式文件系统的总体性能，同时本文的研究方式也可以给今后小文件性能问题研究提供借鉴，文章的研究内容有非常大的研究意义。</p><h2 id="论文内容-1"><a href="#论文内容-1" class="headerlink" title="论文内容"></a>论文内容</h2><p>主要对分布式文件系统Cappella的小文件访问过程进行研究分析，主要对访问过程中客户端与服务器之间的交互过程以及小文件访问耗时进行分析，结合小文件的访问特点确定小文件访问过程中的主要瓶颈。根据对小文件访问瓶颈分析，对小文件应用场景下的Cappella文件系统进行优化，主要包括对小文件的访问流程进行精简，然后使用文件聚合存储技术将小文件的元数据信息和数据信息一起存储在元数据服务器，然后优化了小文件访问过程中的I/O路径，对小文件的写操作使用批量刷回技术进行优化，小文件读操作使用缓存预取技术进行优化。最后对比测试了优化前后Cappella文件系统以及Lustre文件系统的元数据IOPS、小文件读写性能、小文件并发访问性能、大文件读写性能进行测试。</p><p>文章详细测试了Cappella文件系统对海量小文件优化前后的性能，主要包括元数据服务器吞吐量、系统小文件读写性能、系统小文件并发测试以及系统大文件读写性能测试。根据测试结果分析可得，优化后Cappella文件系统元数据吞吐量大幅增加；对小文件的读写性能提升明显；多线程并发写，小文件性能同样有明显提升；系统大文件读写性能有小幅提升。</p><h2 id="论文启发-1"><a href="#论文启发-1" class="headerlink" title="论文启发"></a>论文启发</h2><ol><li>文章中主要对应的存储介质是HDD，考虑到新型介质发展迅速，可以进一步测试不同存储介质情况下本优化方案的提升空间；</li><li>文章中提到的优化方案只是在Cappella这一具体的文件系统上实现，理论上是可以适用于其他分布式文件系统，但是还是需要进行实际的验证，因此本优化方案是否具有普适性就需要更进一步的验证。</li><li>文章仅仅验证了小文件数量在千万级时优化方案对性能还有提升效果，但是当小文件数量更大时本文中的优化方案是否依然有效就需要更深入的测试分析。</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对小文件的访问流程进行精简，然后使用文件聚合存储技术将小文件的元数据信息和数据信息一起存储在元数据服务器，然后优化了小文件访问过程中的I/O路径，对小文件的写操作使用批量刷回技术进行优化，小文件读操作使用缓存预取技术进行优化，从而达到对Cappella文件系统中小文件进行优化的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《分布式文件系统性能测试和优化研究》&quot;&gt;&lt;a href=&quot;#《分布式文件系统性能测试和优化研究》&quot; class=&quot;headerlink&quot; title=&quot;《分布式文件系统性能测试和优化研究》&quot;&gt;&lt;/a&gt;《分布式文件系统性能测试和优化研究》&lt;/h1&gt;&lt;h2 id=&quot;文
      
    
    </summary>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 全栈课程-答疑模块</title>
    <link href="http://yoursite.com/JavaScript%20%E5%85%A8%E6%A0%88%E8%AF%BE%E7%A8%8B-%E7%AD%94%E7%96%91%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/JavaScript 全栈课程-答疑模块/</id>
    <published>2019-02-22T07:37:29.000Z</published>
    <updated>2019-02-22T07:38:25.056Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>集合运算合集：<br>Q1:./practices/collectionOperator/get_letter_interval_2_spec.js  文件应该怎么写？需要预置一个字符数组吗？<br>A1.1:两种方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getBasicLetter() &#123;</span><br><span class="line">  let basicLetter = [];</span><br><span class="line">  for (let i = 97; i &lt; 97 + 26; ++i)</span><br><span class="line">    basicLetter.push(String.fromCharCode(i));</span><br><span class="line">  return basicLetter;</span><br><span class="line">&#125;//用unicode编码获取</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let ElseLetter =[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;....] //自己写一个字符串数组</span><br></pre></td></tr></table></figure><p>A1.2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function get_letter_interval_2(number_a, number_b) &#123;</span><br><span class="line">  let rounds = getRounds(number_a &gt; number_b ? number_a : number_b);</span><br><span class="line"></span><br><span class="line">  if (number_a &gt; number_b) return getRoundsLetters(rounds).splice(number_b - 1, number_a - number_b + 1).reverse();</span><br><span class="line">  if (number_a &lt; number_b) return getRoundsLetters(rounds).splice(number_a - 1, number_b - number_a + 1);</span><br><span class="line"></span><br><span class="line">  return [getRoundsLetters(rounds)[number_a - 1]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getBasicLetter() &#123;</span><br><span class="line">  let basicLetter = [];</span><br><span class="line">  for (let i = 97; i &lt; 97 + 26; ++i)</span><br><span class="line">    basicLetter.push(String.fromCharCode(i));</span><br><span class="line"></span><br><span class="line">  return basicLetter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRoundsLetters(rounds) &#123;</span><br><span class="line">  let roundsLetters = getBasicLetter();</span><br><span class="line">  let basicLetters = getBasicLetter();</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; rounds - 1; ++i)</span><br><span class="line">    basicLetters.map(letter =&gt; roundsLetters.push(basicLetters[i] + letter));</span><br><span class="line"></span><br><span class="line">  return roundsLetters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRounds(number) &#123;</span><br><span class="line">  let rounds = number / 26;</span><br><span class="line">  if (number % 26 !== 0) rounds += 1;</span><br><span class="line"></span><br><span class="line">  return rounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = get_letter_interval_2;</span><br></pre></td></tr></table></figure><p>pos机：<br>Q1:<img src="https://images-cdn.shimo.im/dgcJ7Pu3v4cIRorf/image.png!thumbnail" alt="图片"><br>怎么回事？<br>A1:</p><p><strong>仓库地址：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tdd测试：      https://github.com/Mucheng910/npm-test.git</span><br><span class="line">运算合集：     https://github.com/Mucheng910/80--es6-.git</span><br><span class="line">黄焖鸡：       https://github.com/Mucheng910/take-out-food.git</span><br><span class="line">dom：         https://github.com/Mucheng910/dom.git</span><br></pre></td></tr></table></figure><p><strong>tdd测试的pos机测试文件有问题</strong><br><img src="https://images-cdn.shimo.im/7rJWB8d9QVMsbdpI/image.png!thumbnail" alt="图片"><br><em>照这个改一下就好了</em></p><p><strong>课程直播的录频：</strong><br>黄焖鸡：  链接: <a href="https://pan.baidu.com/s/1_opDqIowOR0vJgD83oiTPg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_opDqIowOR0vJgD83oiTPg</a> 密码: f78v<br>es6函数：<a href="https://pan.baidu.com/s/1pUP8-et6PST76F6ogd3FVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1pUP8-et6PST76F6ogd3FVg</a> 今日在线直播课程的录屏<br>开发chrome插件：<br>主题：手把手带你开发Chrome插件<br>链接：<a href="https://pan.baidu.com/s/1D2kGN89yQEgy9IZegc6VqA" target="_blank" rel="noopener">https://pan.baidu.com/s/1D2kGN89yQEgy9IZegc6VqA</a> 密码：e7we</p><p>pre course 简书地址<br><a href="https://www.jianshu.com/p/642601569bf7?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weixin" target="_blank" rel="noopener">https://www.jianshu.com/p/642601569bf7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin</a></p><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象基础   https://github.com/Mucheng910/class-es6.git</span><br></pre></td></tr></table></figure><p>测试过程  <a href="https://www.jianshu.com/p/850b3e870261" target="_blank" rel="noopener">https://www.jianshu.com/p/850b3e870261</a><br><img src="https://images-cdn.shimo.im/aDjgCGS4pgAny7y7/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180721102232.jpg!thumbnail" alt="图片"></p><p># </p><p># </p><h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Q1：如果想在浏览器中输入一个未曾注册的域名，例如，<a href="http://www.qinlin.top，浏览器响应的是www.baidu.com，那么这个代码应该怎么写" target="_blank" rel="noopener">www.qinlin.top，浏览器响应的是www.baidu.com，那么这个代码应该怎么写</a><br>A1：</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class=&quot;headerlink&quot; title=&quot;第一阶段&quot;&gt;&lt;/a&gt;第一阶段&lt;/h1&gt;&lt;p&gt;集合运算合集：&lt;br&gt;Q1:./practices/collectionOperator/get_letter_i
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vmware14 安装 Ubuntu18.04 教程</title>
    <link href="http://yoursite.com/vmware14%20%E5%AE%89%E8%A3%85%20Ubuntu18.04%20%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/vmware14 安装 Ubuntu18.04 教程/</id>
    <published>2019-02-22T07:31:42.000Z</published>
    <updated>2019-02-22T07:33:50.925Z</updated>
    
    <content type="html"><![CDATA[<hr><p>作者：王星    有问题请发邮件：<a href="mailto:admin@stormxing.com" target="_blank" rel="noopener">admin@stormxing.com</a></p><h1 id="准备必要文件"><a href="#准备必要文件" class="headerlink" title="准备必要文件"></a>准备必要文件</h1><p>首先需要用到两个文件，你可以用我给的地址下载：</p><ul><li>VMware 14 pro</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/VMware-workstation-full-14.1.1.exe" target="_blank" rel="noopener">https://dl.stormxing.com/share/VMware-workstation-full-14.1.1.exe</a></p><ul><li>Ubuntu 18.04 LTS</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/ubuntu-18.04-desktop-amd64.iso" target="_blank" rel="noopener">https://dl.stormxing.com/share/ubuntu-18.04-desktop-amd64.iso</a></p><ul><li>Ubuntu 16.04 LTS （备用，非必须）</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/ubuntu-16.04.3-desktop-amd64.iso" target="_blank" rel="noopener">https://dl.stormxing.com/share/ubuntu-16.04.3-desktop-amd64.iso</a></p><blockquote><p>有小伙伴反应，Ubuntu 18.04 安装不上，可能是刚出来，vmware 对它的支持还不好，换成Ubuntu16.04 就好了。</p></blockquote><h1 id="安装-VMware-14-pro"><a href="#安装-VMware-14-pro" class="headerlink" title="安装 VMware 14 pro"></a>安装 VMware 14 pro</h1><ol><li>打开软件之后先点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/0cjVJXojWnoj3bQS/vm01.png!thumbnail" alt="图片"></p><ol><li>建议把安装位置改一下，软件比较大，默认是安装到 C 盘的。这个增强型键盘驱动程序无需安装。</li></ol><p><img src="https://images-cdn.shimo.im/VB2yOwDrjMEuIGko/vm02.png!thumbnail" alt="图片"></p><ol><li>最后，要把这两个打钩的去掉。</li></ol><p><img src="https://images-cdn.shimo.im/GFQUfRwk7YIpLDPJ/vm03.png!thumbnail" alt="图片"></p><h1 id="激活-VMware-14-Pro"><a href="#激活-VMware-14-Pro" class="headerlink" title="激活 VMware 14 Pro"></a>激活 VMware 14 Pro</h1><ol><li>在软件安装完成的时候点击「许可证」。</li></ol><p><img src="https://images-cdn.shimo.im/sItvPLwBHGI5XXvN/vm04.png!thumbnail" alt="图片"></p><ol><li><p>输入一下密匙后点「输入」</p><p>   CG54H-D8D0H-H8DHY-C6X7X-N2KG6</p></li></ol><p><img src="https://images-cdn.shimo.im/ELrxOQNjALoJY8H6/vm05.png!thumbnail" alt="图片"></p><ol><li>之后打开 vmware ，点击「帮助」——&gt;「关于」，可以看到软件是激活的。</li></ol><p><img src="https://images-cdn.shimo.im/ayRUKVpVzPsBzN5X/vm06.png!thumbnail" alt="图片"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a>安装 Ubuntu 18.04</h1><ol><li>点击「创建新的虚拟机」，按默认的安装方式点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/XLtcf5Mm78E8U0GW/vm07.png!thumbnail" alt="图片"></p><ol><li>点击浏览，然后选择刚下载好的镜像，打开之后点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/pyUOPJoj69kisTjV/vm08.png!thumbnail" alt="图片"></p><ol><li>设置 Ubuntu 的用户名和密码，我这里输入的都是 test，你要换成你自己的。</li></ol><p><img src="https://images-cdn.shimo.im/jpnuYguEhl0WiVwE/vm09.png!thumbnail" alt="图片"></p><ol><li>然后选择安装位置，这个位置一定要改一下，默认的是 c 盘。</li></ol><p><img src="https://images-cdn.shimo.im/AU6PtGOoxiIOk5g6/vm10.png!thumbnail" alt="图片"></p><ol><li>设置 Ubuntu 最大可用空间，我这里设置的 20 G，你可以设置大一点。其他的不要动，直接点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/Rz7Dvp1qKCgkxCEq/vm11.png!thumbnail" alt="图片"></p><ol><li>接着可以自定义硬件，如果你不太懂的话，我也建议你无需更改，默认的设置就很好。</li></ol><p><img src="https://images-cdn.shimo.im/9szbCtbZqRU4pX6M/vm12.png!thumbnail" alt="图片"></p><ol><li>最后，他就开始安装了，可惜的是我这里报错了，不要惊慌！如果你跟我一样，则接着进行下面的设置。</li></ol><p><img src="https://images-cdn.shimo.im/W79pau1xR9w0bKka/vm13.png!thumbnail" alt="图片"></p><ol><li><p>打开电脑的「控制面板」——&gt;「程序」——&gt;「启用或关闭 Windows 功能」。<br><img src="https://images-cdn.shimo.im/KjWTbdSCWo4zKlBw/vm14.png!thumbnail" alt="图片"></p></li><li><p>找到 「Hyper-V」,将勾去掉，然后点确定。最后它会提示要重启电脑，这个也是一定要重启的。</p></li></ol><p><img src="https://images-cdn.shimo.im/poIsPKd7xNs9gvgX/vm15.png!thumbnail" alt="图片"></p><ol><li>重启电脑之后，点击「开启此虚拟机」</li></ol><p><img src="https://images-cdn.shimo.im/ZAeGwPUVhGwWXWDS/vm16.png!thumbnail" alt="图片"></p><ol><li>接着就会自动安装 Ubuntu，这个过程大概会持续 10 到 20 分钟左右。如果你电脑配置较好的话，需要的时间则更短。</li></ol><p><img src="https://images-cdn.shimo.im/aLE3Z1z6l9ATo7F1/vm17.png!thumbnail" alt="图片"></p><ol><li>安装完成之后点击用户，登录即可。</li></ol><p><img src="https://images-cdn.shimo.im/DBVuquqTTmYDnN9b/vm18.png!thumbnail" alt="图片"></p><ol><li>电脑竟然卡住了，点击「重新启动客户机」即可。</li></ol><p><img src="https://images-cdn.shimo.im/cs6KwQQiI2gdDPSZ/vm19.png!thumbnail" alt="图片"></p><ol><li>然后就顺利的进入到 Ubuntu 18.04 了。请尽情体验吧。</li></ol><p><img src="https://images-cdn.shimo.im/yAiqkdfcirQ6PE5R/vm20.png!thumbnail" alt="图片"></p><ol><li>个人觉得只需要掌握虚拟机的开机、关机、全屏这些操作即可，其他的自己探索吧。</li></ol><p><img src="https://images-cdn.shimo.im/X0jQaBUUg3w25zd7/vm21.png!thumbnail" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;作者：王星    有问题请发邮件：&lt;a href=&quot;mailto:admin@stormxing.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;admin@stormxing.com&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;准备必要文件&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库和非关系型数据库的区别</title>
    <link href="http://yoursite.com/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/关系型数据库和非关系型数据库的区别/</id>
    <published>2019-02-22T06:06:29.000Z</published>
    <updated>2019-02-22T06:08:15.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>非关系型数据库：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。<br>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</p><p>关系型数据库：是指采用了关系模型来组织数据的数据库。<br>关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p><p>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>对于安全性能很高的数据访问要求可以实现。</p><h1 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h1><p>目前基本上大部分主流的非关系型数据库都是免费的。而比较有名气的关系型数据库，比如Oracle、DB2、MSSQL是收费的。虽然Mysql免费，但它需要做很多工作才能正式用于生产。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</p><p>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/assets/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190222140312.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/lijock/article/details/81950660" target="_blank" rel="noopener">关系型数据库和非关系型数据库的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;非关系型数据库：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。&lt;br&gt;非关系型数据
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
