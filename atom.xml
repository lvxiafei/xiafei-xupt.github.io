<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiafei-xupt&#39;s blog</title>
  
  <subtitle>汝之意志所向,即吾剑之所指</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-07T14:06:44.423Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiafei-xupt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件系统理论学习</title>
    <link href="http://yoursite.com/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/文件系统理论学习/</id>
    <published>2019-03-07T10:56:49.000Z</published>
    <updated>2019-03-07T14:06:44.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><p>计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p><p>文件系统通常使用硬盘和光盘这样的存储设备，并维护文件在设备中的物理位置。但是，实际上文件系统也可能仅仅是一种访问数据的界面而已，实际的数据是通过网络协议（如NFS、SMB、9P等）提供的或者内存上，甚至可能根本没有对应的文件（如proc文件系统）。</p><p>严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）</p><h2 id="LKPA"><a href="#LKPA" class="headerlink" title="LKPA"></a>LKPA</h2><p>从系统角度看，文件系统是对文件存储器空间进行组织和分配，负责文件的存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等</p><p>文件系统指文件存在的物理空间，Linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。Linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件系统是一种用于向用户提供底层数据访问的机制！</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>庞大的数据结构</li><li>一切皆文件</li><li>文件系统的目录组织是一个树形结构</li><li>文件本身是无结构的字符流</li><li>文件系统把外部设备做成特殊文件,与普通文件一并进行管理</li></ul><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>每个分区是一棵树/根目录</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/assets/blogImg/微信图片_20190307192332.jpg" alt=""></p><ul><li>/bin 二进制可执行命令</li><li>/dev 设备特殊文件</li><li>/etc 系统管理和配置文件</li><li>/home 用户主目录的基点，比如用户user的主目录就是/home/user。</li><li>/lib 标准程序设计库，又叫动态链接共享库。</li><li>/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序</li><li>/tmp 公用的临时文件存储点</li><li>/root 系统管理员的主目录</li><li>/mnt 用户临时安装其他文件系统的目录。</li><li>/proc 虚拟的目录，不占用磁盘空间，是系统内存的映射。可直接访问这个目录来获取系统信息。</li><li>/var 某些大文件的溢出区，例如各种服务的日志文件</li><li>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录下。</li></ul><p><strong>总结：</strong>整个文件系统只有一棵树，根目录是公共地方，家目录你随便折腾（体现了多用户的特点）</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>每个分区都是一个文件系统  </p><h2 id="索引节点号"><a href="#索引节点号" class="headerlink" title="索引节点号"></a>索引节点号</h2><p>标识一个文件<br>eg:</p><pre><code>ls -li  cat /proc/filesystems</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>mount：</strong>一般挂载到/mnt目录下</p><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p><img src="/assets/blogImg/微信图片_20190307191152.png" alt=""></p><h2 id="常规文件"><a href="#常规文件" class="headerlink" title="常规文件"></a>常规文件</h2><p>存放数据、程序等信息的文件，一般分为文本文件和二进制文件</p><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>将文件的名称和它的索引节点号结合在一起的一张表</p><h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><p>每种I/O设备对应一个设备文件，存放在/dev目录中</p><h2 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h2><p>主要用于在进程间传递数据的媒介，Linux对管道的操作与文件操作相同，将管道作为文件进行处理，又称为先进先出文件  </p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>又称为符号链接文件，提供了共享文件的一种方法。使用链接文件可以访问常规文件，目录文件和其它文件</p><p><strong>注意：</strong>通过<code>ls /dev -l</code>命令可以看到fifo为管道文件，d为目录文件，c为字符文件，l为链接文件</p><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>虚拟文件系统（简称VFS）为用户程序提供了具体文件系统的接口，它对每个具体文件系统的细节进行抽象，使所有文件系统依赖于VFS且可以通过VFS协同工作。要注意VFS与具体文件系统的区别，VFS只存在于内存中，在系统启动时创建，在系统关闭时消亡。</p><h2 id="虚拟含义"><a href="#虚拟含义" class="headerlink" title="虚拟含义"></a>虚拟含义</h2><ol><li>在同一个目录结构中, 可以挂载着若干种不同的文件系统. VFS隐藏了它们的实现细节, 为使用者提供统一的接口;</li><li>目录结构本身并不是绝对的, 每个进程可能会看到不一样的目录结构. 目录结构是由”地址空间(namespace)”来描述的, 不同的进程可能拥有不同的namespace, 不同的namespace可能有着不同的目录结构(因为它们可能挂载了不同的文件系统).</li></ol><h2 id="VFS中四个主要对象"><a href="#VFS中四个主要对象" class="headerlink" title="VFS中四个主要对象"></a>VFS中四个主要对象</h2><p>超级块对象：描述已安装文件系统。</p><p>索引节点对象：描述一个文件。</p><p>目录项对象：描述一个目录项，是路径的组成部分。</p><p>文件对象：描述由进程打开的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;h2 id=&quot;wiki&quot;&gt;&lt;a href=&quot;#wiki&quot; class=&quot;headerlink&quot; title=&quot;wiki&quot;&gt;&lt;/a&gt;wiki&lt;/h
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>空循环引起的问题</title>
    <link href="http://yoursite.com/%E7%A9%BA%E5%BE%AA%E7%8E%AF%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/空循环引起的问题/</id>
    <published>2019-03-07T03:48:53.000Z</published>
    <updated>2019-03-07T03:48:54.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输出为-1"><a href="#输出为-1" class="headerlink" title="输出为-1"></a>输出为-1</h1><p>下列程序的输出结果是（ ）</p><pre><code>int main(void){        int Y=1;        while(Y--);        printf(&quot;Y=%d&quot;,Y);}</code></pre><p>A.Y=0    B.Y=1    C.Y=-1    D.Y=随机数</p><h1 id="输出为0"><a href="#输出为0" class="headerlink" title="输出为0"></a>输出为0</h1><p>那么</p><pre><code>int main(void){        int Y=1;        while(Y--)        printf(&quot;Y=%d&quot;,Y);}</code></pre><p>呢？</p><p><strong>解析：</strong></p><ul><li>第一个程序由于是空循环，当Y为0时还要判断一下，故结果为-1</li><li>第二个程序直接输出，结果为0</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;输出为-1&quot;&gt;&lt;a href=&quot;#输出为-1&quot; class=&quot;headerlink&quot; title=&quot;输出为-1&quot;&gt;&lt;/a&gt;输出为-1&lt;/h1&gt;&lt;p&gt;下列程序的输出结果是（ ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(void)
{
        int 
      
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>中断发展史</title>
    <link href="http://yoursite.com/%E4%B8%AD%E6%96%AD%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>http://yoursite.com/中断发展史/</id>
    <published>2019-03-06T03:40:16.000Z</published>
    <updated>2019-03-06T03:44:01.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h1><p>首先，中断上下部分是为了避免中断嵌套时关中断太长有些中断得不到响应引出的一种机制，中断既能让程序运行的快，又能让程序完成的多个工作，即有效利用时间和空间，中断上半部分是特点是快速可以及时快速响应所有中断（避免了有些中断得不到响应这种情况的发生），中断下半部分执行的比较慢，它才是中断主要执行的有用部分，相对于上半部分而言，下半部分执行时可以被中断，也就是允许并发，考虑到中断下半部分的执行，引出了小任务机制，不可睡眠，工作队列，可睡眠， </p><p>引出软中断实现中断下半部分，随着中断数的不停增加，软中断不够用了，于是下半部又做了进化，为了提高中断处理数量，顺道改进处理效率，于是产生了tasklet机制（小任务机制）</p><p>由于之前机制中的中断不可挂起，串行执行，也就是说只要有一个处理时间较长，则会导致其他中断响应的延迟，为了完成这些不可能完成的任务，引出了工作队列，工作队列的本质是一组内核线程，作为中断守护线程来使用。</p><p>操作系统显然不能任由每个中断各自为政，为了对所有中断进行统一管理，引入软中断<br>我们不可中断部分的共同部分放在函数do_IRQ中，需要添加中断处理函数时，通过request_irq实现。下半部放在do_softirq中，也就是软中断，通过open_softirq添加对应的处理函数。</p><p>旧事物跟不上历史的发展时，总会有新事物出现。随着中断数的不停增加，软中断不够用了，于是下半部又做了进化。软中断用轮询的方式处理。假如正好是最后一种中断，则必须循环完所有的中断类型，才能最终执行对应的处理函数。显然当年开发人员为了保证轮询的效率，于是限制中断个数为32个。</p><p>为了提高中断处理数量，顺道改进处理效率，于是产生了tasklet机制。</p><p><strong>工作队列：</strong>由于之前机制中的中断不可挂起，串行执行，也就是说只要有一个处理时间较长，则会导致其他中断响应的延迟，为了完成这些不可能完成的任务，引出了工作队列，工作队列的本质是一组内核线程，作为中断守护线程来使用。</p><p><img src="/assets/blogImg/图fdefef1.png" alt=""></p><h1 id="中断的栈和进程的栈是一个么？"><a href="#中断的栈和进程的栈是一个么？" class="headerlink" title="中断的栈和进程的栈是一个么？"></a>中断的栈和进程的栈是一个么？</h1><p>不是，因为每个进程都有属于自己的栈（每个进程都有自己的虚拟空间，虚拟空间中有栈，在执行时通过页机制转换），假设中断栈和进程栈是同一个栈，那么每个进程的栈地址都不一样，这样恢复中断时将变得非常麻烦。中断栈应该公有，因为中断最后是要中断CPU的，而内核是管理硬件的，所以猜测中断栈应该在内核态，内核空间也有自己的栈，那么内核栈是否和中断栈是同一个栈？<br>查阅资料得知在2.4版本中，中断栈和内核栈共享，优点是代码简单，缺点是共享有时可能会导致内核栈空间不够用（内核栈和中断栈数据共享），为了改善这个缺点，要么扩大内核栈大小，要么在内核空间重新开辟一个栈，称为中断栈，考虑到中断栈如果发生嵌套，可能会破坏内核栈数据（可能会造成栈溢出），所以现在Linux内核采用内核栈和中断栈分离的设计</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Quartu_flag/article/details/78339318" target="_blank" rel="noopener">Linux中的中断处理机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;发展过程&quot;&gt;&lt;a href=&quot;#发展过程&quot; class=&quot;headerlink&quot; title=&quot;发展过程&quot;&gt;&lt;/a&gt;发展过程&lt;/h1&gt;&lt;p&gt;首先，中断上下部分是为了避免中断嵌套时关中断太长有些中断得不到响应引出的一种机制，中断既能让程序运行的快，又能让程序完成的多
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Level DB和Couch DB的区别？</title>
    <link href="http://yoursite.com/Level%20DB%E5%92%8CCouch%20DB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/Level DB和Couch DB的区别？/</id>
    <published>2019-03-06T02:47:10.000Z</published>
    <updated>2019-03-06T02:59:28.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><p>Level DB：(是fabric默认的db），Level DB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</p><p>Counch DB：支持副查询（更加丰富），Couch DB 是一种可选的替代 level DB 的状态数据库。</p><p>与 Level DB 键值存储一样，Couch DB 不仅可以根据 key 进行相应的查询，还可以根据不同的应用场景需求实现复杂查询。</p><h1 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h1><p><img src="/assets/blogImg/图片1.png" alt=""> </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://db-engines.com/en/system/CouchDB%3BLevelDB" target="_blank" rel="noopener">CouchDB vs. LevelDB Comparison - DB-Engines</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关定义&quot;&gt;&lt;a href=&quot;#相关定义&quot; class=&quot;headerlink&quot; title=&quot;相关定义&quot;&gt;&lt;/a&gt;相关定义&lt;/h1&gt;&lt;p&gt;Level DB：(是fabric默认的db），Level DB 是嵌入在 Peer 中的默认键值对（key-value）状
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>文件描述符</title>
    <link href="http://yoursite.com/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/文件描述符/</id>
    <published>2019-03-05T13:41:51.000Z</published>
    <updated>2019-03-06T02:44:22.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h1><p>1.对于内核而言，所有打开文件都由文件描述符引用<br>2.文件描述符是一个非负整数<br>3.当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符<br>4.当读、写一个文件时，用open或create返回的文件描述符标书该文件，将其作为参数传送给read或write</p><h1 id="代码体现"><a href="#代码体现" class="headerlink" title="代码体现"></a>代码体现</h1><p><strong>fs_test.c：</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc,char *argv[]){        int fd = open(&quot;/etc/passwd&quot;,O_RDONLY);        printf(&quot;fd : %d\n&quot;,fd);        return 0;}</code></pre><p>执行上面代码，返回值是3</p><p><strong>注：</strong>fcntl.h，是unix标准中通用的头文件，其中包含的相关函数有 open，fcntl，shutdown，unlink，fclose等！</p><h1 id="为什么是3？"><a href="#为什么是3？" class="headerlink" title="为什么是3？"></a>为什么是3？</h1><p>当一个进程启动时，它会自动打开三个文件，这三个文件分别是：标准输入、标准输出、标准出错，它们对应的文件描述符分别是0、1、2，所以当打开/etc/passwd这个文件时，它就接着以3开始计数了。</p><p>POSIX.1应用程序中，整数0、1、2营被代换成符号常数STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，这些常数都定义在头文件&lt;unistd.h&gt;（可在/usr/include目录下找到，或使用<code>cat unistd.h | grep STDIN_FILENO</code>查看）中。</p><p>文件描述符范围0-OPEN_MAX。早期UNIX版本采用的上限值是19（允许每个进程打开20个文件），现在很多系统将其增加至63，Linux为1024。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关说明&quot;&gt;&lt;a href=&quot;#相关说明&quot; class=&quot;headerlink&quot; title=&quot;相关说明&quot;&gt;&lt;/a&gt;相关说明&lt;/h1&gt;&lt;p&gt;1.对于内核而言，所有打开文件都由文件描述符引用&lt;br&gt;2.文件描述符是一个非负整数&lt;br&gt;3.当打开一个现存文件或创建一个
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>C语言中fprintf和printf的区别？</title>
    <link href="http://yoursite.com/C%E8%AF%AD%E8%A8%80%E4%B8%ADfprintf%E5%92%8Cprintf%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/C语言中fprintf和printf的区别？/</id>
    <published>2019-03-05T13:36:40.000Z</published>
    <updated>2019-03-05T13:39:26.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>fprintf的函数原型为：</p><pre><code>int fprintf( FILE *stream, const char *format, [ argument ]...)；</code></pre><p>而printf的函数原型为：</p><pre><code>int printf( const char *format [, argument]... );</code></pre><p>因此fprintf是将字符输出到流（文件）的，而printf是输出到标准输出设备（stdout）的，一般就是屏幕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h1&gt;&lt;p&gt;fprintf的函数原型为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int fprintf( FILE *stream, const char *f
      
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>假期论文阅读汇总</title>
    <link href="http://yoursite.com/%E5%81%87%E6%9C%9F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/假期论文阅读汇总/</id>
    <published>2019-03-01T06:09:17.000Z</published>
    <updated>2019-03-01T06:34:24.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《分布式文件系统性能测试和优化研究》"><a href="#《分布式文件系统性能测试和优化研究》" class="headerlink" title="《分布式文件系统性能测试和优化研究》"></a>《分布式文件系统性能测试和优化研究》</h1><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>文章对分布式文件系统的关键技术和GlusterFS的系统架构进行了研究，然后对GlusterFS的文件系统进行了测试，根据测试结果，设计了一套在LevelDB上存储GlusterFS元数据及其扩展属性的方案，使系统的元数据性能得到了提高。</p><h2 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h2><p>互联网的高速发展使得对大数据的存储需求越来越高，应对高并发的数据访问是互联网技术很大的挑战。分布式系统通过计算机网络把不一定连接在本地的物理存储资源连接成集群，其文件系统管理元数据的方式有三种：一是集中式元数据服务模型，二是分布式元数据服务模型，三是无元数据服务模型。GlusterFS采用了无元数据服务模型。这使得GlusterFS避开了前两种模型不能彻底解决的问题，消除了元数据性能瓶颈、单点故障、数据一致性等一系列相关问题，并且使得系统的扩展性显著提高，获得了接近线性的高扩展性。但是，这也导致了GlusterFS部分元数据操作的缓慢。文章修改了LevelDB存储部分元数据的存储方式，让一部分元数据操作通过LevelDB进行，加快元数据操作的速度，从而能提升了性能。</p><h2 id="论文启发"><a href="#论文启发" class="headerlink" title="论文启发"></a>论文启发</h2><ol><li>其他分布式文件系统是否也可以使用数据库保存元数据来加快元数据操作速度？</li><li>数据库的选取对元数据操作速度有影响吗？如果有可否选取合适的数据库进行调优？</li><li>在集中式元数据服务模型和分布式元数据服务模型中应该怎样优化呢？</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章对GlusterFS分布式文件系统进行了详细的分析。试图通过使用<strong>LevelDB保存GlusterFS元数据</strong>来加快GlusterFS元数据操作的速度。</p><h1 id="《分布式文件系统海量小文件性能优化技术研究》"><a href="#《分布式文件系统海量小文件性能优化技术研究》" class="headerlink" title="《分布式文件系统海量小文件性能优化技术研究》"></a>《分布式文件系统海量小文件性能优化技术研究》</h1><h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>文章的主要研究对象是实验室自主独立开发的分布式文件系统Cappella，将小文件访问主要耗时定位到元数据或数据访问时的<strong>磁盘I/O</strong>，对该点进行相关优化可以提高系统对小文件的访问性能。通过本文的研究，证实通过改善小文件的访问性能可以有效提高分布式文件系统的总体性能，同时本文的研究方式也可以给今后小文件性能问题研究提供借鉴，文章的研究内容有非常大的研究意义。</p><h2 id="论文内容-1"><a href="#论文内容-1" class="headerlink" title="论文内容"></a>论文内容</h2><p>主要对分布式文件系统Cappella的小文件访问过程进行研究分析，主要对访问过程中客户端与服务器之间的交互过程以及小文件访问耗时进行分析，结合小文件的访问特点确定小文件访问过程中的主要瓶颈。根据对小文件访问瓶颈分析，对小文件应用场景下的Cappella文件系统进行优化，主要包括对小文件的访问流程进行精简，然后使用文件聚合存储技术将小文件的元数据信息和数据信息一起存储在元数据服务器，然后优化了小文件访问过程中的I/O路径，对小文件的写操作使用批量刷回技术进行优化，小文件读操作使用缓存预取技术进行优化。最后对比测试了优化前后Cappella文件系统以及Lustre文件系统的元数据IOPS、小文件读写性能、小文件并发访问性能、大文件读写性能进行测试。</p><p>文章详细测试了Cappella文件系统对海量小文件优化前后的性能，主要包括元数据服务器吞吐量、系统小文件读写性能、系统小文件并发测试以及系统大文件读写性能测试。根据测试结果分析可得，优化后Cappella文件系统元数据吞吐量大幅增加；对小文件的读写性能提升明显；多线程并发写，小文件性能同样有明显提升；系统大文件读写性能有小幅提升。</p><h2 id="论文启发-1"><a href="#论文启发-1" class="headerlink" title="论文启发"></a>论文启发</h2><ol><li>文章中主要对应的存储介质是HDD，考虑到新型介质发展迅速，可以进一步测试不同存储介质情况下本优化方案的提升空间；</li><li>文章中提到的优化方案只是在Cappella这一具体的文件系统上实现，理论上是可以适用于其他分布式文件系统，但是还是需要进行实际的验证，因此本优化方案是否具有普适性就需要更进一步的验证。</li><li>文章仅仅验证了小文件数量在千万级时优化方案对性能还有提升效果，但是当小文件数量更大时本文中的优化方案是否依然有效就需要更深入的测试分析。</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对小文件的访问流程进行精简，然后使用文件聚合存储技术将小文件的元数据信息和数据信息一起存储在元数据服务器，然后优化了小文件访问过程中的I/O路径，对小文件的写操作使用批量刷回技术进行优化，小文件读操作使用缓存预取技术进行优化，从而达到对Cappella文件系统中小文件进行优化的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《分布式文件系统性能测试和优化研究》&quot;&gt;&lt;a href=&quot;#《分布式文件系统性能测试和优化研究》&quot; class=&quot;headerlink&quot; title=&quot;《分布式文件系统性能测试和优化研究》&quot;&gt;&lt;/a&gt;《分布式文件系统性能测试和优化研究》&lt;/h1&gt;&lt;h2 id=&quot;文
      
    
    </summary>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 全栈课程-答疑模块</title>
    <link href="http://yoursite.com/JavaScript%20%E5%85%A8%E6%A0%88%E8%AF%BE%E7%A8%8B-%E7%AD%94%E7%96%91%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/JavaScript 全栈课程-答疑模块/</id>
    <published>2019-02-22T07:37:29.000Z</published>
    <updated>2019-02-22T07:38:25.056Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>集合运算合集：<br>Q1:./practices/collectionOperator/get_letter_interval_2_spec.js  文件应该怎么写？需要预置一个字符数组吗？<br>A1.1:两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getBasicLetter() &#123;</span><br><span class="line">  let basicLetter = [];</span><br><span class="line">  for (let i = 97; i &lt; 97 + 26; ++i)</span><br><span class="line">    basicLetter.push(String.fromCharCode(i));</span><br><span class="line">  return basicLetter;</span><br><span class="line">&#125;//用unicode编码获取</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let ElseLetter =[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;....] //自己写一个字符串数组</span><br></pre></td></tr></table></figure><p>A1.2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function get_letter_interval_2(number_a, number_b) &#123;</span><br><span class="line">  let rounds = getRounds(number_a &gt; number_b ? number_a : number_b);</span><br><span class="line"></span><br><span class="line">  if (number_a &gt; number_b) return getRoundsLetters(rounds).splice(number_b - 1, number_a - number_b + 1).reverse();</span><br><span class="line">  if (number_a &lt; number_b) return getRoundsLetters(rounds).splice(number_a - 1, number_b - number_a + 1);</span><br><span class="line"></span><br><span class="line">  return [getRoundsLetters(rounds)[number_a - 1]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getBasicLetter() &#123;</span><br><span class="line">  let basicLetter = [];</span><br><span class="line">  for (let i = 97; i &lt; 97 + 26; ++i)</span><br><span class="line">    basicLetter.push(String.fromCharCode(i));</span><br><span class="line"></span><br><span class="line">  return basicLetter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRoundsLetters(rounds) &#123;</span><br><span class="line">  let roundsLetters = getBasicLetter();</span><br><span class="line">  let basicLetters = getBasicLetter();</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; rounds - 1; ++i)</span><br><span class="line">    basicLetters.map(letter =&gt; roundsLetters.push(basicLetters[i] + letter));</span><br><span class="line"></span><br><span class="line">  return roundsLetters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRounds(number) &#123;</span><br><span class="line">  let rounds = number / 26;</span><br><span class="line">  if (number % 26 !== 0) rounds += 1;</span><br><span class="line"></span><br><span class="line">  return rounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = get_letter_interval_2;</span><br></pre></td></tr></table></figure></p><p>pos机：<br>Q1:<img src="https://images-cdn.shimo.im/dgcJ7Pu3v4cIRorf/image.png!thumbnail" alt="图片"><br>怎么回事？<br>A1:</p><p><strong>仓库地址：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tdd测试：      https://github.com/Mucheng910/npm-test.git</span><br><span class="line">运算合集：     https://github.com/Mucheng910/80--es6-.git</span><br><span class="line">黄焖鸡：       https://github.com/Mucheng910/take-out-food.git</span><br><span class="line">dom：         https://github.com/Mucheng910/dom.git</span><br></pre></td></tr></table></figure></p><p><strong>tdd测试的pos机测试文件有问题</strong><br><img src="https://images-cdn.shimo.im/7rJWB8d9QVMsbdpI/image.png!thumbnail" alt="图片"><br><em>照这个改一下就好了</em></p><p><strong>课程直播的录频：</strong><br>黄焖鸡：  链接: <a href="https://pan.baidu.com/s/1_opDqIowOR0vJgD83oiTPg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_opDqIowOR0vJgD83oiTPg</a> 密码: f78v<br>es6函数：<a href="https://pan.baidu.com/s/1pUP8-et6PST76F6ogd3FVg" target="_blank" rel="noopener">https://pan.baidu.com/s/1pUP8-et6PST76F6ogd3FVg</a> 今日在线直播课程的录屏<br>开发chrome插件：<br>主题：手把手带你开发Chrome插件<br>链接：<a href="https://pan.baidu.com/s/1D2kGN89yQEgy9IZegc6VqA" target="_blank" rel="noopener">https://pan.baidu.com/s/1D2kGN89yQEgy9IZegc6VqA</a> 密码：e7we</p><p>pre course 简书地址<br><a href="https://www.jianshu.com/p/642601569bf7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin" target="_blank" rel="noopener">https://www.jianshu.com/p/642601569bf7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin</a></p><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象基础   https://github.com/Mucheng910/class-es6.git</span><br></pre></td></tr></table></figure><p>测试过程  <a href="https://www.jianshu.com/p/850b3e870261" target="_blank" rel="noopener">https://www.jianshu.com/p/850b3e870261</a><br><img src="https://images-cdn.shimo.im/aDjgCGS4pgAny7y7/微信图片_20180721102232.jpg!thumbnail" alt="图片"></p><p># </p><p># </p><h1 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Q1：如果想在浏览器中输入一个未曾注册的域名，例如，<a href="http://www.qinlin.top，浏览器响应的是www.baidu.com，那么这个代码应该怎么写" target="_blank" rel="noopener">www.qinlin.top，浏览器响应的是www.baidu.com，那么这个代码应该怎么写</a><br>A1：</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class=&quot;headerlink&quot; title=&quot;第一阶段&quot;&gt;&lt;/a&gt;第一阶段&lt;/h1&gt;&lt;p&gt;集合运算合集：&lt;br&gt;Q1:./practices/collectionOperator/get_letter_i
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vmware14 安装 Ubuntu18.04 教程</title>
    <link href="http://yoursite.com/vmware14%20%E5%AE%89%E8%A3%85%20Ubuntu18.04%20%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/vmware14 安装 Ubuntu18.04 教程/</id>
    <published>2019-02-22T07:31:42.000Z</published>
    <updated>2019-02-22T07:33:50.925Z</updated>
    
    <content type="html"><![CDATA[<hr><p>作者：王星    有问题请发邮件：<a href="mailto:admin@stormxing.com" target="_blank" rel="noopener">admin@stormxing.com</a></p><h1 id="准备必要文件"><a href="#准备必要文件" class="headerlink" title="准备必要文件"></a>准备必要文件</h1><p>首先需要用到两个文件，你可以用我给的地址下载：</p><ul><li>VMware 14 pro</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/VMware-workstation-full-14.1.1.exe" target="_blank" rel="noopener">https://dl.stormxing.com/share/VMware-workstation-full-14.1.1.exe</a></p><ul><li>Ubuntu 18.04 LTS</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/ubuntu-18.04-desktop-amd64.iso" target="_blank" rel="noopener">https://dl.stormxing.com/share/ubuntu-18.04-desktop-amd64.iso</a></p><ul><li>Ubuntu 16.04 LTS （备用，非必须）</li></ul><p><a href="https://xings.oss-cn-shanghai.aliyuncs.com/share/ubuntu-16.04.3-desktop-amd64.iso" target="_blank" rel="noopener">https://dl.stormxing.com/share/ubuntu-16.04.3-desktop-amd64.iso</a></p><blockquote><p>有小伙伴反应，Ubuntu 18.04 安装不上，可能是刚出来，vmware 对它的支持还不好，换成Ubuntu16.04 就好了。</p></blockquote><h1 id="安装-VMware-14-pro"><a href="#安装-VMware-14-pro" class="headerlink" title="安装 VMware 14 pro"></a>安装 VMware 14 pro</h1><ol><li>打开软件之后先点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/0cjVJXojWnoj3bQS/vm01.png!thumbnail" alt="图片"></p><ol><li>建议把安装位置改一下，软件比较大，默认是安装到 C 盘的。这个增强型键盘驱动程序无需安装。</li></ol><p><img src="https://images-cdn.shimo.im/VB2yOwDrjMEuIGko/vm02.png!thumbnail" alt="图片"></p><ol><li>最后，要把这两个打钩的去掉。</li></ol><p><img src="https://images-cdn.shimo.im/GFQUfRwk7YIpLDPJ/vm03.png!thumbnail" alt="图片"></p><h1 id="激活-VMware-14-Pro"><a href="#激活-VMware-14-Pro" class="headerlink" title="激活 VMware 14 Pro"></a>激活 VMware 14 Pro</h1><ol><li>在软件安装完成的时候点击「许可证」。</li></ol><p><img src="https://images-cdn.shimo.im/sItvPLwBHGI5XXvN/vm04.png!thumbnail" alt="图片"></p><ol><li><p>输入一下密匙后点「输入」</p><p>   CG54H-D8D0H-H8DHY-C6X7X-N2KG6</p></li></ol><p><img src="https://images-cdn.shimo.im/ELrxOQNjALoJY8H6/vm05.png!thumbnail" alt="图片"></p><ol><li>之后打开 vmware ，点击「帮助」——&gt;「关于」，可以看到软件是激活的。</li></ol><p><img src="https://images-cdn.shimo.im/ayRUKVpVzPsBzN5X/vm06.png!thumbnail" alt="图片"></p><h1 id="安装-Ubuntu-18-04"><a href="#安装-Ubuntu-18-04" class="headerlink" title="安装 Ubuntu 18.04"></a>安装 Ubuntu 18.04</h1><ol><li>点击「创建新的虚拟机」，按默认的安装方式点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/XLtcf5Mm78E8U0GW/vm07.png!thumbnail" alt="图片"></p><ol><li>点击浏览，然后选择刚下载好的镜像，打开之后点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/pyUOPJoj69kisTjV/vm08.png!thumbnail" alt="图片"></p><ol><li>设置 Ubuntu 的用户名和密码，我这里输入的都是 test，你要换成你自己的。</li></ol><p><img src="https://images-cdn.shimo.im/jpnuYguEhl0WiVwE/vm09.png!thumbnail" alt="图片"></p><ol><li>然后选择安装位置，这个位置一定要改一下，默认的是 c 盘。</li></ol><p><img src="https://images-cdn.shimo.im/AU6PtGOoxiIOk5g6/vm10.png!thumbnail" alt="图片"></p><ol><li>设置 Ubuntu 最大可用空间，我这里设置的 20 G，你可以设置大一点。其他的不要动，直接点下一步。</li></ol><p><img src="https://images-cdn.shimo.im/Rz7Dvp1qKCgkxCEq/vm11.png!thumbnail" alt="图片"></p><ol><li>接着可以自定义硬件，如果你不太懂的话，我也建议你无需更改，默认的设置就很好。</li></ol><p><img src="https://images-cdn.shimo.im/9szbCtbZqRU4pX6M/vm12.png!thumbnail" alt="图片"></p><ol><li>最后，他就开始安装了，可惜的是我这里报错了，不要惊慌！如果你跟我一样，则接着进行下面的设置。</li></ol><p><img src="https://images-cdn.shimo.im/W79pau1xR9w0bKka/vm13.png!thumbnail" alt="图片"></p><ol><li><p>打开电脑的「控制面板」——&gt;「程序」——&gt;「启用或关闭 Windows 功能」。<br><img src="https://images-cdn.shimo.im/KjWTbdSCWo4zKlBw/vm14.png!thumbnail" alt="图片"></p></li><li><p>找到 「Hyper-V」,将勾去掉，然后点确定。最后它会提示要重启电脑，这个也是一定要重启的。</p></li></ol><p><img src="https://images-cdn.shimo.im/poIsPKd7xNs9gvgX/vm15.png!thumbnail" alt="图片"></p><ol><li>重启电脑之后，点击「开启此虚拟机」</li></ol><p><img src="https://images-cdn.shimo.im/ZAeGwPUVhGwWXWDS/vm16.png!thumbnail" alt="图片"></p><ol><li>接着就会自动安装 Ubuntu，这个过程大概会持续 10 到 20 分钟左右。如果你电脑配置较好的话，需要的时间则更短。</li></ol><p><img src="https://images-cdn.shimo.im/aLE3Z1z6l9ATo7F1/vm17.png!thumbnail" alt="图片"></p><ol><li>安装完成之后点击用户，登录即可。</li></ol><p><img src="https://images-cdn.shimo.im/DBVuquqTTmYDnN9b/vm18.png!thumbnail" alt="图片"></p><ol><li>电脑竟然卡住了，点击「重新启动客户机」即可。</li></ol><p><img src="https://images-cdn.shimo.im/cs6KwQQiI2gdDPSZ/vm19.png!thumbnail" alt="图片"></p><ol><li>然后就顺利的进入到 Ubuntu 18.04 了。请尽情体验吧。</li></ol><p><img src="https://images-cdn.shimo.im/yAiqkdfcirQ6PE5R/vm20.png!thumbnail" alt="图片"></p><ol><li>个人觉得只需要掌握虚拟机的开机、关机、全屏这些操作即可，其他的自己探索吧。</li></ol><p><img src="https://images-cdn.shimo.im/X0jQaBUUg3w25zd7/vm21.png!thumbnail" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;作者：王星    有问题请发邮件：&lt;a href=&quot;mailto:admin@stormxing.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;admin@stormxing.com&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;准备必要文件&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关系型数据库和非关系型数据库的区别</title>
    <link href="http://yoursite.com/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/关系型数据库和非关系型数据库的区别/</id>
    <published>2019-02-22T06:06:29.000Z</published>
    <updated>2019-02-22T06:08:15.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>非关系型数据库：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。<br>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</p><p>关系型数据库：是指采用了关系模型来组织数据的数据库。<br>关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p><p>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>对于安全性能很高的数据访问要求可以实现。</p><h1 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h1><p>目前基本上大部分主流的非关系型数据库都是免费的。而比较有名气的关系型数据库，比如Oracle、DB2、MSSQL是收费的。虽然Mysql免费，但它需要做很多工作才能正式用于生产。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</p><p>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/assets/blogImg/微信图片_20190222140312.png" alt=""></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/lijock/article/details/81950660" target="_blank" rel="noopener">关系型数据库和非关系型数据库的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;非关系型数据库：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。&lt;br&gt;非关系型数据
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>未来技术猜测</title>
    <link href="http://yoursite.com/%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%B5%8B/"/>
    <id>http://yoursite.com/未来技术猜测/</id>
    <published>2019-02-20T07:45:37.000Z</published>
    <updated>2019-02-20T08:07:01.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开源带来的影响："><a href="#开源带来的影响：" class="headerlink" title="开源带来的影响："></a>开源带来的影响：</h1><p>主线 与 分支</p><p>基类 与 继承</p><p>计算 与 存储</p><h1 id="物联网带来的影响："><a href="#物联网带来的影响：" class="headerlink" title="物联网带来的影响："></a>物联网带来的影响：</h1><p>物物互联，信息共享</p><h1 id="人工智能带来的影响："><a href="#人工智能带来的影响：" class="headerlink" title="人工智能带来的影响："></a>人工智能带来的影响：</h1><p>辅助人类，取代计算机</p><h1 id="区块链带来的影响："><a href="#区块链带来的影响：" class="headerlink" title="区块链带来的影响："></a>区块链带来的影响：</h1><p>去中心化，交易透明   生产关系更加透明</p><h1 id="大数据带来的影响："><a href="#大数据带来的影响：" class="headerlink" title="大数据带来的影响："></a>大数据带来的影响：</h1><p>预测结果越来越接近未来发生</p><h1 id="5G带来的影响："><a href="#5G带来的影响：" class="headerlink" title="5G带来的影响："></a>5G带来的影响：</h1><p>云计算的加速   高速带宽使得传统存储方式发生改变，对硬盘、U盘等大容量存储设备的依赖降低</p><p>高清视屏得到普及   提高用户体验（使用云端硬件资源）</p><h1 id="智能家居"><a href="#智能家居" class="headerlink" title="智能家居"></a>智能家居</h1><p>营造一个理想化的生态使得人类能够专心去做自己喜欢的事情</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开源带来的影响：&quot;&gt;&lt;a href=&quot;#开源带来的影响：&quot; class=&quot;headerlink&quot; title=&quot;开源带来的影响：&quot;&gt;&lt;/a&gt;开源带来的影响：&lt;/h1&gt;&lt;p&gt;主线 与 分支&lt;/p&gt;
&lt;p&gt;基类 与 继承&lt;/p&gt;
&lt;p&gt;计算 与 存储&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="未来" scheme="http://yoursite.com/tags/%E6%9C%AA%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于区块链的五个问题</title>
    <link href="http://yoursite.com/%E4%BA%94%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/五个问题/</id>
    <published>2019-02-18T10:50:00.000Z</published>
    <updated>2019-02-18T10:52:09.506Z</updated>
    
    <content type="html"><![CDATA[<p>作者 ：陈哲 西安邮电大学计算机学院研究生大佬一枚</p><p>五个问题：</p><ul><li><p>我们经常说区块链，那么区块究竟是什么？</p></li><li><p>所谓挖矿是怎么回事？</p></li><li><p>比特币是什么？</p></li><li><p>节点之间的信息如何交换？</p></li><li><p>区块在节点上是如何存储，如何查找的？</p><p>首先我们介绍”比特币核心“（bitcoin core），是由中本聪指定的人选组建的团队,通常被认为是比特币的唯一官方开发团队，其在最初的“中本聪客户端”bitcoin-qt的基础上开发了Bitcoin core钱包也被公认为是比特币的官方钱包。</p><p>在bitcoin core中区块信息被存储在一个个<code>.dat</code>文件中，该文件的结构如下， 一个<code>.bat</code>文件包含多个区块的信息。</p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fxclf9jcbvj22jd30du0x.jpg" alt=""><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fxclbi9bcuj20yd0nfwk7.jpg" alt=""></p><p>为了查找方便将区块头等信息另外组织，存放在<code>level DB</code>数据库，这是一个轻量级的K/V数据库，具有很好的写性能。</p><p>查询时可以通过区块哈希值在数据库中查找到相应的<code>.bat</code>文件名及在该文件中的偏移，从而找到区块的完整信息。</p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fxclbhf5bpj20ns0nvdib.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fxclbi53iyj20x90n6grf.jpg" alt=""></p></li></ul><p>区块链</p><ul><li>PoW（Proof of work）各节点贡献自己的计算资源来竞争解决一个难度可动态调整的数学问题。</li><li><p>区块链系统的五个要素</p><ul><li><p>公共的区块链账本</p></li><li><p>分布式的点对点网络</p></li><li>去中心化的共识算法</li><li>适度的经济激励机制</li><li>可编程的脚本代码（智能合约）</li></ul></li></ul><ul><li>数字加密货币面临的两个问题</li></ul><ul><li><p>双重支付 </p><p>现金是实体自然避免。其它数字形式货币需要第三方中心机构来保证，例如支付宝。</p></li></ul><ul><li><p>拜占庭将军问题</p><p>分布式节点如何达成共识和建立互信。</p></li></ul><h2 id="区块链技术的基础模型"><a href="#区块链技术的基础模型" class="headerlink" title="区块链技术的基础模型"></a>区块链技术的基础模型</h2><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fx8ome53n1j20dr0i5taj.jpg" alt="img"></p><ul><li><p>数据层</p><ul><li><p>数据区块</p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fx8olcgjv8j20d50armz4.jpg" alt="img"></p><ul><li><p>区块头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header_structure</span> &#123;</span>      <span class="comment">// BYTES   NAME</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> nVersion;            <span class="comment">// 4       version</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> hashPrevBlock[<span class="number">32</span>];    <span class="comment">// 32     previous block header hash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> hashMerkleRoot[<span class="number">32</span>];   <span class="comment">// 32     merkle root hash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> nTime;               <span class="comment">// 4       time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> nBits;               <span class="comment">// 4       target</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> nNonce;              <span class="comment">// 4       nonce</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>区块体</p><p>包含一定时间段内的交易数据，及交易信息的Merkel树结构。</p></li></ul></li><li><p>哈希函数–SHA256算法</p><p>SHA（Secure Hash Algorithm）是一种密码散列函数算法标准。由美国国家安全局研发，由美国国家标准与技术研究院发布，是美国政府标准。</p><p>其摘要长度为256bits，故称为SHA256。</p><p>其特点为，不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。        </p><p>SHA将消息当成一个位（bit）字符串来处理。</p><p>描述：</p><ul><li><p>常量初始化</p><p>8个哈希初值，由自然数中前8个质数取平方根后，将小数部分转化为16进制，再取前32bit构成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">h0 := 0x6a09e667</span><br><span class="line"></span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line"></span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line"></span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line"></span><br><span class="line">h4 := 0x510e527f</span><br><span class="line"></span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line"></span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line"></span><br><span class="line">h7 := 0x5be0cd19</span><br></pre></td></tr></table></figure><p>64个哈希常量，由自然数中前64个质数取立方根后，将小数部分转化为16进制，再取前32bit构成。这里记为Kt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">428a2f98 71374491 b5c0fbcf e9b5dba5</span><br><span class="line"></span><br><span class="line">3956c25b 59f111f1 923f82a4 ab1c5ed5</span><br><span class="line"></span><br><span class="line">d807aa98 12835b01 243185be 550c7dc3</span><br><span class="line"></span><br><span class="line">72be5d74 80deb1fe 9bdc06a7 c19bf174</span><br><span class="line"></span><br><span class="line">e49b69c1 efbe4786 0fc19dc6 240ca1cc</span><br><span class="line"></span><br><span class="line">2de92c6f 4a7484aa 5cb0a9dc 76f988da</span><br><span class="line"></span><br><span class="line">983e5152 a831c66d b00327c8 bf597fc7</span><br><span class="line"></span><br><span class="line">c6e00bf3 d5a79147 06ca6351 14292967</span><br><span class="line"></span><br><span class="line">27b70a85 2e1b2138 4d2c6dfc 53380d13</span><br><span class="line"></span><br><span class="line">650a7354 766a0abb 81c2c92e 92722c85</span><br><span class="line"></span><br><span class="line">a2bfe8a1 a81a664b c24b8b70 c76c51a3</span><br><span class="line"></span><br><span class="line">d192e819 d6990624 f40e3585 106aa070</span><br><span class="line"></span><br><span class="line">19a4c116 1e376c08 2748774c 34b0bcb5</span><br><span class="line"></span><br><span class="line">391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3</span><br><span class="line"></span><br><span class="line">748f82ee 78a5636f 84c87814 8cc70208</span><br><span class="line"></span><br><span class="line">90befffa a4506ceb bef9a3f7 c67178f2</span><br></pre></td></tr></table></figure><ul><li><p>信息预处理</p><p>消息必须进行补位，以使其长度对512取模后余数为448，先补1，再之后补0。</p><p>附加长度值，用64bit表示补位前消息的长度，并附加在第一步处理后的消息之后。这样总的消息长度能被512整除。</p><p>逻辑运算</p></li></ul></li></ul><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fx8l469we0j20cm05qjrj.jpg" alt="img"></p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fx8l466yt0j207m05rgll.jpg" alt="img"></p><ul><li><p>迭代计算消息摘要</p><p>1, 将原始消息分解为512bit大小的块</p><p>2, 对于每一块，将其分解为16个32bit字记为W[0]…W[15]</p><p>3, 根据如下公式，再构造出48个字</p><pre><code>Wt=σ1(Wt−2)+Wt−7+σ0(Wt−15)+Wt−1</code></pre><p>这样我们一共获得了64个32位字Wt</p><p>下面开始进行迭代计算：</p><p>对每一块512bit长的消息块需要进行64次迭代，初始的ABCDEFGH即为h0…h7</p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fx8l226a3zj20b407ut8s.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for i from 0 to 63</span><br><span class="line">s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)</span><br><span class="line">maj := (a and b) xor (a and c) xor(b and c)</span><br><span class="line">t2 := s0 + maj</span><br><span class="line">s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)</span><br><span class="line">ch := (e and f) xor ((not e) and g)</span><br><span class="line">t1 := h + s1 + ch + k[i] + w[i]</span><br><span class="line">h := g</span><br><span class="line">g := f</span><br><span class="line">f := e</span><br><span class="line">e := d + t1</span><br><span class="line">d := c</span><br><span class="line">c := b</span><br><span class="line">b := a</span><br><span class="line">a := t1 + t2</span><br></pre></td></tr></table></figure><p>迭代完成后的最后一组ABCDEFG即为该块数据的摘要。</p><p>接着进行下一块数据的迭代，重新初始化8个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">h0 := h0 + a</span><br><span class="line"></span><br><span class="line">h1 := h1 + b</span><br><span class="line"></span><br><span class="line">h2 := h2 + c</span><br><span class="line"></span><br><span class="line">h3 := h3 + d</span><br><span class="line"></span><br><span class="line">h4 := h4 + e</span><br><span class="line"></span><br><span class="line">h5 := h5 + f</span><br><span class="line"></span><br><span class="line">h6 := h6 + g</span><br><span class="line"></span><br><span class="line">h7 := h7 + h</span><br></pre></td></tr></table></figure><p>最终，当最后一块数据迭代完毕后，我们得到了原始数据的摘要：</p><p><code>digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</code></p><p>将原始数据编码为特定长度的字符串记入区块链</p><p>双SHA256哈希函数：</p><p>将任意长度的原始数据经过两次SHA256哈希运算后转为长度为256位的二进制数字。</p><p>SHA256算法的散列空间为2^256^ ，好的哈希函数具备的特点：单向性，定时性，定长性，随机性。</p></li></ul></li><li><p>验证一个区块头信息</p><ul><li>首先是<a href="https://webbtc.com/block/000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506" target="_blank" rel="noopener">真实区块信息</a></li><li>接着将数据处理成十六进制，注意时间戳要先转换为UTC时间戳（从1970年1月1日至此时的秒数），再转十六进制。</li><li>big-endian转为little-endian</li><li>拼接字符串</li><li>做两次SHA256</li></ul></li><li><p>二叉Merkle树–快速归纳和校验区块数据的存在和完整性</p><p>Merkle树是一种哈希树，其中每个叶子结点存放数据块的哈希值，而非叶结点存放其孩子结点数据的哈希值。如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/8c4c513bly1fxcnn8k8dmj20xc0l8wf7.jpg" alt=""></p><p>Merkel树逐层记录哈希值，底层数据有任何变动，都能传递到他的父结点，一层层传递到树根。根结点实际上记录了全部数据的数字指纹。</p><p>比特币采用Merkel实现SPV（简化支付验证）协议, 即在不运行完整区块链网络节点的情况下, 也能够对 (交易) 数据进行检验。例如, 为验证上图 中交易 L1, 一个没有下载完整区块链数据的客户端可以通过向其他节点索要包括从交易L1 哈希值沿 Merkle 树上溯至区块头根哈希处的哈希序列 (即哈希节点 0-1, 1,TOP) 来快速确认交易的存在性和正确性. </p><p>一般说来, 在 N个交易组成的区块体中确认任一交易的算法复杂度仅为 log~2~N.  </p></li><li><p>非对称加密–公私钥</p><p>发送者记为A，接受者记为B</p><p>信息加密：A使用B的公钥加密信息后发送给B，保证只有B能解密。</p><p>数字签名：A使用A的私钥加密信息后发送给B，B使用A的公钥解密，确保信息是由A发送的。</p><p>登录认证：客户端用私钥加密登录信息，服务器用客户端的公钥解密后进行验证。</p><p>比特币私钥：随机生成的256位随机数（私钥空间2^256^，对比IPV6 2^128^个地址，可以为世界上每粒沙子分配IP），再由<code>SHA256</code>和<code>Base58</code>转换为50个字符长度的便于书写的私钥提供给用户。</p><p>比特币公钥：由私钥经过<code>Secp256k1</code>椭圆曲线算法加密生成65字节长度的随机数。</p><p>比特币交易地址：由公钥进行<code>SHA256</code>和<code>RIPEMD160</code>两次哈希生成20字节长度的结果，再经过SHA256和Base58转换成33字符长度的比特币地址。</p></li></ul></li><li><p>网络层</p><p>在去中心化的区块链网络中，每一个节点都拥有同等的地位，当然也需要为整个网络尽同等的责任。</p><p>节点的任务主要是网络路由，验证区块数据，传播区块数据，发现新节点等。</p><p>1.寻找比特币网络中的有效节点，此步骤通常有两种方法：</p><ul><li><p>使用“DNS种子”（DNS seeds），DNS种子提供比特币节点的IP地址列表，Bitcoin Core客户端提供五种不同的DNS种子，通常默认使用即可</p></li><li><p>手动通过<code>-seednode</code>命令指定一个比特币节点的IP地址作为比特币种子节点</p></li></ul><p>2.与发现的有效比特币节点进行初始“握手”，建立连接</p><p>节点发送一条包含基本认证内容的<strong>version</strong>消息开始“握手”通信过程。</p><p>3.新节点建立更多的连接，使节点在网络中被更多节点接收，保证连接更稳定**</p><ul><li><p>发送一条包含自身IP地址的<strong>addr</strong>发送给已连接的节点，这些节点收到后将此转发给它们各自的连接节点，使网络中更多的节点接收到新节点</p></li><li><p>发送一条<strong>getaddr</strong>消息，要求已连接节点返回其已知的节点IP地址列表，通过这种方式，节点可以找到更多可连接的节点。</p></li><li><p>已建立连接的节点会定期发送信息维持连接，如果某个节点长达<strong>90分钟</strong>没有通信，会被认为已经断开，网络会开始寻找一个新的节点。</p></li><li><p>每个节点连接不超过<strong>1000个</strong>对等节点，超过数量的IP地址会被忽略，连接过多的节点浪费网络资源，没有必要。</p></li></ul><p>4.交换“区块清单”（注：该步骤仅在全节点上会执行，且从与节点建立连接就开始进行）</p><p>全节点在连接到其他节点后，需要构建完整的区块链，如果是新节点，它仅包含静态植入客户端中的0号区块（创世区块）。</p><ul><li><p>通过<strong>version消息中的BestHeight字段</strong>可知双方节点的区块高度，然后节点之间交换一个<strong>getblocks</strong>消息，其中包含本地区块链顶部区块的Hash，这样节点间就可以判断谁的链更长。</p></li><li><p>拥有更长链的节点识别出其他节点需要“补充”的区块后，开始分批发送区块（<strong>500个区块</strong>为一批），通过<strong>inv</strong>消息先将第一批的区块清单发送给对端节点（inv消息包含500个区块的Hash清单）。限制每次同步区块的数量，是为了减少新节点同步区块对网络造成的影响。</p></li><li><p>缺少区块的节点发送<strong>getdata</strong>消息向所有已连接的节点请求全区块数据，“正在传输”的区块数量不能超过客户端<strong>MAX_BLOCKS_IN_TRANSIT_PER_PEER</strong>参数设置的值。</p></li></ul></li><li><p>共识层</p><ul><li><p>PoW共识–分布式节点的算力竞争</p><p>解决一个求解复杂但验证容易的SHA256数学难题（所谓挖矿）。最快解决这一问题的节点获得区块记账权和系统生成的比特币奖励。</p><p>这样数学问题可表述为：根据当前目标值（难度值），通过搜索一个合适的随机数（Nonce）使得区块头元数据两次SHA256后的哈希值小于等于目标值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block_header = version + previous_block_hash + merkle_root + time + target_bits + nonce</span><br><span class="line">   <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">2</span>**<span class="number">32</span>):</span><br><span class="line">      <span class="keyword">if</span> sha256(sha256(block_header)) &lt; target_bits:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></li><li><p>计算难度的调整：</p><p>比特币系统定时调整目标值（难度值）以保证，每10分钟生成一个区块。</p><p>新目标值= 当前目标值 <em> 实际2016个区块出块时间 / 理论2016个区块产生时间(600s</em>2016=2周)。</p><p>链式结构和分叉</p><p>总是选择延长累计工作量证明最大的区块链和六次确认</p></li></ul></li><li><p>激励层</p><ul><li><p>奖励金</p><p>获得区块记账权的矿工，同时获得系统奖励的比特币，这一奖励信息也被打包在该区块的交易信息中。初始挖到每个区块奖励50BTC ，之后每21万个区块，奖励金减半，最总整个系统共生成2100万BTC 。目前是12.5BTC /块。</p></li><li><p>手续费</p><p>小额交易：小于0.01BTC 每笔支付0.0001BTC </p><p>千字节收费：当前每笔交易的手续费大部分是0.0001BTC  /KB（约3.8元/KB）,最初比特币区块限制1MB。    </p><p>非强制，但矿工在组建数据块时通常会优先考虑带有较高手续费的交易，以便在挖矿成功时能获得较高的报酬，因此无附带任何手续费的交易，可能会需要等待较长的时间才能被处理并纳入区块链中。</p><p>（satoshi，即比特币最小单位，0.000 000 01 BTC = 1 satoshi）</p></li></ul></li><li><p>合约层</p></li><li>应用层</li></ul><p>参考</p><p>《区块链技术发展现状与展望》袁勇 王飞跃</p><p>《區塊鍊(区块链)解密：: 构建基于信用的下一代互联网》   作者：黄步添， 蔡亮编</p><p>《<a href="https://blog.csdn.net/u011583927/article/details/80905740" target="_blank" rel="noopener">SHA256算法原理详解</a>》</p><p>《<a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html" target="_blank" rel="noopener">Merkel Tree学习</a>》</p><p>《<a href="https://www.zhihu.com/question/22075219/answer/301791689" target="_blank" rel="noopener">比特币的挖矿到底在计算什么？ - Tony的回答 - 知乎</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者 ：陈哲 西安邮电大学计算机学院研究生大佬一枚&lt;/p&gt;
&lt;p&gt;五个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们经常说区块链，那么区块究竟是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所谓挖矿是怎么回事？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比特币是什么？&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>什么是分布式文件系统？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是分布式文件系统？/</id>
    <published>2019-02-17T08:15:33.000Z</published>
    <updated>2019-02-22T08:17:22.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="维基百科上给出的定义"><a href="#维基百科上给出的定义" class="headerlink" title="维基百科上给出的定义"></a>维基百科上给出的定义</h1><p>相对于本机端的文件系统而言，分布式文件系统（英语：Distributed file system, DFS），或是网络文件系统（英语：Network File System），是一种允许文件透过网络在多台主机上分享的文件系统，可让多机器上的多用户分享文件和存储空间。<br>在这样的文件系统中，客户端并非直接访问底层的数据存储区块，而是透过网络，以特定的通信协议和服务器沟通。借由通信协议的设计，可以让客户端和服务端都能根据访问控制清单或是授权，来限制对于文件系统的访问。<br>相对地，在一个分享的磁盘文件系统中，所有节点对数据存储区块都有相同的访问权，在这样的系统中，访问权限就必须由客户端程序来控制。<br>分布式文件系统可能包含的功能有：透通的数据复制与容错。也就是说，即使系统中有一小部分的节点脱机，整体来说系统仍然可以持续运作而不会有数据损失。<br>分布式文件系统和分布式数据存储的界线是模糊的，但一般来说，分布式文件系统是被设计用在局域网[1]，比较强调的是传统文件系统概念的延伸，并透过软件方法来达成容错。而分布式数据存储，则是泛指应用分布式运算技术的文件和数据库等提供数据存储服务的系统。</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>一个普遍用来量测网络文件系统性能的方式是：它需要用多少时间来完成服务请求？在传统的系统中，完成请求所需要的时间包括了实际的硬盘访问时间，和一小部分的中央处理器处理时间。但在一个网络文件系统中，由于分布式架构的关系，远程访问动作会产生额外的经常性负担，包括：把请求从客户端送到服务端的时间、把回应从服务端传回客户端的时间、以及这两个传输过程中用来运行网络传输协议的中央处理处时间。一个网络文件系统的性能，可被视为是评估它透通性的一个维度，拿来与本地磁盘进行充分的对比。</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>著名的CAP定理指出：在一个分布式数据存储架构中，数据的一致性（Consistency）、可用性（Availability）、和网络分隔的容忍程度（Partition tolerance）只能取二来做最优化，无法三者兼具。当代的分布式数据存储服务均是各自针对服务的内容和性质来作取舍，很难说有哪一个是通用的最佳解。</p><h1 id="发展路线"><a href="#发展路线" class="headerlink" title="发展路线"></a>发展路线</h1><p>传统纸笔——&gt;磁盘磁带光盘——&gt;单机时代——&gt;独立文件服务器——&gt;存储服务器/设备——&gt;分布式文件系统——&gt;未来量子通信</p><h1 id="目前主流的分布式文件系统介绍"><a href="#目前主流的分布式文件系统介绍" class="headerlink" title="目前主流的分布式文件系统介绍"></a>目前主流的分布式文件系统介绍</h1><p>常见的分布式文件系统有，GFS、HDFS、Lustre 、Ceph 、GridFS 、mogileFS、TFS、FastDFS等。各自适用于不同的领域。它们都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p><h2 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google File System）"></a>GFS（Google File System）</h2><p>Google公司为了满足本公司需求而开发的基于Linux的专有分布式文件系统。。尽管Google公布了该系统的一些技术细节，但Google并没有将该系统的软件部分作为开源软件发布。<br>下面分布式文件系统都是类 GFS的产品。</p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>Hadoop 实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。 Hadoop是Apache Lucene创始人Doug Cutting开发的使用广泛的文本搜索库。它起源于Apache Nutch，后者是一个开源的网络搜索引擎，本身也是Luene项目的一部分。Aapche Hadoop架构是MapReduce算法的一种开源应用，是Google开创其帝国的重要基石。</p><h2 id="Ceph"><a href="#Ceph" class="headerlink" title="Ceph"></a>Ceph</h2><p>是加州大学圣克鲁兹分校的Sage weil攻读博士时开发的分布式文件系统。并使用Ceph完成了他的论文。<br>说 ceph 性能最高，C++编写的代码，支持Fuse，并且没有单点故障依赖， 于是下载安装， 由于 ceph 使用 btrfs 文件系统， 而btrfs 文件系统需要 Linux 2.6.34 以上的内核才支持。<br>可是ceph太不成熟了，它基于的btrfs本身就不成熟，它的官方网站上也明确指出不要把ceph用在生产环境中。</p><h2 id="Lustre"><a href="#Lustre" class="headerlink" title="Lustre"></a>Lustre</h2><p>Lustre是一个大规模的、安全可靠的，具备高可用性的集群文件系统，它是由SUN公司开发和维护的。<br>该项目主要的目的就是开发下一代的集群文件系统，可以支持超过10000个节点，数以PB的数据量存储系统。<br>目前Lustre已经运用在一些领域，例如HP SFS产品等。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">分布式文件系统</a></li><li><a href="http://ask.zol.com.cn/x/4673524.html" target="_blank" rel="noopener">当前主流分布式文件系统有哪些?各有什么优缺点</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;维基百科上给出的定义&quot;&gt;&lt;a href=&quot;#维基百科上给出的定义&quot; class=&quot;headerlink&quot; title=&quot;维基百科上给出的定义&quot;&gt;&lt;/a&gt;维基百科上给出的定义&lt;/h1&gt;&lt;p&gt;相对于本机端的文件系统而言，分布式文件系统（英语：Distributed f
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核是什么？</title>
    <link href="http://yoursite.com/Linux%E5%86%85%E6%A0%B8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/Linux内核是什么？/</id>
    <published>2019-02-10T12:03:33.000Z</published>
    <updated>2019-02-11T03:11:32.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux内核定义"><a href="#Linux内核定义" class="headerlink" title="Linux内核定义"></a>Linux内核定义</h1><p><img src="/assets/blogImg/微信图片_20190210200636.png" alt=""></p><h2 id="底层驱动"><a href="#底层驱动" class="headerlink" title="底层驱动"></a>底层驱动</h2><p>Linux内核[kernel]是整个操作系统的最底层，它负责整个硬件的驱动，以及提供各种系统所需的核心功能，包括防火墙机制、是否支持LVM或Quota等文件系统等等，如果内核不认识某个最新的硬件，那么硬件也就无法被驱动，你也就无法使用该硬件。</p><h2 id="芯片控制"><a href="#芯片控制" class="headerlink" title="芯片控制"></a>芯片控制</h2><p>计算机真正工作的东西其实是硬件，例如数值运算要使用到CPU、数据储存要使用到硬盘、图形显示会用到显示适配器、音乐发声要有音效芯片、连接Internet 可能需要网络卡等等。内核就是控制这些芯片如何工作。</p><h1 id="Linux操作系统的三层模型"><a href="#Linux操作系统的三层模型" class="headerlink" title="Linux操作系统的三层模型"></a>Linux操作系统的三层模型</h1><ul><li>最底层的硬件系统，包括CPU、内存、硬盘、网卡等；</li><li>硬件系统之上是内核，这是操作系统的核心，负责管理硬件系统，同时为上层的应用程序提供操作接口；</li><li>用户进程在这表示计算机中运行的所有程序，它们运行于用户空间，由内核统一管理； </li></ul><p><img src="/assets/blogImg/微信图片_20190210200802.png" alt=""></p><h1 id="Linux内核主的五个子系统"><a href="#Linux内核主的五个子系统" class="headerlink" title="Linux内核主的五个子系统"></a>Linux内核主的五个子系统</h1><ul><li>进程调度</li><li>内存管理</li><li>虚拟文件系统</li><li>网络接口</li><li>进程间通信</li></ul><p><img src="/assets/blogImg/微信图片_20190210201005.png" alt=""></p><p>进程调度位于中心位置，所有子系统都依赖于它，因为每个子系统都需要挂起和恢复进程。<br>一般情况下，当一个进程等待硬件操作完成时，它就被挂起；当操作完成时，进程就被恢复执行<br>例如：<br>当一个进程通过网络发送一条消息时，网络接口需要挂起发送进程，直到硬件成功地完成消息的发送，当消息被成功地发送出去后，网络接口给进程返回一个代码，表示操作成功或失败。其它子系统都是与此相似地依赖进程调度</p><h1 id="Linux组成"><a href="#Linux组成" class="headerlink" title="Linux组成"></a>Linux组成</h1><h2 id="kernel的功能"><a href="#kernel的功能" class="headerlink" title="kernel的功能"></a>kernel的功能</h2><ol><li>kernel提供的功能都通过系统调用给用户接口</li><li>kernel包括：进程管理 、内存管理 、网络管理 、驱动程序、安全管理 、文件系统<br><img src="/assets/blogImg/微信图片_20190210201548.png" alt=""></li></ol><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>函数功能模块集合，调用接口是二进制程序，要想运行，必须别其他程序调用，即其他程序面向硬件的一个中间层，有两种情形</p><ol><li>过程调用（procedure）无返回值</li><li>函数调用（function ）：有返回值</li></ol><h2 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h2><p>linux一切皆文件，除了一级文件外，其他文件需要挂载至根文件系统</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="开机过程"><a href="#开机过程" class="headerlink" title="开机过程"></a>开机过程</h3><p>开机 –&gt;内核运行 –&gt; 内核加载根文件系统 –&gt;运行根文件系统上的第一个应用程序init</p><p>init：它是负责后面的总的应用程序的启动回收等，启动可能需要向内核申请，这一切都在用户空间运行，如果init程序终止了，则用户空间的所有程序终止</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>让程序按照我们需要的方式一直运行下去</p><h1 id="Linux内核特点"><a href="#Linux内核特点" class="headerlink" title="Linux内核特点"></a>Linux内核特点</h1><p>结合了unix操作系统的一些基础概念</p><h2 id="支持模块化"><a href="#支持模块化" class="headerlink" title="支持模块化"></a>支持模块化</h2><ul><li><p>linux内核会将其各部分功能模块化，这使得在安装linux内核时，可以仅保持最基本的内核和功能，不过内核中模块数量会变多。linux内核中的.ko（kernel object）文件就是可以被内核调用的内核模块。</p></li><li><p>做以下假设：驱动是内核提供的，编译好一个内核之后，在装在主机上，在未来添加新的硬件设备没有新的驱动的话。是重新编译一次内核？这种设计是一件反人类的设计啊，因此引入了模块设计。</p></li><li><p>模块化设计得以避免这种情况，故各大厂商可以通过模块化的形式开发自己的驱动，只需针对某一特定设备开发自己驱动程序即可，在编译驱动模块。由于linux支持动态装载和卸载模块，因此当我需要和不需要某一功能时，可自行拆卸，此操作并不影响核心的正常运行。</p></li></ul><h1 id="Linux内核的任务"><a href="#Linux内核的任务" class="headerlink" title="Linux内核的任务"></a>Linux内核的任务</h1><ol><li>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</li><li>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</li><li>内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。</li><li>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/TommyMusk/article/details/80714364" target="_blank" rel="noopener">Linux内核简介</a></li><li><a href="https://www.cnblogs.com/zangfans/p/8646013.html" target="_blank" rel="noopener">linux内核管理</a></li><li>《深入理解linux内核》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux内核定义&quot;&gt;&lt;a href=&quot;#Linux内核定义&quot; class=&quot;headerlink&quot; title=&quot;Linux内核定义&quot;&gt;&lt;/a&gt;Linux内核定义&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogImg/微信图片_20190210200
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Rust语言的优势</title>
    <link href="http://yoursite.com/Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%8A%BF/"/>
    <id>http://yoursite.com/Rust语言的优势/</id>
    <published>2019-02-01T14:23:38.000Z</published>
    <updated>2019-02-01T14:51:37.354Z</updated>
    
    <content type="html"><![CDATA[<p>一门编程语言的开发追求的是快速、安全性、易于编写三个方面，但大多数的编程语言的现状只满足两个方面，安全性和简单的编程语言往往编译速度很慢，比如Python;编译快又满足安全性的却又很难学，比方说C与C++。那么有没有一门语言同时满足快速、安全、简单三个方面呢?</p><p>由Graydon Hoare开发、Mozilla Research赞助的Rust语言一直在致力于快速、安全、简单三方面的追求，虽然谷歌的Go语言近些月以来都被炒得很热，但Rust语言可以说也是新晋黑马的一员，Rust语言为何能与Go相媲美?它的优势在哪里?</p><h1 id="满足更高的速度需求"><a href="#满足更高的速度需求" class="headerlink" title="满足更高的速度需求"></a>满足更高的速度需求</h1><p>Rust代码可跨多个平台编译成本机代码，且二进制文件是自包含的，无需运行。生成的代码意味要执行与C或者C++编写的类似的代码。</p><h1 id="更加注重安全性"><a href="#更加注重安全性" class="headerlink" title="更加注重安全性"></a>更加注重安全性</h1><p>大多数内存错误都是在程序运行时才被发现，其他语言中常见的内存问题——空指针、野指针以及数据竞争等绝不会在Rust中产生。Rust编译器会将这些问题标记出来，在程序运行之前进行修复。</p><h1 id="无需内存管理"><a href="#无需内存管理" class="headerlink" title="无需内存管理"></a>无需内存管理</h1><p>Rust的记忆管理系统在语言语法中通过一个叫做所有权的隐喻进行了阐述语言中的任何给定值都可以被控制或者操纵，且一次只能由一个变量来控制。对象之间传输所有权受到编译器的严格控制，所以在运行时没有内存分配形式的错误。所有权也意味着Rust没有像GO或C#这样的垃圾回收的内存管理。 Rust程序中的所有内存都通过所有权自动跟踪和释放。</p><h1 id="使用简单"><a href="#使用简单" class="headerlink" title="使用简单"></a>使用简单</h1><p>Rust相对于C入门简单，这也是Rust受欢迎的重要原因之一。所有在Rust中生成的二进制文件都会放在一个包里;像GCC那样的外部编译器只有在编译Rust原生系统之外的其他组件(比如从源代码中编译C库)时才需要。Rust同样适用于Linux、MacOS以及Windows。</p><h1 id="其他优势"><a href="#其他优势" class="headerlink" title="其他优势"></a>其他优势</h1><ul><li>支持多架构、多平台</li></ul><p>　　支持三种操作系统，支持交叉编译以及跨架构、平台二进制文件的产生。</p><ul><li><p>强大的语言功能<br>　　Rust拥有 “宏”，泛型，模式匹配等，功能毫不逊色于C++。</p></li><li><p>标准库<br>　　拥有像C和C++的标准库，可使用容器、集合、迭代器等工具，执行字符串操作，管理进程和线程等。</p></li><li><p>IDE工具<br>Visual Studio等工具</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/liigo/article/details/45757123" target="_blank" rel="noopener">为什么我说Rust是靠谱的编程语言</a></li><li><a href="https://www.rust-lang.org" target="_blank" rel="noopener">Rust官网</a>    </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一门编程语言的开发追求的是快速、安全性、易于编写三个方面，但大多数的编程语言的现状只满足两个方面，安全性和简单的编程语言往往编译速度很慢，比如Python;编译快又满足安全性的却又很难学，比方说C与C++。那么有没有一门语言同时满足快速、安全、简单三个方面呢?&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://yoursite.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Docker与虚拟机、物理机的区别？</title>
    <link href="http://yoursite.com/Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/Docker与虚拟机、物理机的区别？/</id>
    <published>2019-01-31T15:22:44.000Z</published>
    <updated>2019-01-31T15:34:49.597Z</updated>
    
    <content type="html"><![CDATA[<p>初次接触Docker时，感觉它就像一种轻量级的虚拟机。Docker最初的成功秘诀是因为它比虚拟机更节省内存，启动更快。然而事实并非如此，Docker并非虚拟机，那么什么是Docker呢？它和虚拟机、物理机又有什么区别呢？</p><h1 id="极简类比"><a href="#极简类比" class="headerlink" title="极简类比"></a>极简类比</h1><h2 id="一、物理机是这样的"><a href="#一、物理机是这样的" class="headerlink" title="一、物理机是这样的"></a>一、物理机是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232444.png" alt=""></p><h2 id="二、虚拟机是这样的"><a href="#二、虚拟机是这样的" class="headerlink" title="二、虚拟机是这样的"></a>二、虚拟机是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232509.png" alt=""></p><h2 id="三、容器是这样的"><a href="#三、容器是这样的" class="headerlink" title="三、容器是这样的"></a>三、容器是这样的</h2><p>  <img src="/assets/blogImg/微信图片_20190131232529.png" alt=""></p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h1><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 </p><h2 id="集装箱比方"><a href="#集装箱比方" class="headerlink" title="集装箱比方"></a>集装箱比方</h2><p>集装箱解决了什么问题呢？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。<br>docker也是类似的理念。我们可以在一台机器上跑多个互相毫无关联的docker容器，每一个容器就相当于一个集装箱。</p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><h2 id="Docker里的几个基本概念"><a href="#Docker里的几个基本概念" class="headerlink" title="Docker里的几个基本概念"></a>Docker里的几个基本概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像可以理解为一堆静态的文件</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器则是镜像run起来之后的一个实例。镜像之于容器就好比面向对象编程里的class之于object。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>镜像需要地方保存，这个地方就是仓库<br>上层建立不同的容器，不同的应用镜像打包在不同的容器中，他们互相隔离。</p><h3 id="理解Docker容器"><a href="#理解Docker容器" class="headerlink" title="理解Docker容器"></a>理解Docker容器</h3><p>使用Docker容器运行多个相互隔离的应用时，如下图:</p><p><img src="/assets/blogImg/微信图片_20190131232714.png" alt=""></p><p>不难发现，相比于虚拟机，Docker要简洁很多。因为我们不需要运行一个臃肿的从操作系统了。<br>从下到上理解上图:</p><ul><li>基础设施(Infrastructure)。</li><li>主操作系统(Host Operating System)。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</li><li>Docker守护进程(Docker Daemon)。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。</li><li>各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</li><li>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li></ul><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>使用虚拟机运行多个相互隔离的应用时，如下图:<br>   <img src="/assets/blogImg/微信图片_20190131232908.png" alt=""></p><p>从下到上理解上图:</p><ul><li>基础设施(Infrastructure)。它可以是你的个人电脑，数据中心的服务器，或者是云主机。</li><li>主操作系统(Host Operating System)。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。</li><li>虚拟机管理系统(Hypervisor)。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。</li><li>从操作系统(Guest Operating System)。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。</li><li>各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。</li><li>应用。安装依赖之后，就可以在各个从操作系统分别运行应用了，这样各个应用就是相互隔离的。</li></ul><h1 id="对比虚拟机与Docker"><a href="#对比虚拟机与Docker" class="headerlink" title="对比虚拟机与Docker"></a>对比虚拟机与Docker</h1><p>docker设计小巧，部署迁移快速，运行高效，应用之间相互独立，管理人员可以看到所有容器的内容，虚拟化技术比较臃肿，不论什么应用都需要先创建新的系统，并且并非按照应用隔离，而是按照系统隔离，管理员无法看到系统内部信息。</p><p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。</p><h2 id="APP与某信"><a href="#APP与某信" class="headerlink" title="APP与某信"></a>APP与某信</h2><p>举个例子，Docker就是手机中的各种APP，只需要一个系统就可以下载自己所需的应用，但是虚拟化技术相当于你的苹果手机安装一个庞大软件，这个软件上安装安卓系统、魅族系统等，每个系统上还要安装各类应用，比较麻烦。</p><p>但两者没有绝对的好坏，主要还是看应用场景，根据不同的需求选择不同的解决方案即可。</p><h2 id="具体对比"><a href="#具体对比" class="headerlink" title="具体对比"></a>具体对比</h2><ol><li>docker启动快速属于秒级别，虚拟机通常需要几分钟去启动。</li><li>docker需要的资源更少，docker在操作系统级别进行虚拟化，docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。</li><li>docker更轻量，docker的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker运行的镜像数远多于虚拟机数量。对系统的利用率非常高</li><li>与虚拟机相比，docker隔离性更弱，docker属于进程之间的隔离，虚拟机可实现系统级别隔离；</li><li>安全性： docker的安全性也更弱。Docker的租户root和宿主机root等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</li><li>可管理性：docker的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如VMware vCenter提供完备的虚拟机管理能力。</li><li>高可用和可恢复性：docker对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制，VMware可承诺虚拟机99.999%高可用，保证业务连续性。</li><li>快速创建、删除：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.docker.org.cn/book/docker/what-is-docker-16.html" target="_blank" rel="noopener">docker中文社区</a></li><li><a href="https://diveintodocker.com/blog/comparing-virtual-machines-vs-docker-containers" target="_blank" rel="noopener">comparing-virtual-machines-vs-docker-containers</a></li><li><a href="https://www.zhihu.com/question/48174633" target="_blank" rel="noopener">docker容器与虚拟机有什么区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初次接触Docker时，感觉它就像一种轻量级的虚拟机。Docker最初的成功秘诀是因为它比虚拟机更节省内存，启动更快。然而事实并非如此，Docker并非虚拟机，那么什么是Docker呢？它和虚拟机、物理机又有什么区别呢？&lt;/p&gt;
&lt;h1 id=&quot;极简类比&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="云计算" scheme="http://yoursite.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>什么是“平均负载”(二)？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D(%E4%BA%8C)%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是“平均负载”(二)？/</id>
    <published>2019-01-30T12:23:21.000Z</published>
    <updated>2019-02-17T06:49:38.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平均负载与-CPU-使用率"><a href="#平均负载与-CPU-使用率" class="headerlink" title="平均负载与 CPU 使用率"></a>平均负载与 CPU 使用率</h1><p>现实工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，进行一个区分。</p><p>可能你也会有这样的疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，是不是也就意味着 CPU 使用率高？</p><p>我们来看看平均负载的含义，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><p>而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><h1 id="平均负载案例分析"><a href="#平均负载案例分析" class="headerlink" title="平均负载案例分析"></a>平均负载案例分析</h1><p>下面，我们以三个示例分别来看这三种情况，并用 iostat、mpstat、pidstat 等工具，找出平均负载升高的根源。</p><h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><p>下面的案例都是基于 Ubuntu 18.04，案例环境如下所示。</p><ul><li>机器配置：2 CPU，2GB 内存。</li><li>预先安装 stress 和 sysstat 包，如 apt install stress sysstat。</li></ul><p>首先介绍一下 stress 和 sysstat。</p><p>stress 是一个 Linux 系统压力测试工具，这里用作异常进程模拟平均负载升高的场景。而 sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的两个命令 mpstat 和 pidstat。</p><ul><li>mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</li><li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</li></ul><p>此外，每个场景都需要开三个终端，登录到同一台 Linux 机器中。</p><p>注意，下面的所有命令，默认以普通用户运行。所以，如果遇到权限不够时，一定要运行 sudo su root 命令切换到 root 用户。</p><p>如果上面的环境准备都已经完成了，先用 uptime 命令，看一下测试前的平均负载情况：</p><p><img src="/assets/blogImg/微信图片_20190130145049.png" alt=""></p><h1 id="场景一：CPU-密集型进程"><a href="#场景一：CPU-密集型进程" class="headerlink" title="场景一：CPU 密集型进程"></a>场景一：CPU 密集型进程</h1><p>首先，在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：</p><p><img src="/assets/blogImg/微信图片_20190130145322.png" alt=""></p><p>接着，在第二个终端运行 uptime 查看平均负载的变化情况：</p><pre><code># -d 参数表示高亮显示变化的区域$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130145357.png" alt=""></p><p>最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p><pre><code># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据$ mpstat -P ALL 5</code></pre><p><img src="/assets/blogImg/微信图片_20190130145455.png" alt=""></p><p>从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。<br>那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询：</p><pre><code># 间隔 5 秒后输出一组数据$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145553.png" alt=""></p><p>从这里可以明显看到，stress 进程的 CPU 使用率为 99.60%，接近100%。</p><h1 id="场景二：I-O-密集型进程"><a href="#场景二：I-O-密集型进程" class="headerlink" title="场景二：I/O 密集型进程"></a>场景二：I/O 密集型进程</h1><p>首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync：</p><pre><code>$ stress -i 1 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130145648.png" alt="">    </p><p><strong>注意：</strong></p><p>在虚拟机中<code>$ stress -i 1 --timeout 600</code>iowait无法升高，与理论不符？</p><p>iowait无法升高的问题，是因为物理机中stress使用的是 sync() 系统调用，它的作用是刷新缓冲区内存到磁盘中。对于虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了。所以，只会看到只有系统CPU使用率升高。解决方法是使用stress的下一代stress-ng，它支持更丰富的选项，比如 <code>stress-ng -i 1 --hdd 1 --timeout 600（--hdd表示读写临时文件）</code>。</p><pre><code>stress-ng -i 1 --hdd 1 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130145749.png" alt="">    </p><p>在第二个终端运行 uptime 查看平均负载的变化情况：</p><pre><code>$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130145820.png" alt="">    </p><p>然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况：</p><pre><code># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据$ mpstat -P ALL 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145900.png" alt="">    </p><p>从这里可以看到，1 分钟的平均负载会慢慢增加到 0.95，接近1，其中一个 CPU 的系统 CPU 使用率升高到了 6.16，而 iowait 高达 87.44%。这说明，平均负载的升高是由于 iowait 的升高。<br>那么到底是哪个进程，导致 iowait 这么高呢？使用 pidstat 来查询：</p><pre><code># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130145950.png" alt=""></p><p>可以发现，还是 stress 进程导致的。</p><h1 id="场景三：大量进程的场景"><a href="#场景三：大量进程的场景" class="headerlink" title="场景三：大量进程的场景"></a>场景三：大量进程的场景</h1><p>当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。<br>比如，我们还是使用 stress，但这次模拟的是 8 个进程：</p><pre><code>$ stress -c 8 --timeout 600</code></pre><p><img src="/assets/blogImg/微信图片_20190130150052.png" alt=""></p><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.76：</p><pre><code>$ uptime或者$ watch -d uptime</code></pre><p><img src="/assets/blogImg/微信图片_20190130150119.png" alt=""></p><p>接着再运行 pidstat 来看一下进程的情况：</p><pre><code># 间隔 5 秒后输出一组数据$ pidstat -u 5 1</code></pre><p><img src="/assets/blogImg/微信图片_20190130150159.png" alt=""></p><p>可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 76%左右。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p><h1 id="案例小结"><a href="#案例小结" class="headerlink" title="案例小结"></a>案例小结</h1><p>分析完这三个案例，归纳一下平均负载的理解。</p><p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，需要注意：</p><ul><li>平均负载高有可能是 CPU 密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li><li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li></ul><h1 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h1><h2 id="什么是平均负载"><a href="#什么是平均负载" class="headerlink" title="什么是平均负载"></a>什么是平均负载</h2><ul><li>正确定义：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。</li><li>错误定义：单位时间内的cpu使用率。</li><li>可运行状态的进程：正在使用cpu或者正在等待cpu的进程，即ps aux命令下STAT处于R状态的进程</li><li>不可中断状态的进程：处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令D状态的进程</li><li>理想状态：每个cpu上都有一个活跃进程，即平均负载数等于cpu数</li><li>过载经验值：平均负载高于cpu数量70%的时候</li></ul><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul><li>cpu核数: lscpu、 grep ‘model name’ /proc/cpuinfo | wc -l</li><li>显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势</li><li>watch -d uptime: -d会高亮显示变化的区域</li><li>strees: 压测命令，–cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，–timeout 执行时间</li><li>mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu</li><li>pidstat: 进程性能分析工具，-u 显示cpu利用率</li></ul><h2 id="平均负载与cpu使用率的区别"><a href="#平均负载与cpu使用率的区别" class="headerlink" title="平均负载与cpu使用率的区别"></a>平均负载与cpu使用率的区别</h2><p>CPU使用率：单位时间内cpu繁忙情况的统计</p><ol><li>情况1：CPU密集型进程，CPU使用率和平均负载基本一致</li><li>情况2：IO密集型进程，平均负载升高，CPU使用率不一定升高</li><li>情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高</li></ol><h2 id="平均负载过高时调优"><a href="#平均负载过高时调优" class="headerlink" title="平均负载过高时调优"></a>平均负载过高时调优</h2><p>工具：stress、sysstat</p><h3 id="CPU密集型进程case"><a href="#CPU密集型进程case" class="headerlink" title="CPU密集型进程case"></a>CPU密集型进程case</h3><ul><li>mpstat -P ALL 5：-P ALL表示监控所有CPU，5表示每5秒刷新一次数据，观察是否有某个cpu的%usr会很高，但iowait应很低</li><li>pidstat -u 5 1：每5秒输出一组数据，观察哪个进程%cpu很高，但是%wait很低，极有可能就是这个进程导致cpu飚高</li></ul><h3 id="IO密集型进程case"><a href="#IO密集型进程case" class="headerlink" title="IO密集型进程case"></a>IO密集型进程case</h3><ul><li>mpstat -P ALL 5：观察是否有某个cpu的%iowait很高，同时%usr也较高</li><li>pidstat -u 5 1：观察哪个进程%wait较高，同时%CPU也较高</li></ul><h3 id="大量进程case"><a href="#大量进程case" class="headerlink" title="大量进程case"></a>大量进程case</h3><ul><li>pidstat -u 5 1：观察那些%wait较高的进程是否有很多</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://time.geekbang.org/column/140" target="_blank" rel="noopener">Linux性能优化实战 倪朋飞</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;平均负载与-CPU-使用率&quot;&gt;&lt;a href=&quot;#平均负载与-CPU-使用率&quot; class=&quot;headerlink&quot; title=&quot;平均负载与 CPU 使用率&quot;&gt;&lt;/a&gt;平均负载与 CPU 使用率&lt;/h1&gt;&lt;p&gt;现实工作中，我们经常容易把平均负载和 CPU 使用率
      
    
    </summary>
    
    
      <category term="系统优化" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>什么是“平均负载”(一)？</title>
    <link href="http://yoursite.com/%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D(%E4%B8%80)%EF%BC%9F/"/>
    <id>http://yoursite.com/什么是“平均负载”(一)？/</id>
    <published>2019-01-29T11:24:27.000Z</published>
    <updated>2019-02-11T02:42:26.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看系统平均负载"><a href="#查看系统平均负载" class="headerlink" title="查看系统平均负载"></a>查看系统平均负载</h1><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><pre><code>ubuntu@localhost:~$ uptime 21:41:11 up 57 min,  1 user,  load average: 0.28, 0.09, 0.24</code></pre><p>命令输出的最后内容表示在过去的1、5、15分钟内运行队列中的平均进程数量。一般来说只要每个 CPU 的当前活动进程数不大于3那么系统的性能就是良好的，如果每个 CPU 的任务数大于5，那么就表示这台机器的性能有严重问题。通过</p><pre><code>ubuntu@localhost:~$ grep &apos;model name&apos; /proc/cpuinfo | wc -l1 </code></pre><p>可知该系统此时只有一个 CPU ，则表示其系统性能是良好的。</p><h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p><img src="/assets/blogImg/微信图片_20190129193440.png" alt=""></p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><img src="/assets/blogImg/微信图片_20190129193653.png" alt=""></p><h2 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h2><p><img src="/assets/blogImg/微信图片_20190129193745.png" alt=""> </p><h2 id="tload"><a href="#tload" class="headerlink" title="tload"></a>tload</h2><p><img src="/assets/blogImg/微信图片_20190129200544.png" alt=""> </p><h2 id="loadavg"><a href="#loadavg" class="headerlink" title="loadavg"></a>loadavg</h2><p>这些工具中的平均负载是从 /proc/loadavg 文件中读取的，也可以直接使用 cat 命令查看：</p><pre><code>ubuntu@localhost:~$ cat /proc/loadavg0.48 0.69 0.42 5/452 6570</code></pre><h1 id="“平均负载”是什么？"><a href="#“平均负载”是什么？" class="headerlink" title="“平均负载”是什么？"></a>“平均负载”是什么？</h1><p>当系统变慢时，我们做的第一件事就是在Linux系统终端中输入uptime、w、top、glances、tload等命令来了解系统的负载情况，这几个命令都会有系统平均负载load average的输出，那么系统平均负载是什么呢？</p><h2 id="运行队列中的平均进程数"><a href="#运行队列中的平均进程数" class="headerlink" title="运行队列中的平均进程数"></a>运行队列中的平均进程数</h2><p>Load Average是 CPU 的Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。</p><p>也就是说： </p><p>系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。<br>如果一个进程满足以下条件则其就会位于运行队列中：</p><ul><li>它没有在等待I/O操作的结果</li><li>它没有主动进入等待状态(也就是没有调用’wait’)</li><li>没有被停止(例如：等待终止)</li></ul><h2 id="平均活跃进程数"><a href="#平均活跃进程数" class="headerlink" title="平均活跃进程数"></a>平均活跃进程数</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 利用率并没有直接关系。这里先解释下，可运行状态和不可中断状态这俩词儿。</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p><h3 id="不可中断状态"><a href="#不可中断状态" class="headerlink" title="不可中断状态"></a>不可中断状态</h3><p>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p><p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。</p><p>所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p><p>因此，你可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。</p><h1 id="理解系统平均负载和-CPU-核心数的关系"><a href="#理解系统平均负载和-CPU-核心数的关系" class="headerlink" title="理解系统平均负载和 CPU 核心数的关系"></a>理解系统平均负载和 CPU 核心数的关系</h1><p>考虑了 CPU 核心数的影响，才能解释系统负载。</p><h2 id="多处理器-Vs-多核处理器"><a href="#多处理器-Vs-多核处理器" class="headerlink" title="多处理器 Vs 多核处理器"></a>多处理器 Vs 多核处理器</h2><ul><li>多处理器 – 一个计算机系统中集成两个或多个物理 CPU</li><li>多核处理器 – 单个物理 CPU 有两个或多个单独的核并行工作（也叫处理单元）。双核意味着有两个处理单元，4核有4个处理单元，以此类推。</li></ul><p>此外，Intel 引入了超线程技术用来提高并行计算能力。<br>通过超线程技术，在操作系统中，单个物理 CPU 表现的和两个逻辑 CPU 一样。（实际在硬件上只有一个 CPU）。</p><p>注意，单个 CPU 核同一时间只能执行一个任务，于是产生了多 CPU/处理器、多核 CPU，以及多线程技术。</p><p>多 CPU 时，多个程序可以同时执行。如今的 Intel CPU 使用了多核心和超线程技术。<br>可以使用 nproc 或 lscpu 命令查看系统中的处理器单元数量。</p><pre><code>ubuntu@localhost:~$ nproc4# 或者lscpu也可以使用 grep 命令：ubuntu@localhost:~$ grep &apos;model name&apos; /proc/cpuinfo | wc -l4</code></pre><p>为了进一步理解系统负载，需要做一些假设。假设系统负载如下：</p><pre><code>23:16:49 up  10:49,  5 user,  load average: 1.00, 0.40, 3.35</code></pre><h3 id="在单核系统中意味着："><a href="#在单核系统中意味着：" class="headerlink" title="在单核系统中意味着："></a>在单核系统中意味着：</h3><p>•    CPU 被充分利用（100%）；最近的 1 分钟有 1 个进程在运行。</p><p>•    CPU 有 60% 处于空闲状态；在最近的 5 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均过载了 235%；最近的 15 分钟平均有 2.35 个进程在等待 CPU 时间。</p><h3 id="在双核系统中意味着："><a href="#在双核系统中意味着：" class="headerlink" title="在双核系统中意味着："></a>在双核系统中意味着：</h3><p>•    有一个 CPU 处于完全空闲状态，另一个 CPU 被使用；最近的 1 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均 160% 处于空闲状态；最近的 5 分钟没有进程等待 CPU 时间。</p><p>•    CPU 平均过载了 135%；最近的 15 分钟有 1.35 个进程等待 CPU 时间。</p><h1 id="Load-average的算法"><a href="#Load-average的算法" class="headerlink" title="Load average的算法"></a>Load average的算法</h1><p>上面的输出数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以 CPU 的数目，结果高于5的时候就表明系统在超负荷运转了。其算法(摘自Linux 2.6 的内核代码)如下：</p><p><strong>文件: include/linux/sched.h:</strong></p><pre><code>#define FSHIFT        11        /* nr of bits of precision */#define FIXED_1        (1&lt;&lt;FSHIFT)    /* 1.0 as fixed-point */#define LOAD_FREQ    (5*HZ)        /* 5 sec intervals */#define EXP_1        1884        /* 1/exp(5sec/1min) as fixed-point */#define EXP_5        2014        /* 1/exp(5sec/5min) */#define EXP_15        2037        /* 1/exp(5sec/15min) */#define CALC_LOAD(load,exp,n) \    load *= exp; \    load += n*(FIXED_1-exp); \    load &gt;&gt;= FSHIFT;</code></pre><p><strong>文件: kernel/timer.c:</strong></p><pre><code>unsigned long avenrun[3];/* * calc_load - given tick count, update the avenrun load estimates. * This is called while holding a write_lock on xtime_lock. */static inline void calc_load(unsigned long ticks){    unsigned long active_tasks; /* fixed-point */    static int count = LOAD_FREQ;    count -= ticks;    if (count &lt; 0) {        count += LOAD_FREQ;        active_tasks = count_active_tasks();        CALC_LOAD(avenrun[0], EXP_1, active_tasks);        CALC_LOAD(avenrun[1], EXP_5, active_tasks);        CALC_LOAD(avenrun[2], EXP_15, active_tasks);    }}</code></pre><p><strong>文件: fs/proc/proc_misc.c:</strong></p><pre><code>#define LOAD_INT(x) ((x) &gt;&gt; FSHIFT)#define LOAD_FRAC(x) LOAD_INT(((x) &amp; (FIXED_1-1)) * 100)/* * Warning: stuff below (imported functions) assumes that its output will fit * into one page. For some of those functions it may be wrong. Moreover, we * have a way to deal with that gracefully. Right now I used straightforward * wrappers, but this needs further analysis wrt potential overflows. */extern int get_hardware_list(char *);extern int get_stram_list(char *);extern int get_chrdev_list(char *);extern int get_filesystem_list(char *);extern int get_exec_domain_list(char *);extern int get_dma_list(char *);extern int get_locks_status (char *, char **, off_t, int);static int proc_calc_metrics(char *page, char **start, off_t off,                 int count, int *eof, int len){    if (len &lt;= off+count) *eof = 1;    *start = page + off;    len -= off;    if (len&gt;count) len = count;    if (len&lt;0) len = 0;    return len;}static int loadavg_read_proc(char *page, char **start, off_t off,                 int count, int *eof, void *data){    int a, b, c;    int len;    a = avenrun[0] + (FIXED_1/200);    b = avenrun[1] + (FIXED_1/200);    c = avenrun[2] + (FIXED_1/200);    len = sprintf(page,&quot;%d.%02d %d.%02d %d.%02d %ld/%d %d\n&quot;,        LOAD_INT(a), LOAD_FRAC(a),        LOAD_INT(b), LOAD_FRAC(b),        LOAD_INT(c), LOAD_FRAC(c),        nr_running(), nr_threads, last_pid);    return proc_calc_metrics(page, start, off, count, eof, len);}</code></pre><h1 id="平均负载的意义"><a href="#平均负载的意义" class="headerlink" title="平均负载的意义"></a>平均负载的意义</h1><p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p><ul><li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li><li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li><li>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</li></ul><h1 id="平均负载为多少时合理"><a href="#平均负载为多少时合理" class="headerlink" title="平均负载为多少时合理"></a>平均负载为多少时合理</h1><p>回到前面的例子，不知道能否判断出，在那些命令的结果里，其中三个时间段的平均负载数，多大的时候能说明系统负载高？或是多小的时候就能说明系统负载很低呢？</p><p>我们知道，平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时，首先需要知道系统有几个 CPU，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取。有了 CPU 个数，我们就可以判断出，当平均负载比 CPU 个数还大的时候，系统已经出现了过载。</p><p>不过，新的问题又来了。在前面的例子中可以看到，平均负载有三个数值，到底该参考哪一个呢？<br>实际上，都要看。三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，可以更全面、更立体地理解目前的负载状况。</p><h2 id="平均负载的三个时间段"><a href="#平均负载的三个时间段" class="headerlink" title="平均负载的三个时间段"></a>平均负载的三个时间段</h2><p>打个比方，就像初秋时北京的天气，如果只看中午的温度，你可能以为还在 7 月份的大夏天呢。但如果你结合了早上、中午、晚上三个时间点的温度来看，基本就可以全方位了解这一天的天气情况了。<br>同样的，前面说到的 CPU 的三个负载时间段也是这个道理。</p><ul><li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li><li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li><li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。</li></ul><p>这里举个例子，假设在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。</p><h2 id="实际环境中的平均负载"><a href="#实际环境中的平均负载" class="headerlink" title="实际环境中的平均负载"></a>实际环境中的平均负载</h2><p>在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>一般情况，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p><p>但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，再去做分析和调查。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://time.geekbang.org/column/140" target="_blank" rel="noopener">Linux性能优化实战 倪朋飞</a> </li><li><a href="https://www.cnblogs.com/pangguoping/p/5589027.html" target="_blank" rel="noopener">什么是系统平均负载(Load average)</a></li><li><a href="https://linux.cn/article-8632-1.html" target="_blank" rel="noopener">理解 Linux 的平均负载和性能监控</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看系统平均负载&quot;&gt;&lt;a href=&quot;#查看系统平均负载&quot; class=&quot;headerlink&quot; title=&quot;查看系统平均负载&quot;&gt;&lt;/a&gt;查看系统平均负载&lt;/h1&gt;&lt;h2 id=&quot;uptime&quot;&gt;&lt;a href=&quot;#uptime&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="系统优化" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>任务安排</title>
    <link href="http://yoursite.com/%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/"/>
    <id>http://yoursite.com/任务安排/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2018-10-08T03:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境<br>PostgreSQL环境搭建:原理、安装</p><p>2018/7/16    熟悉数据库操作基本流程、数据操作命令、编程接口<br>PostgreSQL语法学习：操作教程、命令语法、编程接口</p><p>2018/7/23    研究HTML界面开发框架数据库操作以及相关开发语言<br>前端学习：Electron开源库+blur-admin响应式模板学习、安装、介绍、接口</p><p>2018/7/30    分析应用场景（场景1：日志分析）数据操作以及数据展示要求，设计数据库表、字段，设计服务程序，创造数据，写入数据库<br>表格创建：应用场景</p><p>2018/8/6    应用场景1：日志分析 中展示要求1，2 界面框架数据库查询接口<br>PostgreSQL连接接口（一）：实现</p><p>2018/8/13    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版以及查询接口”<br>自测功能（一）：</p><p>2018/8/20    应用场景1：日志分析 中展示要求3 界面框架数据库查询接口<br>PostgreSQL接口封装（二）：封装</p><p>2018/8/27    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版、更新查询接口”<br>自测功能（二）：</p><p>2018/9/3    配合HTML界面调试<br>全栈调试（一）：</p><p>2018/9/10    配合HTML界面调试<br>全栈调试（二）：</p><p>2018/9/17    测试、优化<br>测试优化（一）：</p><p>2018/9/24    测试、优化<br>测试优化（二）：</p><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><h2 id="一周：9-10-表格设计与查询显示"><a href="#一周：9-10-表格设计与查询显示" class="headerlink" title="一周：9.10  表格设计与查询显示"></a>一周：9.10  表格设计与查询显示</h2><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><ol><li>从数据表server中获取所有服务器并显示</li><li>可筛选查看</li></ol><h3 id="日志查询"><a href="#日志查询" class="headerlink" title="日志查询"></a>日志查询</h3><ol><li>通过条件从warning中查询日志并显示</li><li>多条件查询，时间、消息类型、电厂名称等</li></ol><h2 id="一周：9-17-实时警告模块设计与实现"><a href="#一周：9-17-实时警告模块设计与实现" class="headerlink" title="一周：9.17 实时警告模块设计与实现"></a>一周：9.17 实时警告模块设计与实现</h2><h3 id="实时告警"><a href="#实时告警" class="headerlink" title="实时告警"></a>实时告警</h3><ol><li>实时（通过定时器）从数据表warning中获取最新的日志显示</li><li>可选择要显示的日志类型、可清空、对日志可以操作状态（已解决、未解决）</li><li>根据重要性统计以饼状图显示（紧急、重要、一般）、并以线性图显示趋势（近一周、近一月、近一年）</li><li>上面显示图表，下面以列表显示日志</li></ol><h2 id="二周：10-1"><a href="#二周：10-1" class="headerlink" title="二周：10.1"></a>二周：10.1</h2><h3 id="系统运行统计图"><a href="#系统运行统计图" class="headerlink" title="系统运行统计图"></a>系统运行统计图</h3><p>9.24<br>柱状图设计与显示：</p><ol><li>按消息类型统计，以柱状图显示</li><li>按操作类型统计，以柱状图显示</li></ol><p>10.1<br>饼状图显示与统计：</p><ol><li>按电厂属性统计，以饼状图显示</li><li>在线统计</li><li>按告警级别统计，以饼状图统计</li></ol><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>10.8  MariaDB数据库学习</p><p>10.15 BLurAdmin界面设计</p><p>系统时间、</p><p>10.22 </p><h1 id="内核基础"><a href="#内核基础" class="headerlink" title="内核基础"></a>内核基础</h1><p>4月初-7月初</p><p>Linux基本操作</p><p>Linux C编程基础：</p><pre><code>工具：gcc、gdb</code></pre><p>c primer plus 源码</p><p>c++ primer plus 原理、实验、心得</p><p>Unix实践编程</p><h1 id="内核代码阅读"><a href="#内核代码阅读" class="headerlink" title="内核代码阅读"></a>内核代码阅读</h1><ol><li><p>多版本源码注释</p></li><li><p>新旧版本知识点对比-&gt;内核演化</p></li></ol><p>09-12</p><p>Linux内核模块编程入门</p><p>list.h</p><p>分页</p><p>进程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;p&gt;2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境&lt;br&gt;PostgreSQL环境搭建:原理、安装&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="安排" scheme="http://yoursite.com/tags/%E5%AE%89%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>IPFS相关操作</title>
    <link href="http://yoursite.com/IPFS%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/IPFS相关操作/</id>
    <published>2018-12-06T04:13:29.000Z</published>
    <updated>2019-03-06T04:13:40.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ipfs私有网络搭建-（5个节点）"><a href="#Ipfs私有网络搭建-（5个节点）" class="headerlink" title="Ipfs私有网络搭建 （5个节点）"></a><strong>Ipfs私有网络搭建 （5个节点）</strong></h1><p><strong>参考 ：</strong>     <a href="https://blog.csdn.net/oscube/article/details/80598790" target="_blank" rel="noopener">https://blog.csdn.net/oscube/article/details/80598790</a><br><strong>添加peer : </strong>ipfs swarm connect<br>ipfs bootstrap add /ip4/10.0.1.85/tcp/4001/ipfs/QmZY1MsysE6SyyQUuE1WvkEZEPy5Wg1Z5M7qWyMKGk5EBQ<br><strong>命令：       ipfs daemon &amp;  </strong><br>    <strong>ipfs swarm peers</strong></p><h1 id="ipfs-cluster集群搭建"><a href="#ipfs-cluster集群搭建" class="headerlink" title="ipfs-cluster集群搭建"></a><strong>ipfs-cluster集群搭建</strong></h1><p>ipfs-cluster-service daemon &amp;<br>ipfs-cluster-service daemon –bootstrap /ip4/10.0.1.85/tcp/9096/ipfs/QmfGrUNtGWBQk36gBMJ3tTW41wGdi6h5BCTCd3hAT8GKEA<br><strong>参考：</strong><br><a href="https://www.cnblogs.com/sumingk/articles/9434253.html" target="_blank" rel="noopener">https://www.cnblogs.com/sumingk/articles/9434253.html</a></p><h1 id="Ipfs-cluster-数据同步（1主4从）"><a href="#Ipfs-cluster-数据同步（1主4从）" class="headerlink" title="Ipfs-cluster 数据同步（1主4从）"></a><strong>Ipfs-cluster 数据同步（1主4从）</strong></h1><p><strong>ipfs-cluster 命令：</strong></p><p>1、统一上传文件<br>ipfs-cluster-ctl add &lt;文件名&gt;<br>该命令可统一上传文件，并且自动在其他节点进行pin命令。</p><p>2、统一pin文件<br>ipfs-cluster-ctl pin add</p><p>3、统一删除文件<br>ipfs-cluster-ctl pin rm<br>但需要在其他节点上手动进行ipfs repo gc</p><p>4、查看通过ipfs-cluster-ctl上传过的文件<br>ipfs-cluster-ctl pin ls</p><p>5、查看cluster集群中联通了哪些节点<br>ipfs-cluster-ctl peers ls<br>6、从集群中删除某一节点<br>ipfs-cluster-ctl peers rm &lt;节点id（短hash）&gt;</p><p>7、可查看集群中文件的同步状态，此命令在某一节点删除文件后有延迟，延迟时间尚不确定<br><strong>ipfs-cluster-ctl status</strong></p><p>8、跟踪集群中文件的同步状态，与上面命令不一样，只会显示同步出现异常的文件，并且可以刷新ipfs-cluster-ctl status的执行结果<br>     ipfs-cluster-ctl sync<br>9、查看集群节点关系图     ipfs-cluster-ctl health graph<br>参考：<br><a href="https://blog.csdn.net/weixin_40741642/article/details/82788072" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40741642/article/details/82788072</a></p><h1 id="医疗数据私有网络分布式存储"><a href="#医疗数据私有网络分布式存储" class="headerlink" title="医疗数据私有网络分布式存储"></a><strong>医疗数据私有网络分布式存储</strong></h1><p>ipfs-cluster-ctl add medical_data/ -r</p><p>added QmZRuAwu5A6feuBBSbyvgeBuukygTjVhQA715KHrAR7D5s medical_data/ECG/MIT/101.xws<br>added Qmc7K6A4FLwm8tLnMg49Eo2W8NYc2iiptkpifx6ZcEvMsh medical_data/ECG/MIT/102.atr<br>……<br>added QmUPouSiTr8cE6hCnzZYUpYgeyPArFwNf8NKdca6iSa7xh medical_data</p><h1 id="api实现文件存取"><a href="#api实现文件存取" class="headerlink" title="api实现文件存取"></a><strong>api实现文件存取</strong></h1><p>js版：client-api实现数据上传，未完善<br>go版：简单了解</p><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a><strong>服务器配置</strong></h1><p>关闭firewall：<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br>firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ipfs私有网络搭建-（5个节点）&quot;&gt;&lt;a href=&quot;#Ipfs私有网络搭建-（5个节点）&quot; class=&quot;headerlink&quot; title=&quot;Ipfs私有网络搭建 （5个节点）&quot;&gt;&lt;/a&gt;&lt;strong&gt;Ipfs私有网络搭建 （5个节点）&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="IPFS" scheme="http://yoursite.com/tags/IPFS/"/>
    
  </entry>
  
</feed>
