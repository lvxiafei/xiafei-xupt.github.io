<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiafei-xupt&#39;s blog</title>
  
  <subtitle>汝之意志所向,即吾剑之所指</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-08T02:16:50.907Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiafei-xupt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/08/FAQ/"/>
    <id>http://yoursite.com/2018/08/08/FAQ/</id>
    <published>2018-08-08T01:08:30.672Z</published>
    <updated>2018-08-08T02:16:50.907Z</updated>
    
    <content type="html"><![CDATA[<p>Q1:浏览器报Uncaught ReferenceError: require is not defined<br>A1:这个时候你需要看下你是不是在浏览器中运行node.js的模块了.不要把node.js和js搞混了,两个的运行环境是不相同.所以,你再浏览器环境下使用node.js的方法显示的not defined.<br>Q2:Ajax　　<br>A2:服务端渲染随着单页面应用以及Restful接口的兴起，Ajax逐渐成为目前前后端交流最为频繁的方式。</p><p>　　Ajax的核心是XmlHttpRequest。我们通过对该对象的操作来进行异步的数据请求。</p><p>　　实际上我们接触到最多jQuey就有很好的封装，比如$.ajax，$.post等，如果用Angular的话我们可以用$http服务，</p><p>　　除了这些之外，我们可以使用第三方的Ajax库qwest等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Q1:浏览器报Uncaught ReferenceError: require is not defined&lt;br&gt;A1:这个时候你需要看下你是不是在浏览器中运行node.js的模块了.不要把node.js和js搞混了,两个的运行环境是不相同.所以,你再浏览器环境下使用no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/03/%E7%AE%80%E5%8D%95%E7%9A%84linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/03/简单的linux设备驱动程序/</id>
    <published>2018-08-03T00:42:53.333Z</published>
    <updated>2018-08-03T00:42:53.363Z</updated>
    
    <content type="html"><![CDATA[<p>简单的linux设备驱动程序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的linux设备驱动程序&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/03/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/08/03/日志分析及数据库表的设计/</id>
    <published>2018-08-03T00:22:58.314Z</published>
    <updated>2018-08-04T00:54:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志分析及数据库表的设计"><a href="#日志分析及数据库表的设计" class="headerlink" title="日志分析及数据库表的设计"></a>日志分析及数据库表的设计</h1><h3 id="2018年7月30日-2018年8月6日"><a href="#2018年7月30日-2018年8月6日" class="headerlink" title="2018年7月30日~2018年8月6日"></a>2018年7月30日~2018年8月6日</h3><h2 id="标签：-PostgreSQL"><a href="#标签：-PostgreSQL" class="headerlink" title="标签： PostgreSQL  "></a>标签： PostgreSQL  </h2><p>赵岩、吕夏飞——2018-08-02——项目周报告——日志分析及数据库表的设计</p><h1 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h1><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>大量日志情况下，写程序（服务形式），定期不断产生日志消息，写入数据库。消息内容至少包括有主机分组、主机id、日志时间、日志类型、日志等级、日志消息。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>在大量的电脑日志情况下，HTML应用对日志进行条件查询、分析、产生各类型报表。数据库设计要依照数据参考和数据展示来进行设计。</p><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><ol><li>在产生大量日志数据的情况下需要项数据库中写入这些数据，而要写入的数据不止日志消息。要知道是哪台计算机产生的日志消息，需要主机的id和主机的分组，而产生的日志包括日志的类型、日志等级、和日志的消息内容，还有日志产生的时间。</li><li>在测试阶段，需要把日志的信息写入数据库即有一个数据库表的插入操作，此操作只需要在后台实现，利用postgreSQL数据库桌面工具写入测试数据。还有一个数据查询操作，此操作需要在HTML界面进行展示，将查询的数据通过整合，按照一定的要求进行展示。</li></ol><h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p>数据库可以实现数据共享、减少数据的冗余度、提高数据的独立性、使得数据实现集中控制、增加数据一致性和可维护性、有利于数据的故障恢复。</p><h2 id="PostgreSQL基础"><a href="#PostgreSQL基础" class="headerlink" title="PostgreSQL基础"></a>PostgreSQL基础</h2><ul><li>PostgreSQL是一个功能强大的开源对象关系数据库系统，它使用并扩展了SQL语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。</li><li>PostgreSQL的起源可以追溯到1986年，作为加州大学伯克利分校POSTGRES项目的一部分，并在核心平台上进行了30多年的积极开发。</li><li>PostgreSQL凭借其经过验证的架构，可靠性，数据完整性，强大的功能集，可扩展性以及软件背后的开源社区的奉献精神赢得了良好的声誉，以始终如一地提供高性能和创新的解决方案。</li><li>PostgreSQL在所有主要操作系统上运行，自2001年以来一直是符合ACID标准的，并且具有强大的附加功能，例如流行的PostGIS地理空间数据库扩展器。毫无疑问，PostgreSQL已经成为许多人和组织的首选开源关系数据库。</li></ul><h2 id="数据库视图"><a href="#数据库视图" class="headerlink" title="数据库视图"></a>数据库视图</h2><h3 id="视图的概述"><a href="#视图的概述" class="headerlink" title="视图的概述"></a>视图的概述</h3><p>视图是从一个或者多个表中导出的，它的行为与表非常相似，但视图是一个虚拟表。在视图中，用户可以使用SELECT语句查询语句，以及使用INSERT、UPDATE、和DELETE语句修改记录。在PostgreSQL中，使用视图可以使用户操作方便，而且可以保障数据库系统的安全。<br>我们通过视图看到的数据只是存放在基本表中的数据。当对通过视图看到的数据进行修改时，相应的基本表的数据也要发生变化，同时，若基本表的数据发生变化，则这种变化也可以自动地反映到视图中。</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>与直接从数据库表中读取数据相比，视图具有以下优点：</p><ol><li>简单化<br>看到的就是需要的。视图不仅可以简单化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li><li>安全性<br>通过视图，用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见、也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特殊的行和特殊的列上。通过视图，用户可以被限制在数据的不同子集上，如下：<br>● 使用权限可被限制在基表的行的子集上。<br>● 使用权限可被限制在基表的列的子集上。<br>● 使用权限可被限制在基表的行和列的子集上。<br>● 使用权限可被限制在多个基表的连接所限定的行上。<br>● 使用权限可被限制在基表中的数据的统计汇总上。<br>● 使用权限可被限制在另一视图的一个子集上，或是一些视图和基表合并后的子集上。</li><li>逻辑数据独立性<br>视图可以帮助用户屏蔽真实表结构变化带来的影响。</li></ol><h1 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h1><h2 id="数据库表的设计"><a href="#数据库表的设计" class="headerlink" title="数据库表的设计"></a>数据库表的设计</h2><p>根据提供的数据进行分析，由于现阶段只是前期的测试阶段，所采用的数据不是最终的数据，只是项目测试需要的数据，而且日志又分了等级和类型，主机也有自己的分组，我就考虑将主机分组、日志类型和日志等级分别建表，便于以后的修改，于是乎就一共有四张表产生。<br>分别为：日志表、类型表、等级表和主机分组表（红色下划线表示主键，蓝色下划线表示外键）</p><ol><li>类型表（<font color="#DC143C">日志类型</font>、类型名称）</li><li>等级表（<font color="#DC143C">日志等级</font>、等级名称）</li><li>主机分组表（<font color="#DC143C">主机分组</font>、分组名称）</li><li>日志表（<font color="#DC143C">主机id</font>、<font color="#0000FF">日志类型</font>、<font color="#0000FF">日志等级</font>、日志时间、日志消息、<font color="#0000FF">主机分组</font>）</li></ol><h2 id="字段类型设计"><a href="#字段类型设计" class="headerlink" title="字段类型设计"></a>字段类型设计</h2><p>其中各个表的字段大多对应的是计算机产生的数据，大多数应为字符串，字段的对应的类型再次设置为 character varying ，这个类型为可变长的字符串型，日志时间设置为date类型。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>Debian 9系统</li><li>PostgreSQL</li></ul><p><strong>注：</strong>由于PostgreSQL操作使用pgAdmin实现，而Windows 10系统使用pgAdmin 4，Debian 9系统使用pgAdmin3，两者几乎完全一样，故此处只在Windows 10系统上进行测试</p><h1 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h1><h2 id="类型表的创建语句"><a href="#类型表的创建语句" class="headerlink" title="类型表的创建语句"></a>类型表的创建语句</h2><pre><code>CREATE TABLE public.&quot;Class&quot;(&quot;日志类型&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;类型名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,CONSTRAINT &quot;Class_pkey&quot; PRIMARY KEY (&quot;日志类型&quot;))WITH (OIDS = FALSE)TABLESPACE pg_default;ALTER TABLE public.&quot;Class&quot;OWNER to postgres;</code></pre><p><img src="/assets/blogImg/微信图片_20180803133913.png" alt=""></p><h2 id="等级表的创建语句"><a href="#等级表的创建语句" class="headerlink" title="等级表的创建语句"></a>等级表的创建语句</h2><pre><code>CREATE TABLE public.&quot;Grade&quot;(&quot;日志等级&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;等级名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,CONSTRAINT &quot;Grade_pkey&quot; PRIMARY KEY (&quot;日志等级&quot;))WITH (OIDS = FALSE)TABLESPACE pg_default;ALTER TABLE public.&quot;Grade&quot;OWNER to postgres;</code></pre><p><img src="/assets/blogImg/微信图片_20180803134026.png" alt=""></p><h2 id="主机分组表的创建语句"><a href="#主机分组表的创建语句" class="headerlink" title="主机分组表的创建语句"></a>主机分组表的创建语句</h2><pre><code>CREATE TABLE public.&quot;Group&quot;(&quot;主机分组&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;分组名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,CONSTRAINT &quot;Group_pkey&quot; PRIMARY KEY (&quot;主机分组&quot;))WITH (OIDS = FALSE)TABLESPACE pg_default;ALTER TABLE public.&quot;Group&quot;OWNER to postgres;</code></pre><p><img src="/assets/blogImg/微信图片_20180803134304.png" alt=""></p><h2 id="日志表创建语句"><a href="#日志表创建语句" class="headerlink" title="日志表创建语句"></a>日志表创建语句</h2><pre><code>CREATE TABLE public.&quot;Mess&quot;(&quot;主机id&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;日志类型&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;日志等级&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;日志时间&quot; date NOT NULL,&quot;日志消息&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,&quot;主机分组&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL,CONSTRAINT &quot;Mess_pkey&quot; PRIMARY KEY (&quot;主机id&quot;),CONSTRAINT &quot;CFkey&quot; FOREIGN KEY (&quot;日志类型&quot;)REFERENCES public.&quot;Class&quot; (&quot;日志类型&quot;) MATCH FULLON UPDATE NO ACTIONON DELETE NO ACTIONDEFERRABLE INITIALLY DEFERREDNOT VALID,CONSTRAINT &quot;Fkey&quot; FOREIGN KEY (&quot;主机分组&quot;)REFERENCES public.&quot;Group&quot; (&quot;主机分组&quot;) MATCH FULLON UPDATE NO ACTIONON DELETE NO ACTIONDEFERRABLE INITIALLY DEFERREDNOT VALID,CONSTRAINT &quot;GFkey&quot; FOREIGN KEY (&quot;日志等级&quot;)REFERENCES public.&quot;Grade&quot; (&quot;日志等级&quot;) MATCH FULLON UPDATE NO ACTIONON DELETE NO ACTIONDEFERRABLE INITIALLY DEFERREDNOT VALID)WITH (OIDS = FALSE)TABLESPACE pg_default;ALTER TABLE public.&quot;Mess&quot;OWNER to postgres;</code></pre><p><img src="/assets/blogImg/微信图片_20180803134358.png" alt=""></p><h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><p>首先先确定日志类型、日志等级和主机分组的信息</p><h2 id="类型表"><a href="#类型表" class="headerlink" title="类型表"></a>类型表</h2><pre><code>INSERT INTO public.&quot;Class&quot;(    &quot;日志类型&quot;, &quot;类型名称&quot;)    VALUES (&apos;C01&apos;, &apos;A&apos;),(&apos;C02&apos;,&apos;B&apos;),(&apos;C03&apos;,&apos;C&apos;),(&apos;C04&apos;,&apos;D&apos;);</code></pre><p><img src="/assets/blogImg/微信图片_20180803134510.png" alt=""> </p><h2 id="等级表"><a href="#等级表" class="headerlink" title="等级表"></a>等级表</h2><pre><code>INSERT INTO public.&quot;Grade&quot;(    &quot;日志等级&quot;, &quot;等级名称&quot;)    VALUES (&apos;G01&apos;, &apos;A级&apos;),(&apos;G02&apos;,&apos;B级&apos;),(&apos;G03&apos;,&apos;C级&apos;),(&apos;G04&apos;,&apos;D级&apos;);</code></pre><p><img src="/assets/blogImg/微信图片_20180803134621.png" alt=""> </p><h2 id="主机分组表"><a href="#主机分组表" class="headerlink" title="主机分组表"></a>主机分组表</h2><pre><code>INSERT INTO public.&quot;Group&quot;(    &quot;主机分组&quot;, &quot;分组名称&quot;)    VALUES (&apos;F01&apos;, &apos;A组&apos;),(&apos;F02&apos;,&apos;B组&apos;),(&apos;F03&apos;,&apos;C组&apos;),(&apos;F04&apos;,&apos;D组&apos;);</code></pre><p><img src="/assets/blogImg/微信图片_20180803134651.png" alt=""> </p><h2 id="日志表"><a href="#日志表" class="headerlink" title="日志表"></a>日志表</h2><pre><code>INSERT INTO public.&quot;Mess&quot;(    &quot;主机id&quot;, &quot;日志类型&quot;, &quot;日志等级&quot;, &quot;日志时间&quot;, &quot;日志消息&quot;, &quot;主机分组&quot;)    VALUES(&apos;00000001&apos;,&apos;C01&apos;,&apos;G01&apos;,&apos;2018-03-14&apos;,&apos;asjdgahsfhdsvbjhdsvbcxnvvbjdfvbdsfjvbdsfbds&apos;, &apos;F01&apos;),    (&apos;00000002&apos;,&apos;C02&apos;,&apos;G03&apos;,&apos;2018-03-14&apos;,&apos;asjdgahsfhdsvbjhdsvbcx215641462273412424&apos;,&apos;F04&apos;),    (&apos;00000003&apos;,&apos;C04&apos;,&apos;G02&apos;,&apos;2018-03-21&apos;,&apos;12jdgahsfhdsvbjhdsvbcx215641462273412424&apos;,&apos;F03&apos;),    (&apos;00000004&apos;,&apos;C03&apos;,&apos;G02&apos;,&apos;2018-03-26&apos;,&apos;12jdgahsfhd123456dsvbcx215641462273412424&apos;,&apos;F04&apos;),    (&apos;00000005&apos;,&apos;C01&apos;,&apos;G04&apos;,&apos;2018-03-26&apos;,&apos;12jdgahsfhd123456dsvbcx215641462273412424&apos;,&apos;F02&apos;);</code></pre><p><img src="/assets/blogImg/微信图片_20180803134726.png" alt=""> </p><h1 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h1><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>info_log视图的创建语句</p><pre><code>CREATE OR REPLACE VIEW public.info_log ASSELECT &quot;Mess&quot;.&quot;主机id&quot;,&quot;Group&quot;.&quot;分组名称&quot;,&quot;Class&quot;.&quot;类型名称&quot;,&quot;Grade&quot;.&quot;等级名称&quot;,&quot;Mess&quot;.&quot;日志时间&quot;,&quot;Mess&quot;.&quot;日志消息&quot;     FROM &quot;Mess&quot;,&quot;Group&quot;,&quot;Grade&quot;,&quot;Class&quot;     WHERE &quot;Mess&quot;.&quot;主机分组&quot;::text = &quot;Group&quot;.&quot;主机分组&quot;::text AND &quot;Mess&quot;.&quot;日志类型&quot;::text = &quot;Class&quot;.&quot;日志类型&quot;::text AND &quot;Mess&quot;.&quot;日志等级&quot;::text = &quot;Grade&quot;.&quot;日志等级&quot;::text;ALTER TABLE public.info_logOWNER TO postgres;</code></pre><p><img src="/assets/blogImg/微信图片_20180803134844.png" alt=""> </p><h2 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h2><p>通过视图进行所有日志信息的查询</p><pre><code>SELECT &quot;主机id&quot;, &quot;分组名称&quot;, &quot;类型名称&quot;, &quot;等级名称&quot;, &quot;日志时间&quot;, &quot;日志消息&quot;    FROM public.info_log;</code></pre><p><img src="/assets/blogImg/微信图片_20180803135039.png" alt=""></p><h1 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h1><ul><li>通过数据库表的设计和创建，加深了对数据库的理解，掌握了数据库基本操作技能</li><li>主键和外键的设置可以帮助我们理清各个表之间的关系，最后通过视图操作将其在一张表上显示，清晰明了</li><li>通过对视图的操作即可实现对各个表数据的操作，提升了操作效率</li><li>视图操作使得数据库其它表的修改变得方便、安全，通过视图，用户只能查询和修改他们所能见到的数据。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.postgresql.org/docs/10/static/index.html" target="_blank" rel="noopener">PostgreSQL文档</a></li><li><a href="https://www.jb51.net/books/479286.html" target="_blank" rel="noopener">PostgreSQL 9从零开始学</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志分析及数据库表的设计&quot;&gt;&lt;a href=&quot;#日志分析及数据库表的设计&quot; class=&quot;headerlink&quot; title=&quot;日志分析及数据库表的设计&quot;&gt;&lt;/a&gt;日志分析及数据库表的设计&lt;/h1&gt;&lt;h3 id=&quot;2018年7月30日-2018年8月6日&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/31/proc%E7%9B%AE%E5%BD%95%E4%B8%8B%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/"/>
    <id>http://yoursite.com/2018/07/31/proc目录下信息提取/</id>
    <published>2018-07-31T06:53:46.044Z</published>
    <updated>2018-08-02T00:48:14.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-proc目录下信息提取"><a href="#Linux-proc目录下信息提取" class="headerlink" title="Linux /proc目录下信息提取"></a>Linux /proc目录下信息提取</h1><h3 id="2018-6-25-2018-7-1"><a href="#2018-6-25-2018-7-1" class="headerlink" title="2018-6-25~2018-7-1"></a>2018-6-25~2018-7-1</h3><h2 id="标签：-Linux"><a href="#标签：-Linux" class="headerlink" title="标签： Linux"></a>标签： Linux</h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>了解proc文件系统即/proc目录，获取该目录下内核运行状态的一系列系统状态信息，并将其以文档形式导出。</p><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><p>可以更加及时、准确地获得系统状态信息，以便后续对其进行分析、评估、预测、态势感知等。</p><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="proc文件系统简介"><a href="#proc文件系统简介" class="headerlink" title="proc文件系统简介"></a>proc文件系统简介</h2><p>proc的全称为process data system   ，proc文件系统是一种无存储的文件系统，当读其中的文件时，其内容动态生成，当写文件时，文件所关联的写函数被调用。每个proc文件都关联的字节特定的读写函数，因而它提供了另外的一种和内核通信的机制：内核部件可以通过该文件系统向用户空间提供接口来提供查询信息、修改软件行为，因而它是一种比较重要的特殊文件系统。</p><p>Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。<br>proc文件系统属于虚拟文件系统，即该文件系统的数据，由内核动态生成，并不会存放在持久存储数据中。<br>“即时”产生文件信息，换句话说，只有发出读操作请求时，才会产生信息。<br>它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>proc文件系统，使得内核可以生成与系统状态和配置有关的信息。该信息可以由用户和系统程序从普通文件读取，而无需专门的工具与内核通信。<br>从内核开发趋势来看，正在远离用proc文件系统提供的信息，而倾向于采用特定与问题的虚拟文件系统来导出数据。一个很好的例子就是USB文件系统，将与USB子系统有关的许多状态信息导出到用户空间，而没有给proc增加新的负担。但这并不意味这，proc文件系统变的多余，当今，/proc依旧重要，不仅在安装新的发布版时，而且也用于支持（自动化的）系统管理。</p><p> procfs 是进程文件系统(file system) 的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 /proc 目录。由于 /proc 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。</p><h2 id="proc目录中的常见文件介绍"><a href="#proc目录中的常见文件介绍" class="headerlink" title="proc目录中的常见文件介绍"></a>proc目录中的常见文件介绍</h2><p>静态生成：静态生成、动态变化<br>动态生成：动态变化</p><h3 id="proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。"><a href="#proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。" class="headerlink" title="/proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。"></a>/proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。</h3><p>/proc/[pid]</p><p>/proc/[pid]/attr</p><p>/ proc / [pid] / attr / current<br> 该文件的内容代表当前的安全性过程的属性。</p><p>/ proc / [pid] / attr / exec（自Linux 2.6.0开始该文件表示要分配给进程的属性</p><p>/ proc / [pid] / attr / fscreate（自Linux 2.6.0开始）该文件表示要分配给创建的文件的属性</p><p>/ proc / [pid] / attr / keycreate（自Linux 2.6.18开始） 如果一个进程将安全上下文写入这个文件，全部随后创建的键（add_key（2））将被标记这个背景。</p><p>/proc/cpu/info<br>cat /proc/cpuinfo</p><p>/ proc / [pid] / stat<br>              有关进程的状态信息。这由ps（1）使用。<br>              它在内核源文件fs / proc / array.c中定义。</p><pre><code>这些字段按顺序带有适当的scanf（3）格式speci-以下列出。是否某些这些字段显示有效信息由ptrace管理访问模式PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT 检查（参考ptrace（2））。如果支票拒绝访问，那么字段值显示为0.受影响的字段为用标记[PT]表示。（1）pid   ％d          进程ID。（2）通讯   ％s          可执行文件的文件名，括号中。          无论可执行文件是否可见，这都是可见的          换出。（3）状态   ％c          指示过程的以下字符之一          州：          R运行          S睡在可中断的等待中          D正在等待不间断磁盘睡眠          Z Zombie          T停止（在信号上）或（在Linux 2.6.33之前）             追踪停止          t跟踪停止（Linux 2.6.33以上）          W Paging（仅在Linux 2.6.0之前）          X Dead（从Linux 2.6.0开始）          x Dead（仅Linux 2.6.33至3.13）          K Wakekill（仅适用于Linux 2.6.33至3.13）          W醒来（仅适用于Linux 2.6.33至3.13）          P停放（仅适用于Linux 3.9至3.13）（4）ppid   ％d          此进程的父进程的PID。（5）pgrp   ％d          进程的进程组ID。（6）会话   ％d          进程的会话ID。（7）tty_nr   ％d          过程的控制终端。（未成年人          设备编号包含在组合中          位31至20和7至0; 主要的设备编号是          在位15至8中）（8）tpgid   ％d          con的前台进程组的ID          流程的终端。（9）标志   ％u          内核标记进程的单词。对于位平均 -           请参阅Linux内核中的PF_ *定义          源文件include / linux / sched.h。细节取决于          在内核版本上。          此字段的格式为Linux 2.6之前的％lu。（10）minflt   ％lu          过程所做的轻微故障的数量          不需要从中加载内存页面          磁盘。（11）cminflt   ％lu          该进程的小错误数量          等待的孩子们已经做出了决定。（12）majflt   ％lu          过程所造成的重大故障的数量          这需要从磁盘加载一个内存页面。（13）cmajflt   ％lu          该进程的主要故障数量          等待的孩子们已经做出了决定。（14）utime   ％lu          此进程已计划的时间量          在用户模式下，以时钟滴答度量（除以          sysconf（_SC_CLK_TCK））。这包括访客时间，           guest_time（运行虚拟CPU所花费的时间，请参阅          下面），以便不知道的应用程序          来宾时间字段不会从那时失去          他们的计算。（15）stime   ％lu          此进程已计划的时间量          在内核模式下，以时钟滴答度量（除以          sysconf（_SC_CLK_TCK））。（16）cutime   ％ld          这个进程等待的时间量，          dren已经安排在用户模式下，以英寸计量          时钟滴答（除以sysconf（_SC_CLK_TCK））。（看到          也包括时间（2））。这包括访客时间，           cguest_time（运行虚拟CPU所用的时间，请参阅          下面）。（17）cstime   ％ld          这个进程等待的时间量，          dren已经在内核模式下进行了安排，          时钟滴答（除以sysconf（_SC_CLK_TCK））。（18）优先级   ％ld          （针对Linux 2.6的解释）对于正在运行的进程          实时调度策略（以下策略 ;请参见           sched_setscheduler（2）），这是否定的schedul-          优先级，减1; 那就是一个数字          范围-2到-100，对应于实时优先级 -           关系1到99.对于在non-          实时调度策略，这是非常好的          值（setpriority（2）），如内核中所示。          内核在数据中存储很好的值          范围0（高）到39（低），对应于          用户可见的-20至19的好范围。          在Linux 2.6之前，这是基于的一个缩放值          调度程序给予这个过程的权重。（19）nice   ％ld          好的值（请参阅setpriority（2）），这是一个值          范围19（低优先级）至-20（高优先级）。（20）num_threads   ％ld          此过程中的线程数（自Linux 2.6开始）。          在内核2.6之前，这个字段被硬编码为0          先前移除的字段的占位符。（21）itrealvalue   ％ld          在下一个SIGALRM之前jiffies的时间发送          归因于间隔计时器的过程。由于ker-          nel 2.6.17，这个字段不再维护，并且          被硬编码为0。（22）starttime   ％llu          系统启动后进程启动的时间。在          Linux 2.6之前的内核，表达了这个值          在jiffies。从Linux 2.6开始，数值被表达出来          在时钟周期中（除以sysconf（_SC_CLK_TCK））。          此字段的格式为Linux 2.6之前的％lu。（23）vs   ％lu          虚拟内存大小（字节）。（24）rss   ％ld          驻留集大小：进程拥有的页数          在真实的记忆中。这只是计数的页面          朝向文本，数据或堆栈空间。这不是          包括未被请求加载的页面，          或哪些被换出。（25）rsslim   ％lu          当前在软件rss上的软限制          处理; 看到的描述RLIMIT_RSS在           getrlimit（2） 。（26）startcode   ％lu [PT]          程序文本可以运行的地址。（27）endcode   ％lu [PT]          程序文本可以运行的地址。（28）startstack   ％lu [PT]          开始的地址（即底部）          叠加。（29）kstkesp   ％lu [PT]          发现ESP（堆栈指针）的当前值          在进程的内核堆栈页面中。（30）kstkeip   ％lu [PT]          当前的EIP（指令指针）。（31）信号   ％lu          未决信号的位图显示为deci-          mal号码。已过时，因为它不提供          有关实时信号的信息; 使用          / proc / [pid] / status。（32）阻止   ％lu          被阻塞信号的位图显示为一个deci-          mal号码。已过时，因为它不提供          有关实时信号的信息; 使用          / proc / [pid] / status。（33）sigignore   ％lu          忽略信号的位图，显示为一个deci-          mal号码。已过时，因为它不提供          有关实时信号的信息; 使用          / proc / [pid] / status。（34）sigcatch   ％lu          捕获信号的位图，以小数形式显示          数。已过时，因为它不提供          有关实时信号的信息; 使用          / proc / [pid] / status。（35）wchan   ％lu [PT]          这是进程等待的“通道”          ING。它是内核中某个位置的地址          进程在睡觉的地方。相应的          符号名称可以在/ proc / [pid] / wchan中找到。（36）nswap   ％lu          交换页数（不保留）。（37）cnswap   ％lu子进程的          累积nswap（不是main-          tained）。（38）exit_signal   ％d（自Linux 2.1.22开始）          当我们死亡时，信号被发送给父母。（39）处理器   ％d（自Linux 2.2.8开始）          上次执行的CPU号码。（40）rt_priority   ％U（因为Linux 2.5.19）          实时调度优先级，范围内的一个数字          1到99用于实时调度的进程          策略或0，用于非实时进程（请参阅          sched_setscheduler（2））。（41）策略   ％u（自Linux 2.5.19开始）          调度策略（请参阅sched_setscheduler（2））。          使用linux / sched.h中的SCHED_ *常量进行解码。          这个字段的格式是Linux之前的％lu          2.6.22。（42）delayacct_blkio_ticks   ％llu（自Linux 2.6.18开始）          累计块I / O延迟，以时钟滴答度量          （厘秒）。（43）guest_time   ％lu（自Linux 2.6.24起）          过程的访客时间（运行vir-          用于客户操作系统的双CPU），以英寸计算          时钟滴答（除以sysconf（_SC_CLK_TCK））。（44）cguest_time   ％ld（自Linux 2.6.24起）          该过程的孩子的访客时间，以英寸计          时钟滴答（除以sysconf（_SC_CLK_TCK））。（45）start_data   ％lu（自Linux 3.3起）[PT]          程序初始化和unini-          tialized（BSS）数据被放置。（46）end_data   ％lu（自Linux 3.3起）[PT]          地址在哪个程序初始化和unini-          tialized（BSS）数据被放置。（47）start_brk   ％lu（自Linux 3.3起）[PT]          程序堆的地址可以扩展          与brk（2）。（48）arg_start   ％lu（自Linux 3.5起）[PT]          程序命令行参数上面的地址          （argv）被放置。（49）arg_end   ％lu（自Linux 3.5起）[PT]          程序命令行参数（argv）下的地址          摆放在。（50）env_start   ％lu（自Linux 3.5起）[PT]          在上面放置程序环境的地址。（51）env_end   ％lu（自Linux 3.5起）[PT]          地址在哪个程序环境下放置。（52）exit_code   ％d（自Linux 3.5起）[PT]          线程的退出状态以表格形式报告          waitpid（2）。              </code></pre><p>/ proc / [pid] / status<br>              提供/ proc / [pid] / stat和<br>               / proc / [pid] / statm中的大部分信息，<br>              解析。这是一个例子：</p><pre><code>    $ cat / proc / $$ / status    Name:   bash    Umask:  0022    State:  S (sleeping    Tgid：17248    Ngid：0    Pid：17248    PPid：17200    TracerPid：0    Uid：1000 1000 1000 1000    Gid：100 100 100 100    FDSize：256    Groups：16 33 100    NStgid：17248    NSpid：17248    NSpgid：17248    NSsid：17200    VmPeak：131168 kB    VmSize：131168 kB    VmLck：0 kB    VmPin：0 kB    VmHWM：13484 kB    VmRSS：13484 kB    RssAnon：10264 kB    RssFile：3220 kB    RssShmem：0 kB    VmData：10332 kB    VmStk：136 kB    VmExe：992 kB    VmLib：2104 kB    VmPTE：76 kB    VmPMD：12 kB    VmSwap：0 kB    HugetlbPages：0 kB＃4.4    Threads：1    SigQ:   0/3067    SigPnd: 0000000000000000    ShdPnd: 0000000000000000    SigBlk: 0000000000010000    SigIgn: 0000000000384004    SigCgt: 000000004b813efb    CapInh: 0000000000000000    CapPrm: 0000000000000000    CapEff: 0000000000000000    CapBnd: ffffffffffffffff    CapAmb:   0000000000000000    NoNewPrivs：0    Seccomp：0    Cpus_allowed：00000001    Cpus_allowed_list：0    Mems_allowed：1    Mems_allowed_list：0    volunte_ctxt_switches：150    nonvoluntary_ctxt_switches：545这些字段如下所示：* 名称：由此进程运行的命令。* Umask：处理umask，用八进制表示一个领先的  零; 见umask（2）。（从Linux 4.7开始）。* 状态：进程的当前状态。其中一个“R（跑步）”，  “S（睡眠）”，“D（磁盘睡眠）”，“T（停止）”，“T（追踪  停止）“，”Z（僵尸）“或”X（死亡）“。* Tgid：线程组ID（即进程ID）。* Ngid：NUMA组ID（如果没有，则为0;自Linux 3.13以来）。* Pid：线程ID（请参阅gettid（2））。* PPid：父进程的PID。* TracerPid：进程跟踪此进程的PID（如果不是，则为0）  被追踪）。* Uid，Gid：真实，有效，保存的设置和文件系统UID  （GID的）。* FDSize：当前分配的文件描述符插槽的数量。* 团体：补充小组名单。* NStgid：每个PID中的线程组ID（即PID）  其中[pid]是其成员的名称空间。最左边的条目  显示相对于PID命名空间的值  读取过程，接着是值  嵌套的内部命名空间。（从Linux 4.1开始）* NSpid：每个PID名称空间中的线程ID，其中   [pid]是其成员。这些字段按照NStgid排序。  （从Linux 4.1开始）* NSpgid：在每个PID名称空间中处理组ID  哪个[pid]是成员。这些字段按照Nst-   gid排序。（从Linux 4.1开始）* NSsid：后代命名空间会话ID层次结构会话ID  在其中[pid]是其成员的每个PID名称空间中。  这些字段按照NStgid排序。（从Linux 4.1开始）* VmPeak：峰值虚拟内存大小。* VmSize：虚拟内存大小。* VmLck：锁定内存大小（请参阅mlock（3））。* VmPin：固定的内存大小（自Linux 3.2以来）。这些是  因某些需要而无法移动的页面  直接访问物理内存。* VmHWM：高峰居民组大小（“高水位”）。* VmRSS：居民组大小。请注意，这里的值是  总和RssAnon，RssFile和RssShmem。* RssAnon：驻留匿名内存的大小。（自Linux以来  4.5）。* RssFile：常驻文件映射的大小。（自Linux 4.5以来）。* RssShmem：驻留共享内存的大小（包括System V  共享内存，来自tmpfs（5）的映射和共享匿名  映射）。（自Linux 4.5以来）。* VmData，VmStk，VmExe：数据，堆栈和文本的大小seg-  发言：。* VmLib：共享库代码大小。* VmPTE：页表条目大小（自Linux 2.6.10起）。* VmPMD：第二级页面表的大小（自Linux 4.0开始）。* VmSwap：由匿名私人交换虚拟内存大小  页; 不包括shmem交换使用（因为Linux  2.6.34）。* HugetlbPages：hugetlb内存部分的大小。（自Linux以来  4.4）。* 线程数：包含这个的进程中的线程数  线。* SigQ：该字段包含两个以斜线分隔的数字  与排队信号有关的真实用户ID  处理。其中第一个是当前的数量  排队的信号为这个真实的用户ID，第二个是  对此的排队信号数量的资源限制  处理（参照的描述RLIMIT_SIGPENDING在   getrlimit（2） ）。* SigPnd，ShdPnd：线程和for的待处理信号的数量  作为一个整体（见pthreads（7）和signal（7））。* SigBlk，SigIgn，SigCgt：指示信号的掩码  被阻止，被忽略并被捕获（见信号（7））。* CapInh，CapPrm，CapEff：启用的功能掩码  可继承的，允许的和有效的集合（参见  能力（7））。* CapBnd：Capability Bounding集合（自Linux 2.6.26起，参见   能力（7））。* CapAmb：环境能力集（自Linux 4.3起，参见   能力（7））。* NoNewPrivs：no_new_privs位的值（自Linux 4.10开始，  参见prctl（2））。* Seccomp：进程的Seccomp模式（自Linux 3.8起，请参阅   seccomp（2））。0表示SECCOMP_MODE_DISABLED ; 1表示SEC-   COMP_MODE_STRICT ; 2表示SECCOMP_MODE_FILTER。这个领域  仅当内核是在启用CON-   FIG_SECCOMP内核配置选项的情况下生成的。* Cpus_allowed：可以运行此进程的CPU的掩码  （从Linux 2.6.24开始，请参阅cpuset（7））。* Cpus_allowed_list：与之前相同，但是以“列表格式”  （从Linux 2.6.26开始，请参阅cpuset（7））。* Mems_allowed：此进程允许的内存节点掩码  （从Linux 2.6.24开始，请参阅cpuset（7））。* Mems_allowed_list：与之前相同，但是以“列表格式”  （从Linux 2.6.26开始，请参阅cpuset（7））。* voluntary_ctxt_switches，nonvoluntary_ctxt_switches：号码  自愿和非自愿的上下文切换（自Linux以来  2.6.23）。</code></pre><p>1<br>10<br>1009<br>103<br>104<br>106<br>107<br>108<br>11<br>111<br>113<br>1134<br>12<br>129<br>13<br>1315<br>1323<br>1328<br>1333<br>1354<br>1359<br>1364<br>1366<br>137<br>1393<br>14<br>1401<br>1403<br>1407<br>1414<br>1436<br>1451<br>1455<br>1459<br>1463<br>1476<br>1485<br>1489<br>1494<br>1499<br>15<br>1521<br>1561<br>1572<br>1584<br>1588<br>1590<br>16<br>1602<br>1603<br>1605<br>1611<br>1622<br>1623<br>1626<br>1635<br>1650<br>1664<br>17<br>1725<br>18<br>185<br>186<br>19<br>2<br>2079<br>208<br>2090<br>21<br>218<br>22<br>2234<br>23<br>2367<br>237<br>24<br>25<br>26<br>27<br>28<br>298<br>3<br>3535<br>3873<br>3884<br>40<br>41<br>410<br>424<br>426<br>427<br>433<br>447<br>5<br>500<br>501<br>502<br>504<br>505<br>5099<br>5100<br>5102<br>5158<br>5160<br>548<br>5508<br>5509<br>5510<br>5512<br>5562<br>564<br>5705<br>5708<br>5714<br>5905<br>6018<br>6041<br>6050<br>611<br>617<br>628<br>635<br>693<br>695<br>7<br>723<br>731<br>735<br>74<br>75<br>76<br>8<br>9<br>915<br>936<br>968<br>980<br>997</p><p>/proc/acpi<br>；</p><p>/proc/asound</p><p>/proc/buddyinfo<br>用于诊断内存碎片问题的相关信息文件；</p><p>/proc/bus</p><p>/cgroups</p><p>/proc/cmdline<br>在启动时传递至内核的相关参数信息，这些信息通常由lilo或grub等启动管理工具进行传递；<br>/proc/consoles</p><p>/proc/cpuinfo<br>处理器的相关信息的文件；</p><p>/proc/crypto</p><p>/proc/devices</p><p>/proc/diskstats</p><p>/proc/dma</p><p>/proc/driver<br>driver<br>execdomains<br>fb<br>filesystems<br>fs<br>interrupts<br>iomem<br>ioports<br>irq<br>kallsyms<br>kcore<br>keys<br>key-users<br>kmsg<br>kpagecgroup<br>kpagecount<br>kpageflags<br>loadavg<br>locks<br>meminfo<br>misc<br>modules<br>mounts<br>mpt<br>mtrr<br>net<br>pagetypeinfo<br>partitions<br>sched_debug<br>schedstat<br>self<br>slabinfo<br>softirqs<br>stat<br>swaps<br>sys<br>sysrq-trigger<br>sysvipc<br>thread-self<br>timer_list<br>tty<br>uptime<br>version<br>vmallocinfo<br>vmstat<br>zoneinfo<br>…</p><h2 id="proc的数据结构"><a href="#proc的数据结构" class="headerlink" title="proc的数据结构"></a>proc的数据结构</h2><p>与Ext2一样，proc大量使用了VFS数据结构，因为作为一种文件系统，它必须集成到内核的VFS抽象层中。但，毕竟proc只是用于获取内核的数据为主要目的，所以在其设计的过程中，遵循简单实用的特性，较Ext2简单。</p><h2 id="proc文件系统API"><a href="#proc文件系统API" class="headerlink" title="proc文件系统API"></a>proc文件系统API</h2><p>内核为创建proc文件提供了一套API，相关API如下：</p><p>struct proc_dir_entry <em>proc_mkdir(const char </em>name, struct proc_dir_entry *parent);</p><p>该函数用于在proc文件系统中创建一个目录项，大多数时候，当我们期望实现自己的proc文件时，都要先创建一个自己的目录，然后在该目录里创建自己的文件，当然我们也可以直接在已经存在的proc文件系统目录里创建自己的文件。<br>该函数的各个参数含义如下：<br>name：该目录的名字<br>parent：该目录的父目录的名字<br>void proc_remove(struct proc_dir_entry <em>de);<br>该函数用于删除一个目录。<br>struct proc_dir_entry </em>proc_create(const char <em>name, umode_t mode, struct proc_dir_entry </em>parent, const struct file_operations <em>proc_fops);<br>该函数用于在proc文件系统中创建一个proc文件，其参数含义如下：<br>name：proc文件的名字，表现在proc文件系统中，就是文件的名字<br>mode：proc文件的访问模式，表现在proc文件系统中，就是文件的访问模式<br>parent：该proc文件所在的目录<br>proc_fops：指向用于操作该文件的文件操作的指针<br>这些参数提供了一个文件所需要的关键信息，包括文件名，访问模式，目录项（用于指定文件在文件系统中的位置），以及文件操作指针。<br>当要删除一个文件时，需要使用API：<br>void remove_proc_entry(const char </em>name, struct proc_dir_entry *parent)；<br>参数的含义是显然的，该函数用于从proc文件系统的指定目录删除指定的proc文件。还有一些其它的API，都定义在include/linux/prof_fs.h中。<br>在proc文件系统中创建文件或者目录时，最终都会调到proc_register，该函数会为新创建的文件或目录指定正确的file_operations和inode_operations，它们将在访问文件时被使用。</p><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><h2 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h2><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><p>/proc目录下所有文件按目录形式复制出来，再进行选择性地提取有效信息。</p><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><p>手动导出</p><h2 id="方案C"><a href="#方案C" class="headerlink" title="方案C"></a>方案C</h2><p>使用shell脚本直接提取目的信息，按合适格式导出到文档中。</p><h2 id="方案D"><a href="#方案D" class="headerlink" title="方案D"></a>方案D</h2><p>通过内核模块获取目的信息，按合适格式导出到文档中。 </p><h2 id="方案E"><a href="#方案E" class="headerlink" title="方案E"></a>方案E</h2><p>代码直接调用mysql API,</p><h2 id="方案F"><a href="#方案F" class="headerlink" title="方案F"></a>方案F</h2><p>Node.js 直接调用系统API接口</p><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h2 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h2><h3 id="方案A-1"><a href="#方案A-1" class="headerlink" title="方案A"></a>方案A</h3><p>df -a   显示为0<br>ls -lh /proc/kcore<br>du -hs /proc/kcore<br>ls /proc/kcore -lh<br>hexdump（或od）<br>-r——– 1 root root 128T Jun 30 12:50 /proc/kcore</p><p>/proc是伪文件系统，内核想报告多大就多大。又不用分配出来<br>不可行。</p><h3 id="方案B-1"><a href="#方案B-1" class="headerlink" title="方案B"></a>方案B</h3><p>暂时先提取十条进程的信息<br>/proc/17256/stat</p><p>1725 (gvfsd-metadata) S 693 1725 1725 0 -1 4194304 746 0 174 0 10 20 0 0 20 0 3 0 8235 198119424 479 18446744073709551615 94113580531712 94113580601292 140721845185440 0 0 0 0 4096 0 0 0 0 17 0 0 0 238 0 0 94113582698760 94113582702612 94113598459904 140721845193626 140721845193655 140721845193655 140721845194715 0<br>即：</p><p>安装linux-header</p><p>apt-get install -y linux-headers-$(uname -r)</p><p>dmesg -C</p><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><h2 id="文章分析"><a href="#文章分析" class="headerlink" title="文章分析"></a>文章分析</h2><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">Linux Programmer’s Manual  PROC(5)</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul><h1 id="Markdown用法"><a href="#Markdown用法" class="headerlink" title="Markdown用法"></a>Markdown用法</h1><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$，<br> 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p><h1 id="0x05-参考资料"><a href="#0x05-参考资料" class="headerlink" title="0x05-参考资料"></a>0x05-参考资料</h1><p>Linux下Proc文件系统的编程剖析_郭松<br><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2010&amp;filename=HQDB201005010&amp;uid=WEEvREcwSlJHSldRa1FhcTdWajFtZk1DY3hvZmUvYk10TGtFRmcwaDkyTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjA1NzN5RGxVN3pJTFR6UGJMRzRIOUhNcW85RVpJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTEtmWWVSb0Y=" target="_blank" rel="noopener">http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2010&amp;filename=HQDB201005010&amp;uid=WEEvREcwSlJHSldRa1FhcTdWajFtZk1DY3hvZmUvYk10TGtFRmcwaDkyTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjA1NzN5RGxVN3pJTFR6UGJMRzRIOUhNcW85RVpJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTEtmWWVSb0Y=</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-proc目录下信息提取&quot;&gt;&lt;a href=&quot;#Linux-proc目录下信息提取&quot; class=&quot;headerlink&quot; title=&quot;Linux /proc目录下信息提取&quot;&gt;&lt;/a&gt;Linux /proc目录下信息提取&lt;/h1&gt;&lt;h3 id=&quot;201
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/31/Electron%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/07/31/Electron应用开发/</id>
    <published>2018-07-31T06:23:58.792Z</published>
    <updated>2018-08-10T02:32:37.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Electron应用开发"><a href="#Electron应用开发" class="headerlink" title="Electron应用开发"></a>Electron应用开发</h1><h3 id="日期1-日期2"><a href="#日期1-日期2" class="headerlink" title="日期1~日期2"></a>日期1~日期2</h3><h2 id="标签：-模板"><a href="#标签：-模板" class="headerlink" title="标签： 模板 "></a>标签： 模板 </h2><blockquote><ul><li>0x00-项目背景</li><li>0x01-技能储备</li><li>0x02-开发环境</li><li>0x03-方案设计</li><li>0x04-测试验证</li><li>0x05-调试优化</li><li>0x06-项目源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-项目背景"><a href="#0x00-项目背景" class="headerlink" title="0x00-项目背景"></a>0x00-项目背景</h1><h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p>原型开发</p><h2 id="项目前景"><a href="#项目前景" class="headerlink" title="项目前景"></a>项目前景</h2><p>Electron套用BlurAdmin模板打通了B/S架构与跨平台桌面应用程序之间的界限</p><h1 id="0x01-技能储备"><a href="#0x01-技能储备" class="headerlink" title="0x01-技能储备"></a>0x01-技能储备</h1><h2 id="Linux内核开发经验"><a href="#Linux内核开发经验" class="headerlink" title="Linux内核开发经验"></a>Linux内核开发经验</h2><h2 id="人工智能开发经验"><a href="#人工智能开发经验" class="headerlink" title="人工智能开发经验"></a>人工智能开发经验</h2><h2 id="数据分析开发经验"><a href="#数据分析开发经验" class="headerlink" title="数据分析开发经验"></a>数据分析开发经验</h2><h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h1 id="0x02-开发环境"><a href="#0x02-开发环境" class="headerlink" title="0x02-开发环境"></a>0x02-开发环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><p>原型开发：</p><p>Electron开发</p><p>BlurAdmin开发</p><p>BlurAdmin开发完成后打包成Electron应用</p><p>使用BlurAdmin打包压缩后的代码，结合Electron开发</p><p>使用BlurAdmin打包未压缩的代码，结合Electron开发</p><p>BlurAdmin开发+使用BlurAdmin打包未压缩的代码+Electron开发</p><p>交互开发：</p><h2 id="Electron套用HTML5模板"><a href="#Electron套用HTML5模板" class="headerlink" title="Electron套用HTML5模板"></a>Electron套用HTML5模板</h2><p>ui-router方法，这种方法配置的侧边栏，其html文件由相应的js操纵，动态填充在主页面index.html的框架中，经过gulp工具后打包会被内联到js中，再修改不方便。</p><p>手工配置方法，这种方法将侧边栏指向另外一个完整的静态网页，其html文件经过gulp打包后保持原有格式。方便在electron上二次开发。</p><h2 id="使用Electron调用Node-js等相关API，编写应用"><a href="#使用Electron调用Node-js等相关API，编写应用" class="headerlink" title="使用Electron调用Node.js等相关API，编写应用"></a>使用Electron调用Node.js等相关API，编写应用</h2><h2 id="使用Electron全栈开发"><a href="#使用Electron全栈开发" class="headerlink" title="使用Electron全栈开发"></a>使用Electron全栈开发</h2><p>Electron套用BlurAdmin模板</p><h3 id="添加模块兼容语句"><a href="#添加模块兼容语句" class="headerlink" title="添加模块兼容语句"></a>添加模块兼容语句</h3><pre><code>&lt;!--添加模块兼容语句--&gt;&lt;script&gt;if (typeof module === &apos;object&apos;) {window.module = module; module = undefined;}&lt;/script&gt;</code></pre><p><img src="/assets/blogImg/微信图片_20180805123318.png" alt=""></p><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-测试验证"><a href="#0x04-测试验证" class="headerlink" title="0x04-测试验证"></a>0x04-测试验证</h1><h2 id="测试操作"><a href="#测试操作" class="headerlink" title="测试操作"></a>测试操作</h2><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h1 id="0x05-调试优化（折中与平衡）"><a href="#0x05-调试优化（折中与平衡）" class="headerlink" title="0x05-调试优化（折中与平衡）"></a>0x05-调试优化（折中与平衡）</h1><h2 id="用户体验："><a href="#用户体验：" class="headerlink" title="用户体验："></a>用户体验：</h2><h2 id="应用性能："><a href="#应用性能：" class="headerlink" title="应用性能："></a>应用性能：</h2><h1 id="0x06-项目源码"><a href="#0x06-项目源码" class="headerlink" title="0x06-项目源码"></a>0x06-项目源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Electron应用开发&quot;&gt;&lt;a href=&quot;#Electron应用开发&quot; class=&quot;headerlink&quot; title=&quot;Electron应用开发&quot;&gt;&lt;/a&gt;Electron应用开发&lt;/h1&gt;&lt;h3 id=&quot;日期1-日期2&quot;&gt;&lt;a href=&quot;#日期1-日期
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/31/BlurAdmin%E6%A8%A1%E6%9D%BF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/07/31/BlurAdmin模板学习/</id>
    <published>2018-07-31T06:21:36.036Z</published>
    <updated>2018-08-10T02:30:48.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BlurAdmin模板学习"><a href="#BlurAdmin模板学习" class="headerlink" title="BlurAdmin模板学习"></a>BlurAdmin模板学习</h1><h3 id="2018-7-23-2018年7月30日"><a href="#2018-7-23-2018年7月30日" class="headerlink" title="2018-7-23~2018年7月30日"></a>2018-7-23~2018年7月30日</h3><h2 id="标签：-模板"><a href="#标签：-模板" class="headerlink" title="标签： 模板 "></a>标签： 模板 </h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>研究HTML界面开发框架以及相关开发语言<br>了解BlurAdmin模板的项目结构和简单使用<br>熟练定制BlurAdmin模板配色、主题、页面、组件等</p><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><p>学习BlurAdmin模板可以加深对前端的理解<br>定制模板、修改组件可以得到合适的模板，缩减项目开发周期</p><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="BlurAdmin基础"><a href="#BlurAdmin基础" class="headerlink" title="BlurAdmin基础"></a>BlurAdmin基础</h2><h3 id="BlurAdmin介绍"><a href="#BlurAdmin介绍" class="headerlink" title="BlurAdmin介绍"></a>BlurAdmin介绍</h3><p><img src="/assets/blogImg/微信图片_20180802201611.png" alt=""></p><ul><li>BlurAdmin是Angular前端Admin Dashboard模板。这意味着您可以在图表，图表表格中看到的所有数据都在Javascript中进行硬编码。您可以无限制地使用任何您想要的后端。</li><li>目前很多业务应用程序都有一些管理界面。有时它并不那么明显，但很多Web应用程序都有仪表板，带有面板，图表分析。</li><li>BlurAdmin旨在引导您的产品开发，并为构建原型甚至生产就绪应用程序提供生态系统。</li><li>尽管像Bootstrap这样的框架提供了许多组件，但通常它们还不足以构建真实世界的应用程序。此模板带有许多流行的UI组件和统一的配色方案。</li></ul><h3 id="BlurAdmin文档"><a href="#BlurAdmin文档" class="headerlink" title="BlurAdmin文档"></a>BlurAdmin文档</h3><p>主要介绍了BlurAdmin模板的特点、安装、定制等一些问题，是BlurAdmin学习必备的文档。</p><h3 id="BlurAdmin特点"><a href="#BlurAdmin特点" class="headerlink" title="BlurAdmin特点"></a>BlurAdmin特点</h3><ul><li>响应式布局</li><li>高分辨率</li><li>Bootstrap CSS  框架</li><li>Sass</li><li>Gulp构建</li><li>AngularJS</li><li>jQuery</li><li>Jquery ui</li><li>图表（amChart，Chartist，Chart.js，Morris）</li><li>地图（Google，Leaflet，amMap）</li></ul><p>总之，其图形界面比较炫酷，图表分析功能强大，各种组件比较齐全。</p><h2 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h2><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </li><li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 </li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li><li>Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。</li><li>除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等</li></ul><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>PostgreSQL</li><li>WebStorm</li><li>Node.js</li><li>Git</li></ul><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="改变配色方案"><a href="#改变配色方案" class="headerlink" title="改变配色方案"></a>改变配色方案</h2><p>修改BlurAdmin模板的背景色，文本颜色等</p><h2 id="启用模糊主题"><a href="#启用模糊主题" class="headerlink" title="启用模糊主题"></a>启用模糊主题</h2><p>计算面板的初始背景偏移，改变一些颜色，使主题变得模糊</p><h2 id="分析项目结构"><a href="#分析项目结构" class="headerlink" title="分析项目结构"></a>分析项目结构</h2><p>详细了解该模板目录下每个文件/文件夹的内容、功能等</p><h2 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h2><p>创建一个新的HTML页面，写入内容：Hello BlurAdmin !</p><h2 id="修改侧边栏组件"><a href="#修改侧边栏组件" class="headerlink" title="修改侧边栏组件"></a>修改侧边栏组件</h2><p>使用多种方式配置侧边栏菜单，使得主页可以打开所创建的页面</p><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="模板准备"><a href="#模板准备" class="headerlink" title="模板准备"></a>模板准备</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li><p><a href="https://github.com/akveo/blur-admin" target="_blank" rel="noopener">GitHub官网下载</a></p><p> git clone <a href="https://github.com/akveo/blur-admin.git" target="_blank" rel="noopener">https://github.com/akveo/blur-admin.git</a></p></li><li><p><a href="https://akveo.github.io/blur-admin/articles/091-downloads/" target="_blank" rel="noopener">BlurAdmin官网下载</a> </p></li></ol><p>如果您在安装node.js和/或其他工具以在您的计算机上构建和运行BlurAdmin时遇到问题而您只想下载html / js / css文件，则可以在此页面上找到要下载的链接。</p><p><strong>可以在{ARCHIVE_ROOT}/blur-admin-{VERSION}/dev-release目录中找到开发（非压缩）文件</strong>。压缩文件在{ARCHIVE_ROOT}/blur-admin-{VERSION}/release目录中。然后您可以打开index.html以查看您的本地版本。</p><p><strong>请注意：</strong>由于chrome不支持AJAX请求，因此当您通过文件协议打开HTML文件时，可能需要禁用Web安全性才能运行模板。</p><p>OS  X 上的示例命令：</p><pre><code>open -a Google\ Chrome --args --disable-web-security --user-data-dir=~/ChromeDevSession/</code></pre><p>Linux上的示例命令 </p><pre><code>google-chrome --user-data-dir=&quot;~/chrome-dev-session&quot; --disable-web-security</code></pre><p>Windows上的示例命令</p><pre><code>start chrome --user-data-dir=&quot;C:/Chrome dev session&quot; --disable-web-security</code></pre><p><strong>下载链接</strong></p><p><a href="https://akveo.github.io/blur-admin/downloads/blur-admin-1.3.1.zip" target="_blank" rel="noopener">BlurAdmin 1.3.1</a><br><a href="https://akveo.github.io/blur-admin/downloads/blur-admin-1.2.0.zip" target="_blank" rel="noopener">BlurAdmin 1.2.0</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>cd blur-admin npm install //安装所需组件npm install -g yo gulp bower //安装bowernpm install -g generator-gulp-angular //安装generator-gulp-angular</code></pre><p><strong>注：</strong></p><p>安装node如果没有翻墙的话可能会安装失败，使用淘宝镜像代替：</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org  然后用 cnpm install</code></pre><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ol><li>去掉引用谷歌maps.js ###<br><img src="/assets/blogImg/微信图片_20180805122307.png" alt=""></li><li>去掉启动app.js的延迟时间设置和AmCharts预加载<br><img src="/assets/blogImg/微信图片_20180805122439.png" alt=""></li></ol><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ol><li>要在开发模式下运行本地副本，请执行：<br> gulp serve</li></ol><p>此脚本应在默认浏览器中自动打开模板。<br><img src="/assets/blogImg/微信图片_20180805111748.png" alt=""><br><img src="/assets/blogImg/微信图片_20180805111820.png" alt=""></p><ol start="2"><li><p>要在生产模式下运行本地副本，请执行：</p><p> gulp serve:dist<br><img src="/assets/blogImg/微信图片_20180805114943.png" alt=""><br><img src="/assets/blogImg/微信图片_20180805114952.png" alt=""></p></li></ol><p><strong>注：</strong>release文件即为发布所需文件</p><p><strong>模板主页</strong><br><img src="/assets/blogImg/微信图片_20180805111856.png" alt=""><br><strong>注：</strong>默认浅色主题</p><h2 id="改变配色方案-1"><a href="#改变配色方案-1" class="headerlink" title="改变配色方案"></a>改变配色方案</h2><p>默认情况下，BlurAdmin有两种颜色配置文件：mint和blur。那么如何创建自己的颜色配置文件呢？假设你想让BlurAdmin变暗。首先，建议将一些colorscheme文件作为基础。<br>对于浅色主题，建议采用src/sass/theme/conf/colorScheme/_mint.scss文件；<br>对于黑暗主题，建议采用src/sass/theme/conf/colorScheme/_blur.scss文件。<br>1）如果想要黑暗主题。复制<br>src/sass/theme/conf/colorScheme/_blur.scss<br>到<br>src/sass/theme/conf/colorScheme/_dark.scss。<br><img src="/assets/blogImg/微信图片_20180806083837.png" alt=""></p><p>2）同时需修改colorscheme文件src/sass/theme/common.scs。请替换</p><pre><code>@import &apos;theme/conf/colorScheme/mint&apos;;</code></pre><p>至    </p><pre><code>@import &apos;theme/conf/colorScheme/dark&apos;;</code></pre><p><img src="/assets/blogImg/微信图片_20180806083956.png" alt=""><br>3）现在可以开始改变颜色了。例如，为展示不同颜色的一些内容，可在_dark.scss文件中更改了5个主要变量：</p><pre><code>$default: rgba(#000000, 0.2); //Panel background color$body-bg: #F0F3F4; // Body background color$default-text: #ffffff; // Default text color$help-text: #eeeeee; // Default subtext color$label-text: #ffffff; // Text for labels in forms (Basically it should be equal to default-text in most cases)</code></pre><p>4）完成此操作后，需要在构建图表和其他JavaScript组件时设置javascript以使用相同的颜色。为此，将以下代码添加到某个配置块，例如src/app/theme/theme.config.js：</p><pre><code> baConfigProvider.changeColors({ default: &apos;rgba(#000000, 0.2)&apos;, defaultText: &apos;#ffffff&apos;, dashboard: {   white: &apos;#ffffff&apos;, },});</code></pre><p><img src="/assets/blogImg/微信图片_20180806103037.png" alt=""><br>基本上就是这样！现在应用程序如下所示：</p><p><img src="/assets/blogImg/微信图片_20180806084725.png" alt=""><br>如需进一步修改，请参考</p><ul><li>Colorscheme scss文件（src/sass/theme/conf/colorScheme/路径下）</li><li>src/app/theme/theme.configProvider.js 了解哪些javascript颜色可以更改</li></ul><h2 id="启用模糊主题-1"><a href="#启用模糊主题-1" class="headerlink" title="启用模糊主题"></a>启用模糊主题</h2><p>如果要将主题切换为模糊，则需要执行以下3个简单步骤：</p><p>1）模糊主题需要一些javascript来计算面板的初始背景偏移。这就是为什么你需要做的第一件事是启用该代码。这应该在Angular 配置块中完成。例如，您可以添加以下行src/app/theme/theme.config.js：</p><pre><code>baConfigProvider.changeTheme({blur: true});</code></pre><p>2）同样你需要改变一些颜色。。对于模糊主题，可以使用以下配置</p><pre><code>baConfigProvider.changeColors({default: &apos;rgba(#000000, 0.2)&apos;,defaultText: &apos;#ffffff&apos;,dashboard: {  white: &apos;#ffffff&apos;,},});</code></pre><p><img src="/assets/blogImg/微信图片_20180806085148.png" alt=""><br>3）CSS也应该重新编译。在运行构建命令之前，建议切换到模糊颜色配置文件。为此，请替换文件中的主题src/sass/theme/common.scss：</p><pre><code>@import &apos;theme/conf/colorScheme/mint&apos;;</code></pre><p>至</p><pre><code>@import &apos;theme/conf/colorScheme/blur&apos;;</code></pre><p>或</p><pre><code>@import &apos;theme/conf/colorScheme/dark&apos;;</code></pre><p><img src="/assets/blogImg/微信图片_20180806083956.png" alt=""><br><strong>主题效果</strong></p><p><img src="/assets/blogImg/微信图片_20180806083417.png" alt=""><br><strong>注：</strong>如果想使用一些不同的背景，请替换以下图像：</p><pre><code>src/app/assets/img/blur-bg.jpg （主要背景图片）src/app/assets/img/blur-bg-blurred.jpg （面板上使用的模糊背景图像）</code></pre><h2 id="分析项目结构-1"><a href="#分析项目结构-1" class="headerlink" title="分析项目结构"></a>分析项目结构</h2><p>该模板的目录结构如下：</p><pre><code>├── bower.json   &lt;- front-end library dependencies//前端库依赖├── gulpfile.js  &lt;- main task runner file//主任务运行文件├── package.json &lt;- mostly task runner dependencies//许多任务运行依赖├── docs/&lt;- wintersmith documentation generator//wintersmith文档生成器├── gulp/&lt;- build tasks//项目构建├── src/ &lt;- main front-end assets//源代码│   ├── 404.html│   ├── auth.html│   ├── index.html  &lt;- main app dashboard page//主应用程序页面│   ├── reg.html│   ├── app/&lt;- angular application files//angular应用程序文件│   │   ├── app.js &lt;- angular application entry point. Used for managing dependencies//angular应用程序入口. 用于管理依赖项│   │   ├── pages/ &lt;- UI router pages. Pages created for demonstration purposes. Put your application js and html files here//UI路由页面,为演示目的创建的页。将应用程序 js 和 html 文件放在这里│   │   ├── theme/ &lt;- theme components. Contains various common widgets, panels which used across application//主题组件. 包含各种常用的小部件, 跨应用使用的模板│   ├── assets/ &lt;- static files (images, fonts etc.)//静态文件 (图像, 字体等)│   ├── sass/   &lt;- sass styles//sass样式文件│   │   ├── app/   &lt;- application styles. Used mostly for demonstration purposes. Put your app styles here.//应用程序样式。主要用于演示目的。将应用程序样式放在这里│   │   ├── theme/ &lt;- theme styles. Used to customize bootstrap and other common components used in tempate.//主题样式。用于自定义bootstrap和模板中使用的其他常用组件。</code></pre><p>在该模板中，尝试分离主题图层和表示层。大多数其他模板都将它们结合起来。这就是为什么当开始使用它们时，很难删除不需要的东西。</p><h2 id="创建新页面-1"><a href="#创建新页面-1" class="headerlink" title="创建新页面"></a>创建新页面</h2><p>BlurAdmin使用Angular UI路由器进行导航。这意味着要创建基本配置ui-router状态所需的新页面。</p><p>建议将页面放在单独的模块中。这将允许在将来根据需要轻松关闭某些页面。假设要创建一个标题为“我的新页面”的空白页面</p><p>1）创建一个新目录来包含新页面src/app/pages。叫这个目录myNewPage。然后创建空白角度模块以包含页面中名为’myNewPage.module.js’的内容src/app/pages/myNewPage：</p><pre><code>(function () {  &apos;use strict&apos;;  angular.module(&apos;BlurAdmin.pages.myNewPage&apos;, [])  .config(routeConfig);  /** @ngInject */  function routeConfig() {  }})();</code></pre><p>2）然后在my-new-page.html里面创建一个空的html文件src/app/pages/myNewPage，写入内容：Hello BlurAdmin !<br><img src="/assets/blogImg/微信图片_20180806103734.png" alt=""><br>3）最后为这个页面创建ui路由器状态。为此，需要修改第2步创建的module.js文件：</p><pre><code>(function () {  &apos;use strict&apos;;  angular.module(&apos;BlurAdmin.pages.myNewPage&apos;, [])  .config(routeConfig);  /** @ngInject */  function routeConfig($stateProvider) {  $stateProvider  .state(&apos;myNewPage&apos;, {  url: &apos;/myNewPage&apos;,  templateUrl: &apos;app/pages/myNewPage/my-new-page.html&apos;,  title: &apos;My New Page&apos;,  sidebarMeta: {    order: 800,  },});}})();</code></pre><p><img src="/assets/blogImg/微信图片_20180806103838.png" alt=""></p><h2 id="修改侧边栏组件-1"><a href="#修改侧边栏组件-1" class="headerlink" title="修改侧边栏组件"></a>修改侧边栏组件</h2><p>边栏用于在应用程序中提供方便的导航方式。应用程序仅支持每个角度应用程序一个侧栏。这意味着侧边栏基本上是一个单一对象。目前侧栏支持1级和2级子菜单。</p><p>可以使用baSidebar指令创建补充工具栏：</p><pre><code>&lt;ba-sidebar&gt;&lt;/ba-sidebar&gt;</code></pre><p>目前它仅支持javascript配置。虽然可以手动配置或通过ui-router状态配置。这种方法可以一起使用，也可以一次使用一种。</p><p>1）手动配置<br>对于手动配置，需要baSidebarServiceProvider在角度配置块中使用提供程序。提供者有addStaticItem方法，它接收menuItem对象作为参数，它可以具有以下属性：</p><table><thead><tr><th>属性</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>菜单项的名称</td></tr><tr><td>icon</td><td>String</td><td>要在标题附近显示的图标（它是一个类名）</td></tr><tr><td>stateRef</td><td>String</td><td>ui-router 与此菜单项关联的状态</td></tr><tr><td>fixedHref</td><td>String</td><td>与此菜单项关联的网址</td></tr><tr><td>blank</td><td>String</td><td>指定是否应在新浏览器选项卡中打开以下Url</td></tr><tr><td>subMenu</td><td>Array of menu items</td><td>要显示为下一级子菜单的菜单项列表</td></tr></tbody></table><p>手动配置示例：</p><pre><code>baSidebarServiceProvider.addStaticItem({  title: &apos;Menu Level 1&apos;,  icon: &apos;ion-ios-more&apos;});</code></pre><p><strong>例如</strong><br><img src="/assets/blogImg/微信图片_20180806104804.png" alt=""><br><strong>启动效果</strong><br><img src="/assets/blogImg/微信图片_20180806104949.png" alt=""></p><p>2）路由配置<br>默认情况下，侧栏会遍历您在应用程序中定义的所有ui-router状态，并sidebarMeta在其中搜索对象。对于具有此属性的每个州，都会创建侧边栏元素。</p><p>各州按等级分组。这意味着如果某个状态存在父抽象状态并且它们都具有sidebarMeta属性，则它将显示为该抽象状态菜单项的子项。</p><p>该物品的名称取自state的title财产。示例状态配置，它将向侧栏添加项：</p><p>$stateProvider<br>        .state(‘dashboard’, {<br>          url: ‘/dashboard’,<br>          templateUrl: ‘app/pages/dashboard/dashboard.html’,<br>          title: ‘Dashboard’,<br>          sidebarMeta: {<br>            icon: ‘ion-android-home’,<br>            order: 0,<br>          },<br>        });</p><p><strong>例如</strong></p><p><img src="/assets/blogImg/微信图片_20180806103838.png" alt=""></p><p>sidebarMeta 对象可以具有以下属性：</p><table><thead><tr><th>属性</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>icon</td><td>String</td><td>要在标题附近显示的图标（它是一个类名）</td></tr><tr><td>order</td><td>Number</td><td>当前层次结构中元素的顺序</td></tr></tbody></table><p><strong>路由注册</strong></p><p><img src="/assets/blogImg/微信图片_20180806104258.png" alt=""></p><p><strong>启动效果</strong></p><p><img src="/assets/blogImg/微信图片_20180806110123.png" alt=""></p><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><ul><li>熟悉了BlurAdmin模板，加深了对前端开发的理解</li><li>通过对BlurAdmin模板配色、主题、页面、组件等模块的使用，使得定制模板变得简单</li><li>其HTML、JavaScript、CSS等语言的操作和一般前端开发一样，当然也可以在后端通过Node.js调用一些模块来扩充操作</li></ul><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><p><a href="https://pan.baidu.com/s/1V6s88IDmCfG0P-GvzFlCQg" target="_blank" rel="noopener">blur-admin-v0.1</a> 密码：<code>c3qa</code><br><strong>注：</strong>为避免与原模板命名重复，改为blur-admin-v0.1</p><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://blog.csdn.net/Mr_binM/article/details/53048119?locationNum=10&amp;fps=1" target="_blank" rel="noopener">一款基于angularjs、bootstrap免费的后台模板blur-admin使用</a></li><li><a href="http://akveo.com/blur-admin-mint/" target="_blank" rel="noopener">Mint version demo</a></li><li><a href="http://akveo.com/blur-admin/" target="_blank" rel="noopener">Blur version demo</a></li><li><a href="https://github.com/akveo/blur-admin" target="_blank" rel="noopener">GitHub地址</a></li><li><a href="https://akveo.github.io/blur-admin/articles/001-getting-started/" target="_blank" rel="noopener">BlurAdmin文档</a></li><li><a href="https://akveo.github.io/blur-admin/" target="_blank" rel="noopener">BlurAdmin官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BlurAdmin模板学习&quot;&gt;&lt;a href=&quot;#BlurAdmin模板学习&quot; class=&quot;headerlink&quot; title=&quot;BlurAdmin模板学习&quot;&gt;&lt;/a&gt;BlurAdmin模板学习&lt;/h1&gt;&lt;h3 id=&quot;2018-7-23-2018年7月30日&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/31/Electron%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/31/Electron开发流程/</id>
    <published>2018-07-31T06:12:00.798Z</published>
    <updated>2018-08-10T02:26:16.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Electron开发流程"><a href="#Electron开发流程" class="headerlink" title="Electron开发流程"></a>Electron开发流程</h1><h3 id="日期1-日期2"><a href="#日期1-日期2" class="headerlink" title="日期1~日期2"></a>日期1~日期2</h3><h2 id="标签：-模板"><a href="#标签：-模板" class="headerlink" title="标签： 模板 "></a>标签： 模板 </h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践操作</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><ul><li>使用Electron开发一个简单桌面应用Demo</li><li>了解Electron原理及开发逻辑、流程(编写→运行→打包)</li></ul><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><ul><li>将网站构建为桌面应用程序，需求较为广泛</li><li>打通了B/S架构与跨平台桌面应用程序之间的界限</li><li>为后续开发复杂应用理清业务逻辑，探索开发方式</li></ul><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h2><h3 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h3><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><pre><code>npm install moduleName # 安装模块到项目目录下npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖</code></pre><h4 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h4><pre><code>npm remove moduleName # 卸载项目目录下模块npm remove -g moduleName # -g 的意思是全局卸载模块npm remove -save moduleName # -save 的意思是卸载项目目录下模块，并在package文件的dependencies节点删除依赖。npm remove -save-dev moduleName # -save-dev 的意思是卸载项目目录下模块 ，并在package文件的devDependencies节点删除依赖</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。</p><h3 id="package-lock-json-文件"><a href="#package-lock-json-文件" class="headerlink" title="package-lock.json 文件"></a>package-lock.json 文件</h3><ul><li>锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致</li><li>根据官方文档，这个package-lock.json 是在 <code>npm install</code>时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。</li><li>npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖</li></ul><h2 id="Electron基础"><a href="#Electron基础" class="headerlink" title="Electron基础"></a>Electron基础</h2><h3 id="Electron介绍"><a href="#Electron介绍" class="headerlink" title="Electron介绍"></a>Electron介绍</h3><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p><h3 id="Electron文档"><a href="#Electron文档" class="headerlink" title="Electron文档"></a>Electron文档</h3><p>由 <strong>指南、API参考、高级</strong> 组成，详细介绍了Electron的使用、接口、开发等一些了问题，是Electron学习必备的文档。</p><h3 id="Electron特点"><a href="#Electron特点" class="headerlink" title="Electron特点"></a>Electron特点</h3><h4 id="Web技术"><a href="#Web技术" class="headerlink" title="Web技术"></a>Web技术</h4><p>Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。<br>这是一个整合了Node，Chromium，V8的一个框架，通过它可以使用JavaScript，HTML, CSS技术来开发桌面应用程序</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>Electron 是一个由 GitHub 及众多贡献者组成的活跃社区共同维护的开源项目。</p><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>Electron 兼容 Mac, Windows 和 Linux， 它构建的应用可在这三个操作系统上面运行。</p><h4 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h4><p>随着前端技术的发展，现在越来越多的桌面应用程序会嵌入一些Web技术来进行混合开发，结合了web端和传统桌面软件各自的优点。</p><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>PostgreSQL</li><li>Node.js</li></ul><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="electron-packager打包"><a href="#electron-packager打包" class="headerlink" title="electron-packager打包"></a>electron-packager打包</h2><p>创建一个简单页面，通过Electron打开、打包、更改图标、整合成安装包、更新</p><h2 id="electron-builder打包"><a href="#electron-builder打包" class="headerlink" title="electron-builder打包"></a>electron-builder打包</h2><p>进一步优化，使得可以打包成安装程序，生成文件尽可能小，并且支持自动升级</p><h1 id="0x04-实践操作"><a href="#0x04-实践操作" class="headerlink" title="0x04-实践操作"></a>0x04-实践操作</h1><h2 id="Electron安装"><a href="#Electron安装" class="headerlink" title="Electron安装"></a>Electron安装</h2><p>由于国外镜像不能访问的原因，所以使用国内淘宝npm镜像进行安装。</p><pre><code>npm install -g package --registry=https://registry.npm.taobao.org</code></pre><p>也可以使用淘宝NPM开发的cnpm进行package的安装</p><pre><code>//首先安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org//使用cnpm进行安装，使用方法和npm相同，全局安装cnpm install -g electron//查看electron版本electron -v</code></pre><p><img src="/assets/blogImg/electron-use-1.png" alt=""></p><p>使用npm通过淘宝镜像安装和cnpm安装，均可成功安装electron（原electron-prebuilt）。</p><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>创建一个electron应用。我们现在仅仅需要3个文件。 </p><pre><code>index.html main.js package.json</code></pre><p>index.html使我们想要显示的页面，main.js为此应用的入口，package.json为npm项目的配置文件。</p><ol><li><p>新建一个名为electron的文件夹，进入项目目录进行初始化产生package.json文件 </p><p> mkdir electron<br> cd electron<br> npm init</p></li></ol><p>使得package.json为中名称为：HelloElectron；描述为：a simple application；scripts中添加”start”: “electron .”；署名为：xiafei_xupt,其余默认即可</p><ol start="2"><li><p>新建一个index.html, 使得页面标题为：HelloElectron！；页面内容为：Hello Electron！</p></li><li><p>新建一个main.js, 内容如下：（main.js的文件名对应package.json中main的值），同时关闭调试工具。</p></li></ol><h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>在Electron目录下执行npm start 或electron .即可运行</p><p>如果你是局部安装，则运行：</p><pre><code>./node_modules/.bin/electron .npm start</code></pre><p><img src="/assets/blogImg/微信图片_20180801163721.png" alt=""><br><img src="/assets/blogImg/electron-use-2.png" alt=""></p><h2 id="应用打包"><a href="#应用打包" class="headerlink" title="应用打包"></a>应用打包</h2><h3 id="electron-packager打包-1"><a href="#electron-packager打包-1" class="headerlink" title="electron-packager打包"></a>electron-packager打包</h3><p><strong>安装electron-packager</strong><br>它也是一个npm模块，是一个用于打包electron应用的工具</p><pre><code>npm install -g electron-packagerelectron-packager --version</code></pre><p><img src="/assets/blogImg/electron-use-2-0.png" alt=""></p><p><strong>开始打包</strong><br>打包格式如下：</p><pre><code>electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</code></pre><p>但是这样并不够，会提示：<br>    Unable to determine Electron version. Please specify an Electron version<br><img src="/assets/blogImg/微信图片_20180801162943.png" alt=""><br>需要指明Electron version，改进为:</p><pre><code>electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] --electron-version=&lt;electron version&gt;</code></pre><p>eg:</p><pre><code>electron-packager . HelloElectron win32 x64 --electron-version=2.0.6或electron-packager . HelloElectron --platform=win32 --arch=x64 --electron-version=2.0.6</code></pre><p><img src="/assets/blogImg/微信图片_20180801170946.png" alt=""><br><strong>打包结束</strong><br>即在当前目录下生成了一个116M的HelloElectron文件夹，该文件夹内有一个65M大小的HelloElectron.exe<br>通过图形界面进入该文件夹，双击即可运行。<br><img src="/assets/blogImg/微信图片_20180801173408.png" alt=""></p><p>通过查看resources\app目录，可以查看到项目的源代码。<br><img src="/assets/blogImg/微信图片_20180801173934.png" alt=""></p><p><strong>补充</strong></p><ol><li><p>最简单一键打包命令<br>会打包生成所有你需要的各种platform各种arch的包</p><p> electron-packager ./ –all<br> 即：<br> electron-packager ./ –all –electron-version=2.0.6</p></li></ol><ol start="2"><li>分平台分arch打包</li></ol><p>platform 取值有：darwin, linux, mas, win32 。命令：</p><pre><code>electron-packager ./ --platform=darwinelectron-packager ./ --platform=linuxelectron-packager ./ --platform=maselectron-packager ./ --platform=win32</code></pre><p>不写arch的情况下，arch的取值就是打包的电脑的arch值。一般可以取值有：</p><pre><code>ia32,x64,armv7l,arm64electron-packager ./ --arch=ia32electron-packager ./ --arch=x64electron-packager ./ --arch=armv7lelectron-packager ./ --arch=arm64</code></pre><ol start="3"><li>新生成的包，如果你想继续实验其他选项的话，可能是难以删除的。可以增加个<code>--overwrite</code>参数，会覆盖原有的<code>build</code>。有关其他可选标志的概述，请运行<code>electron-packager --help</code>或查看 <a href="https://github.com/electron-userland/electron-packager/blob/master/usage.txt" target="_blank" rel="noopener">usage.txt</a>。有关详细说明，请参阅<a href="https://github.com/electron-userland/electron-packager/blob/master/docs/api.md" target="_blank" rel="noopener">API文档</a>。</li><li><p>如果我们想要更改窗口左上角的图标和任务栏的图标，只需要在打包的命令上加个icon参数</p><p> <code>--icon= &lt;ico_address&gt;</code><br>eg:<br> <code>--icon=./app/img/icon.ico</code></p></li></ol><h3 id="electron-builder打包-1"><a href="#electron-builder打包-1" class="headerlink" title="electron-builder打包"></a>electron-builder打包</h3><p><strong>安装electron-builder</strong></p><pre><code>npm install electron-builder -gelectron-builder --version</code></pre><p><img src="/assets/blogImg/微信图片_20180801185434.png" alt=""></p><p><strong>开始打包</strong></p><p><img src="/assets/blogImg/微信图片_20180801190245.png" alt=""></p><p>实际上打包过程会各种超时,建议挂代理</p><p><strong>打包结束</strong><br><img src="/assets/blogImg/微信图片_20180801191543.png" alt=""><br><strong>打开应用</strong><br><img src="/assets/blogImg/微信图片_20180801192048.png" alt=""></p><p><strong>安装应用</strong></p><p><img src="/assets/blogImg/微信图片_20180801192607.png" alt=""><br><strong>运行应用</strong><br><img src="/assets/blogImg/微信图片_20180801192656.png" alt=""><br><img src="/assets/blogImg/微信图片_20180801192725.png" alt=""></p><p><strong>补充</strong></p><ol><li><p>一键构建所有安装包<br>electron-builder -mwl<br>electron-builder –platform=all<br>electron-builder –win –x64</p></li><li><p>分平台构建安装包</p></li></ol><p>mac：</p><pre><code>electron-builder -melectron-builder -oelectron-builder --macelectron-builder --macoselectron-builder --platform=macelectron-builder --platform=darwin</code></pre><p>win:</p><pre><code>electron-builder -welectron-builder --winelectron-builder --windowselectron-builder --platform=winelectron-builder --platform=win32</code></pre><p>inux:</p><pre><code>electron-builder -lelectron-builder --linuxelectron-builder --platform=linux</code></pre><ol start="3"><li>参数说明</li></ol><p>–platform 这个参数是过期废弃的参数，不建议使用。同样，还有 –arch （取值是ia32/x64/all）也是一个过期参数。替代参数是 –x64 或者 –ia32 或者 –armv7l 。</p><p>当 –platform 或者 –arch 没有指定的时候，就会build当前系统的platform，当前系统的arch。也就是说，下面的命令在不同的系统下，命令是不一样的。（没有指定platform和arch）。</p><p>electron-builder –help 可查看相关用法</p><ol start="4"><li><p>latest.yml为与更新相关文件，了打包时生成latest.yml文件，需要在 build 参数中添加 publish 配置，即：</p><p> “publish”: [<br>   {<br> “provider”: “generic”,<br> “url”: “<a href="http://localhost:4000/version&quot;//更新服务器地址" target="_blank" rel="noopener">http://localhost:4000/version&quot;//更新服务器地址</a><br>   }<br> ]<br>则：<br><img src="/assets/blogImg/微信图片_20180801223134.png" alt=""></p></li></ol><p><strong>注意</strong></p><ol><li><p>devDependencies与dependencies的区别<br>dependencies 表示我们要在生产环境下使用该依赖，devDependencies 则表示我们仅在开发环境使用该依赖。在打包时，一定要分清哪些包属于生产依赖，哪些属于开发依赖，尤其是在项目较大，依赖包较多的情况下。若在生产环境下错应或者少引依赖包，即便是成功打包，但在使用应用程序期间也会报错，导致打包好的程序无法正常运行。</p></li><li><p>npm与cnpm的区别<br>说到npm与cnpm的区别，可能大家都知道，但大家容易忽视的一点，是cnpm装的各种node_module，这种方式下所有的包都是扁平化的安装。一下子node_modules展开后有非常多的文件。<br>导致了在打包的过程中非常慢。但是如果改用npm来安装node_modules的话，所有的包都是树状结构的，层级变深。<br>由于这个不同，对一些项目比较大的应用，很容易出现打包过程慢且node内存溢出的问题（这也是在解决electron打包过程中困扰我比较久的问题，最后想到了npm与cnpm的这点不同，解决了node打包内存溢出的问题，从打包一次一小时优化到打包一次一分钟，极大的提高了效率）。<br>所以建议在打包前，将使用cnpm安装的依赖包删除，替换成npm安装的依赖包。</p></li></ol><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><h3 id="electron-packager打包-2"><a href="#electron-packager打包-2" class="headerlink" title="electron-packager打包"></a>electron-packager打包</h3><ol><li>支持平台有：Windows (32/64 bit)、OS X (also known as macOS)、Linux (x86/x86_64);</li><li>进行应用更新时，使用electron内置的autoUpdate进行更新</li><li>支持CLI和JS API两种使用方式；</li></ol><h3 id="electron-builder打包-2"><a href="#electron-builder打包-2" class="headerlink" title="electron-builder打包"></a>electron-builder打包</h3><ol><li>electron-builder 可以打包成msi、exe、dmg文件，macOS系统，只能打包dmg文件，window系统才能打包exe，msi文件；</li><li>几乎支持了所有平台的所有格式；</li><li>支持Auto Update；</li><li>支持CLI和JS API两种使用方式；</li></ol><h3 id="electron应用整合成一个安装包"><a href="#electron应用整合成一个安装包" class="headerlink" title="electron应用整合成一个安装包"></a>electron应用整合成一个安装包</h3><p>另外可以使用下面两种方法：</p><ol><li><a href="http://blog.csdn.net/yu17310133443/article/details/79496499" target="_blank" rel="noopener">NSIS打包Electron</a>    </li><li><a href="http://blog.csdn.net/yu17310133443/article/details/79495936" target="_blank" rel="noopener">grunt打包Electron</a> </li></ol><h2 id="文章分析"><a href="#文章分析" class="headerlink" title="文章分析"></a>文章分析</h2><p>本文使用Electron创建一个简单页面，实现了打开、打包、更改图标、整合成安装包等功能，展示了Electron应用开发的简单流程，使得开发逻辑更加清晰，开发过程更加具体，开发目的更加明确。</p><p>使用electron-packager打包生成文件较大，且是以文件夹形式生成，较为臃肿；源码暴露，不安全</p><p>使用electron-builder打包应用是安装包方式，而不像electron-packager打包之后直接是一个文件夹，里面所有的文件暴露出来。 </p><p>其中关于应用打包工具，推荐使用electron-builder打包，相比electron-packager有以下优点：</p><ol><li>支持更多的平台</li><li>支持了自动更新</li><li>打出的包更为轻量</li><li>打出的包不暴露源码</li><li>可以打包出setup安装程序</li></ol><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre><code>{  &quot;name&quot;: &quot;HelloElectron&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;a simple application&quot;,  &quot;main&quot;: &quot;main.js&quot;,  &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;electron .&quot;  },  &quot;author&quot;: &quot;xiafei_xupt&quot;,  &quot;license&quot;: &quot;ISC&quot;}    </code></pre><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><pre><code>&lt;!DOCTYPE html&gt;  &lt;html&gt;    &lt;head&gt;  &lt;title&gt;HelloElectron！&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;  &lt;h1&gt;Hello Electron!&lt;/h1&gt;    &lt;/body&gt;  &lt;/html&gt; </code></pre><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><pre><code>const {app, BrowserWindow} = require(&apos;electron&apos;);let win;let windowConfig = {width:800,height:600};function createWindow(){win = new BrowserWindow(windowConfig);win.loadURL(`file://${__dirname}/index.html`);//接口//开启调试工具//win.webContents.openDevTools();win.on(&apos;close&apos;,() =&gt; {//回收BrowserWindow对象win = null;});win.on(&apos;resize&apos;,() =&gt; {win.reload();})}app.on(&apos;ready&apos;,createWindow);app.on(&apos;window-all-closed&apos;,() =&gt; {app.quit();});app.on(&apos;activate&apos;,() =&gt; {if(win == null){createWindow();}})</code></pre><h2 id="Electron-Demo打包"><a href="#Electron-Demo打包" class="headerlink" title="Electron Demo打包"></a>Electron Demo打包</h2><p>为避免命名冲突，重命名为<a href="https://pan.baidu.com/s/15miRWxA6Qj8cv9cCB2ydhw" target="_blank" rel="noopener">electron-v1.0.0</a>（密码：<code>dkes</code>）</p><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.npmjs.com/package/electron-packager" target="_blank" rel="noopener">electron-packager文档</a></li><li><a href="https://electronjs.org/" target="_blank" rel="noopener">Electron官网</a></li><li><a href="https://electronjs.org/docs" target="_blank" rel="noopener">Electron 文档</a></li><li><a href="https://electronjs.org/docs/tutorial/first-app" target="_blank" rel="noopener">打造你第一个 Electron 应用</a></li><li><a href="https://newsn.net/say/electron-packager-basic.html" target="_blank" rel="noopener">electron-packager打包工具的最简化使用</a></li><li><a href="https://segmentfault.com/a/1190000013924153" target="_blank" rel="noopener">electron打包：electron-packager及electron-builder两种方式实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Electron开发流程&quot;&gt;&lt;a href=&quot;#Electron开发流程&quot; class=&quot;headerlink&quot; title=&quot;Electron开发流程&quot;&gt;&lt;/a&gt;Electron开发流程&lt;/h1&gt;&lt;h3 id=&quot;日期1-日期2&quot;&gt;&lt;a href=&quot;#日期1-日期
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/30/PostgreSQL%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/07/30/PostgreSQL操作接口/</id>
    <published>2018-07-30T09:06:43.332Z</published>
    <updated>2018-08-10T02:18:48.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL操作接口"><a href="#PostgreSQL操作接口" class="headerlink" title="PostgreSQL操作接口"></a>PostgreSQL操作接口</h1><h3 id="2018-8-6-2018-8-13"><a href="#2018-8-6-2018-8-13" class="headerlink" title="2018-8-6~2018-8-13"></a>2018-8-6~2018-8-13</h3><h2 id="标签：-实习-PostgreSQL-JavaScript-Electron"><a href="#标签：-实习-PostgreSQL-JavaScript-Electron" class="headerlink" title="标签： 实习 PostgreSQL JavaScript Electron"></a>标签： 实习 PostgreSQL JavaScript Electron</h2><blockquote><ul><li>0x00-文章前言   </li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><ul><li>日志分析中展示要求、界面框架数据库查询接口</li><li>PostgreSQL和Node.js、Electron应用之间的连接、通信、封装、优化、打包</li></ul><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><ul><li>对于Node.js调用PostgreSQL接口的封装有利于面向对象的开发</li><li>通过Electron使用Node.js模块和数据库通信，可以加深对Electron框架的理解</li><li>对于Node.js和数据库通信的掌握可以打通前后端的界限，有利于形成全栈思维</li></ul><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="PostgreSQL基础"><a href="#PostgreSQL基础" class="headerlink" title="PostgreSQL基础"></a>PostgreSQL基础</h2><ul><li>自从MySQL被Oracle收购以后，PostgreSQL逐渐成为开源关系型数据库的首选。</li><li>PostgreSQL是一个功能强大的开源对象关系数据库系统，它使用并扩展了SQL语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。</li><li>PostgreSQL的起源可以追溯到1986年，作为加州大学伯克利分校POSTGRES项目的一部分，并在核心平台上进行了30多年的积极开发。</li><li>PostgreSQL凭借其经过验证的架构，可靠性，数据完整性，强大的功能集，可扩展性以及软件背后的开源社区的奉献精神赢得了良好的声誉，以始终如一地提供高性能和创新的解决方案。</li><li>PostgreSQL在所有主要操作系统上运行，自2001年以来一直是符合ACID标准的，并且具有强大的附加功能，例如流行的PostGIS地理空间数据库扩展器。毫无疑问，PostgreSQL已经成为许多人和组织的首选开源关系数据库。</li></ul><h2 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h2><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </li><li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 </li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li><li>Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。</li><li>除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等</li></ul><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>Debian 9系统</li><li>PostgreSQL</li><li>Node.js</li></ul><p><strong>注：</strong>由于PostgreSQL操作接口使用Node.js实现，而Windows 10系统和Debian 9系统对于Node.js的支持完全一样，故此处只在Windows 10系统上进行测试</p><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><p>Electron通过Node.js使用 pg 模块和PostgreSQL连接</p><h2 id="客户端方式"><a href="#客户端方式" class="headerlink" title="客户端方式"></a>客户端方式</h2><p>每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。<br>适用：客户端连接次数少、重复访问率低的数据</p><p><strong>注：</strong>本文数据库操作接口使用客户端方式实现</p><h2 id="连接池方式"><a href="#连接池方式" class="headerlink" title="连接池方式"></a>连接池方式</h2><p>连接池允许应用程序从连接池中获得一个连接并使用这个连接，而不需要为每一个连接请求重新建立一个连接。一旦一个新的连接被创建并且放置在连接池中，应用程序就可以重复使用这个连接而不必实施整个数据库连接创建过程。<br>当应用程序请求一个连接时，连接池为该应用程序分配一个连接而不是重新建立一个连接；当应用程序使用完连接后，该连接被归还给连接池而不是直接释放。<br>适用：大量、重复访问率高的数据</p><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg-1.png" alt=" PostgreSQL操作接口"></p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg-2.png" alt=" PostgreSQL操作接口"></p><h2 id="安装pg模块"><a href="#安装pg模块" class="headerlink" title="安装pg模块"></a>安装pg模块</h2><p>Node.js中有专门的模块可以用来连接PostgreSql数据库，首先从npm资源库中获取数据库模块，名为”pg”：</p><pre><code>npm install pgnpm ls --depth 0//查看已安装模块</code></pre><p><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg1.png" alt=" PostgreSQL操作接口"></p><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><h3 id="增删改查接口测试"><a href="#增删改查接口测试" class="headerlink" title="增删改查接口测试"></a>增删改查接口测试</h3><p><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg2.png" alt=" PostgreSQL操作接口"><br><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg30.png" alt=" PostgreSQL操作接口"></p><h3 id="SELECT接口测试"><a href="#SELECT接口测试" class="headerlink" title="SELECT接口测试"></a>SELECT接口测试</h3><p>对<strong>增删改查</strong>接口中<strong>查询</strong>接口进行了改进</p><h4 id="Node-js测试"><a href="#Node-js测试" class="headerlink" title="Node.js测试"></a>Node.js测试</h4><p><img src="/assets/blogImg/windows10-PostgreSQL-interface-pg3.png" alt=" PostgreSQL操作接口"></p><h4 id="Electron测试"><a href="#Electron测试" class="headerlink" title="Electron测试"></a>Electron测试</h4><p><img src="/assets/blogImg/微信图片_20180810091352.png" alt=" PostgreSQL操作接口"><br><img src="/assets/blogImg/微信图片_20180810090914.png" alt=" PostgreSQL操作接口"></p><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><ul><li>在函数实现里面，我们采用了回调函数的形式实现，根据输出信息可以很号的看出node.js的主要特性：非阻塞</li><li>数据库的查询接口改进后使用指定行列进行操作，查询比较具体，由于Node.js使用非阻塞式 I/O 的模型，故多个查询之间不会冲突</li><li>PostgreSQL操作接口是连接了前后端之间的桥梁，使得前端页面和后端数据库之间的通信变得简单直观。</li></ul><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="创建数据库脚本"><a href="#创建数据库脚本" class="headerlink" title="创建数据库脚本"></a>创建数据库脚本</h2><pre><code>create table Log_Inf(id character varying(10),type character varying(10),rank character varying(10));</code></pre><h2 id="插入数据脚本"><a href="#插入数据脚本" class="headerlink" title="插入数据脚本"></a>插入数据脚本</h2><pre><code>insert into Log_Inf values(&apos;1&apos;,&apos;C01&apos;,&apos;G01&apos;);insert into Log_Inf values(&apos;2&apos;,&apos;C02&apos;,&apos;G02&apos;);insert into Log_Inf values(&apos;3&apos;,&apos;C03&apos;,&apos;G03&apos;);insert into Log_Inf values(&apos;4&apos;,&apos;C04&apos;,&apos;G04&apos;);</code></pre><h2 id="增删改查操作的封装"><a href="#增删改查操作的封装" class="headerlink" title="增删改查操作的封装"></a>增删改查操作的封装</h2><h3 id="Client-js"><a href="#Client-js" class="headerlink" title="Client.js"></a>Client.js</h3><pre><code>var f = require(&apos;./PG&apos;);var pg = require(&apos;pg&apos;);//var conString = &quot;tcp://postgres:postgres@localhost/test&quot;;var conString = &quot;tcp://postgres:111111@localhost:5432/test&quot;;var client = new pg.Client(conString);var value = [&apos;9&apos;,&apos;C09&apos;,&apos;G09&apos;];insertSQLString = &apos;insert into Log_Inf values($1,$2,$3)&apos;;selectSQLString = &apos;select * from Log_Inf&apos;;updateSQLString = &quot;update Log_Inf set TYPE=&apos;C07&apos; where ID=&apos;4&apos;&quot;;deleteSQLString = &quot;delete from Log_Inf where ID=&apos;9&apos;&quot;;client.connect(function(error, results) {if(error){console.log(&apos;ClientConnectionReady Error: &apos; + error.message);client.end();return;}console.log(&apos;connection success...\n&apos;);f._select(client,selectSQLString);f._insert(client,insertSQLString,value);f._update(client,updateSQLString);f._delete(client,deleteSQLString);});</code></pre><h3 id="PG-js"><a href="#PG-js" class="headerlink" title="PG.js"></a>PG.js</h3><pre><code>function _insert(client,insertSQLString,value){console.log(&quot;insert beginning&quot;);client.query(insertSQLString, value,  function(error, results){if(error){console.log(&quot;ClientReady Error: &quot; + error.message),client.end();return;}console.log(&apos;Inserted: &apos; + results.affectedRows + &apos; row.&apos;),console.log(&apos;insert success...\n&apos;);});console.log(&quot;insert end\n&quot;);}function _select(client,selectSQLString){console.log(&quot;select beginning&quot;);client.query(selectSQLString,  function selectCb(error, results, fields){console.log(&quot;in select callback function&quot;);if (error){console.log(&apos;GetData Error: &apos; + error.message),client.end();return;}if(results.rowCount &gt; 0){var firstResult,resultSet = &apos;&apos;;for(var i = 0, len = results.rowCount; i &lt; len; i++){firstResult = results.rows[i]; resultSet += &apos;id:&apos; + firstResult[&apos;id&apos;] + &apos; &apos; + &apos;type:&apos; + firstResult[&apos;type&apos;] + &apos; &apos; +  &apos;rank:&apos; + firstResult[&apos;rank&apos;] + &apos;\n&apos;; }}console.log(resultSet);/* 添加功能：使查询结果集返回到客户端并保证此函数的通用性. */});console.log(&quot;select end\n&quot;);}function _update(client,updateSQLString){console.log(&quot;update beginning&quot;);client.query(updateSQLString,function(error, results){if(error){console.log(&quot;ClientReady Error: &quot; + error.message),client.end();return;}console.log(&apos;update success...\n&apos;);});console.log(&quot;update end\n&quot;);}function _delete(client,deleteSQLString){console.log(&quot;delete beginning&quot;);client.query(deleteSQLString,  function(error, results){if(error){console.log(&quot;ClientReady Error: &quot; + error.message),client.end();return;}console.log(&apos;delete success...\n&apos;);});console.log(&quot;delete end\n&quot;);}exports._insert = _insert;exports._select = _select;exports._update = _update;exports._delete = _delete;</code></pre><h2 id="SELECT接口的封装"><a href="#SELECT接口的封装" class="headerlink" title="SELECT接口的封装"></a>SELECT接口的封装</h2><h3 id="Node-js测试-1"><a href="#Node-js测试-1" class="headerlink" title="Node.js测试"></a>Node.js测试</h3><h4 id="Client-js-1"><a href="#Client-js-1" class="headerlink" title="Client.js"></a>Client.js</h4><pre><code>var f = require(&apos;./SELECT&apos;);var pg = require(&apos;pg&apos;);var conString = &quot;tcp://postgres:111111@localhost:5432/test&quot;;//1.连接var client = new pg.Client(conString);Table_Name=&apos;Log_Inf&apos;;//2.表名Row_Number=0;//2.行数，默认从0开始Col_Name=&apos;id&apos;;//2.列名client.connect(function(error, results) {if(error){console.log(&apos;ClientConnectionReady Error: &apos; + error.message);client.end();return;}//f._select(client,Table_Name,Row_Number,Col_Name);f._select(client,&apos;Log_Inf&apos;,3,&apos;rank&apos;);//2.all});</code></pre><h4 id="SELECT-js"><a href="#SELECT-js" class="headerlink" title="SELECT.js"></a>SELECT.js</h4><pre><code>function _select(client,Table_Name,Row_Number,Col_Name){selectSQLString = &apos;select * from &apos;+Table_Name;    client.query(selectSQLString,  function selectCb(error, results, fields){if (error){console.log(&apos;GetData Error: &apos; + error.message),client.end();return;}if(results.rowCount &gt; 0){resultSet = results.rows[Row_Number][Col_Name]; }console.log(resultSet);/* 添加功能：使查询结果集返回到客户端并保证此函数的通用性. */});}exports._select = _select;</code></pre><p>打包后的Node.js测试<a href="https://pan.baidu.com/s/1rgjMGhRljFYwuCxMiPaACQ" target="_blank" rel="noopener">SELECT接口</a>（密码：<code>mg3w</code>）     </p><h3 id="Electron测试-1"><a href="#Electron测试-1" class="headerlink" title="Electron测试"></a>Electron测试</h3><p>测试代码是在我写的<strong>Electron开发流程</strong>中的<a href="https://pan.baidu.com/s/15miRWxA6Qj8cv9cCB2ydhw" target="_blank" rel="noopener">electron-v1.0.0</a>（密码：<code>dkes</code>）基础上进行修改 </p><p>修改方式：</p><ol><li><p>electron-v1.0.0文件夹重命名为Electron_PostgreSQL，并将Node.js测试中SELECT.js和Client.js文件放到Electron_PostgreSQL的文件夹下</p></li><li><p>在index.html的body标签中加入：</p></li></ol><pre><code>&lt;div&gt;数据库数据：&lt;span id=&quot;pg_data&quot;&gt;&lt;/span&gt;&lt;script src=&quot;./Client.js&quot;&gt;&lt;/script&gt;&lt;/div&gt; </code></pre><ol start="3"><li>在SELECT.js中<code>console.log(&#39;resultSet&#39;);</code>的下一行加入 ：</li></ol><pre><code>document.getElementById(&apos;pg_data&apos;).innerHTML = resultSet;</code></pre><p>打包后的Electron测试:<a href="https://pan.baidu.com/s/1aDTE6lm41er1pfJDYID4BQ" target="_blank" rel="noopener">Electron_PostgreSQL</a>(密码：d7gt)</p><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.postgresql.org" target="_blank" rel="noopener">PostgreSQL 官网</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js 中文网</a></li><li><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">Node.js v10.7.0 文档</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js 中文网</a></li><li><a href="https://electronjs.org/" target="_blank" rel="noopener">Electron 官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PostgreSQL操作接口&quot;&gt;&lt;a href=&quot;#PostgreSQL操作接口&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL操作接口&quot;&gt;&lt;/a&gt;PostgreSQL操作接口&lt;/h1&gt;&lt;h3 id=&quot;2018-8-6-2018-8-1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/29/PostgreSQL%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/07/29/PostgreSQL语法学习/</id>
    <published>2018-07-29T11:56:24.957Z</published>
    <updated>2018-07-30T10:38:15.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL语法学习"><a href="#PostgreSQL语法学习" class="headerlink" title="PostgreSQL语法学习"></a>PostgreSQL语法学习</h1><h3 id="2018-7-16-2018-7-23"><a href="#2018-7-16-2018-7-23" class="headerlink" title="2018-7-16~2018-7-23"></a>2018-7-16~2018-7-23</h3><h2 id="标签：-实习-PostgreSQL"><a href="#标签：-实习-PostgreSQL" class="headerlink" title="标签： 实习 PostgreSQL "></a>标签： 实习 PostgreSQL </h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><ul><li>熟悉数据库操作基本流程、数据操作命令、编程接口</li><li>建立一个简单表格，可以通过SELECT语句查询出来</li><li>了解PostgreSQL的相关语法，为后期项目开发做准备</li></ul><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><ul><li>有益于对数据库基本操作的掌握</li><li>有助于对PostgreSQL语法的学习</li><li>有利于对后期相关项目的顺利进展</li></ul><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><p>Debian 9上pgadmin3和Windows 10上pgAdmin 4类似，SQL命令完全一样，故此处仅在Windows 10上进行相关学习即可，以下内容为PostgreSQL语法学习所需基础知识。</p><h2 id="PostgreSQL命令大全"><a href="#PostgreSQL命令大全" class="headerlink" title="PostgreSQL命令大全"></a>PostgreSQL命令大全</h2><p>可以使用help语句来获取帮助信息。 按照以下步骤查看PostgreSQL中相关命令的使用。</p><ol><li>安装postgreSQL后，打开psql为：程序文件 -&gt; PostgreSQL 10 -&gt; SQL Shell(psql)，输入相关信息即可启动数据库。<br><img src="/assets/blogImg/windows10-graph-8.png" alt=" Windows 10下图形安装"></li><li>获取帮助信息 postgres=＃help<br><img src="/assets/blogImg/Windows10-PostgreSQL-help.png" alt=" Windows 10下PostgreSQL语法"></li><li>显示发行条款 postgres=＃\copyright<br><img src="/assets/blogImg/Windows10-PostgreSQL-copyright.png" alt=" Windows 10下PostgreSQL语法"></li><li>显示 SQL 命令的说明 postgres=＃\h<br><img src="/assets/blogImg/Windows10-PostgreSQL-h.png" alt=" Windows 10下PostgreSQL语法"></li><li>显示 pgsql 命令的说明 postgres=＃\?<br><img src="/assets/blogImg/Windows10-PostgreSQL-pgsql.png" alt=" Windows 10下PostgreSQL语法"></li></ol><p>……</p><h2 id="PostgreSQL语法大全"><a href="#PostgreSQL语法大全" class="headerlink" title="PostgreSQL语法大全"></a>PostgreSQL语法大全</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li>创建数据库: create database database_name;</li><li>查看数据库: \l</li><li>删除数据库: drop database database_name;</li></ul><h3 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h3><ul><li><p>创建表格</p><p>  CREATE TABLE table_name(<br>  column1 datatype,<br>  column2 datatype,<br>  column3 datatype,<br>  …..<br>  columnN datatype,<br>  PRIMARY KEY( one or more columns )<br>  );</p></li><li><p>删除表格</p><p>  DROP TABLE table_name;</p></li><li><p>插入数据</p><p>  INSERT INTO TABLE_NAME (column1, column2, column3,…columnN)<br>  VALUES (value1, value2, value3,…valueN);</p></li><li><p>查询数据<br>  SELECT “column1”, “column2”..”column” FROM “table_name”;</p></li><li><p>更新数据</p><p>  UPDATE table_name<br>  SET column1 = value1, column2 = value2…., columnN = valueN<br>  WHERE [condition];</p></li><li><p>删除数据 </p><p>  DELETE FROM table_name<br>  WHERE [condition];</p></li></ul><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li>Windows 10系统</li><li>Debian 9系统</li><li>PostgreSQL</li></ul><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="UI操作"><a href="#UI操作" class="headerlink" title="UI操作"></a>UI操作</h2><p>操作起来较为简单，适合于小量数据，用户体验度高</p><h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><p>使用SQL语句操作，由于使用命令，可复用操作大量数据，效率高</p><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>在PostgreSQL中，可以使用CREATE DATABASE命令创建数据库。</p><p>语法：</p><pre><code>CREATE DATABASE database_name;</code></pre><p>这里，database_name是指定要创建的数据库的名称。</p><p>打开开始菜单，然后单击pgAdmin,第一次打开可能需要你输入密码，结果如下<br><img src="/assets/blogImg/Windows10-PostgreSQL-create.png" alt=" Windows 10下PostgreSQL语法"><br>右键单击PostgreSQL 10并将PostgreSQL连接到本地主机服务器。右键单击数据库(Databases)，转到新数据库，将出现一个弹出框，如下图所示 -<br><img src="/assets/blogImg/Windows10-PostgreSQL-create-1.png" alt=" Windows 10下PostgreSQL语法"></p><p>然后键入您要的数据库名称，这里创建的数据库名称是：test_db，如下图所示<br><img src="/assets/blogImg/Windows10-PostgreSQL-create-test_db.png" alt=" Windows 10下PostgreSQL语法"><br>点击保存(Save)就可以了。<br>创建新的数据库(test_db)如下图所示<br><img src="/assets/blogImg/Windows10-PostgreSQL-create-test_db-1.png" alt=" Windows 10下PostgreSQL语法"></p><p>PostgreSQL使用查询工具创建数据库<br>打开SQL Shell(psql)，执行以下创建语句</p><pre><code>create database testdb;</code></pre><p>执行结果如下<br><img src="/assets/blogImg/Windows10-PostgreSQL-create-psql.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p><img src="/assets/blogImg/Windows10-PostgreSQL-create-psql-1.png" alt=" Windows 10下PostgreSQL语法"><br>或者在 pgAdmin 的左侧中查看，结果如下<br><img src="/assets/blogImg/Windows10-PostgreSQL-look2.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>使用pgAdmin删除数据库  test_db<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop.png" alt=" Windows 10下PostgreSQL语法"><br>右键单击数据库：test_db，左键单击delete/drop选项。将收到以下弹出框。<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-1.png" alt=" Windows 10下PostgreSQL语法"><br>点击“是(Yes)”完全删除数据库“test_db”</p><p>看到结果：<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-2.png" alt=" Windows 10下PostgreSQL语法"></p><p>在PostgreSQL中，可以使用DROP DATABASE命令删除数据库。<br>语法：</p><pre><code>DROP DATABASE database_name;</code></pre><p>这里，database_name是指定要创建的数据库的名称。</p><p>PostgreSQL使用查询工具删除数据库<br>打开SQL Shell(psql)，执行以下创建语句</p><pre><code>drop database testdb;</code></pre><p>查看数据库：</p><p><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-0.png" alt=" Windows 10下PostgreSQL语法"><br>执行语句如下<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql.png" alt=" Windows 10下PostgreSQL语法"></p><p>看到结果：<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-1.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p>在PostgreSQL中，CREATE TABLE语句用于在任何给定的数据库中创建一个新表。</p><p>语法：</p><pre><code>CREATE TABLE table_name(     column1 datatype,     column2 datatype,     column3 datatype,     .....     columnN datatype,     PRIMARY KEY( one or more columns )  );</code></pre><h3 id="UI操作-1"><a href="#UI操作-1" class="headerlink" title="UI操作"></a>UI操作</h3><ul><li>首先选择要创建表的数据库。</li><li>左键单击与所选数据库关联的框类型结构,将看到目录和模式(架构)。</li><li>左键单击与模式(架构)关联的框类型结构。现在可以看到public。</li><li>左键单击与公共(public)关联的框类型结构，就可以看到有数据表。</li><li>选择数据表，右键单击数据表，会得到一个新的弹出表框，创建所需的表。<br>参见示例：<br>创建test_db2数据库，然后创建表:student<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-2.png" alt=" Windows 10下PostgreSQL语法"><br>添加数据<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-3.png" alt=" Windows 10下PostgreSQL语法"></li></ul><p>查看SQL脚本<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-4.png" alt=" Windows 10下PostgreSQL语法"></p><h3 id="命令操作-1"><a href="#命令操作-1" class="headerlink" title="命令操作"></a>命令操作</h3><p>PostgreSQL使用SQL命令创建表：student2<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-5.png" alt=" Windows 10下PostgreSQL语法"><br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-6.png" alt=" Windows 10下PostgreSQL语法"><br>查看所创表格：<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-7.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="删除表格"><a href="#删除表格" class="headerlink" title="删除表格"></a>删除表格</h2><h3 id="UI操作-2"><a href="#UI操作-2" class="headerlink" title="UI操作"></a>UI操作</h3><p>右键单击所选表，这里选择表为：student2。<br>找到表并选择点击完成。<br>现在应该会看到这样的：<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-8.png" alt=" Windows 10下PostgreSQL语法"><br>点击确定(OK),则该表被删除。<br><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-9.png" alt=" Windows 10下PostgreSQL语法"><br>现在可以看到没有那个student2的表了。</p><h3 id="命令操作-2"><a href="#命令操作-2" class="headerlink" title="命令操作"></a>命令操作</h3><p><img src="/assets/blogImg/Windows10-PostgreSQL-drop-psql-10.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>在PostgreSQL中，INSERT查询用于在表中插入新行。 您可以一次插入单行或多行到表中。</p><p>语法：</p><pre><code>INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)  VALUES (value1, value2, value3,...valueN);</code></pre><p>注意：column1, column2, column3,…columnN是要插入数据的表中的列的名称。</p><h3 id="UI操作-3"><a href="#UI操作-3" class="headerlink" title="UI操作"></a>UI操作</h3><p><img src="/assets/blogImg/Windows10-PostgreSQL-insert0.png" alt=" Windows 10下PostgreSQL语法"></p><h3 id="命令操作-3"><a href="#命令操作-3" class="headerlink" title="命令操作"></a>命令操作</h3><p><img src="/assets/blogImg/Windows10-PostgreSQL-insert.png" alt=" Windows 10下PostgreSQL语法"><br>操作成功<br><img src="/assets/blogImg/Windows10-PostgreSQL-insert2.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>在PostgreSQL中，SELECT语句用于从数据库表中检索数据。 数据以结果表格的形式返回。 这些结果表称为结果集。</p><p>语法：</p><pre><code>SELECT &quot;column1&quot;, &quot;column2&quot;..&quot;column&quot; FROM &quot;table_name&quot;;</code></pre><p>这里，column1，column2，.. columnN指定检索哪些数据的列。 如果要从表中检索所有字段，则必须使用以下语法：</p><pre><code>SELECT * FROM &quot;table_name&quot;;</code></pre><p>使用SQL语句操作：<br><img src="/assets/blogImg/Windows10-PostgreSQL-select.png" alt=" Windows 10下PostgreSQL语法"><br>操作成功<br><img src="/assets/blogImg/Windows10-PostgreSQL-select2.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>在PostgreSQL中，UPDATE语句用于修改表中现有的记录。 要更新所选行，您必须使用WHERE子句，否则将更新所有行。</p><p>语法：</p><p>以下是update语句的基本语法：</p><pre><code>UPDATE table_name  SET column1 = value1, column2 = value2...., columnN = valueN  WHERE [condition];</code></pre><p>使用SQL语句操作：<br><img src="/assets/blogImg/Windows10-PostgreSQL-update.png" alt=" Windows 10下PostgreSQL语法"><br>操作成功<br><img src="/assets/blogImg/Windows10-PostgreSQL-update1.png" alt=" Windows 10下PostgreSQL语法"></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>DELETE语句用于从表中删除现有记录。 “WHERE”子句用于指定删除所选记录的条件，如是不指定条件则将删除所有记录。</p><p>语法：</p><p>以下是DELETE语句的基本语法：</p><pre><code>DELETE FROM table_name  WHERE [condition];</code></pre><p>使用SQL语句操作：<br><img src="/assets/blogImg/Windows10-PostgreSQL-delete.png" alt=" Windows 10下PostgreSQL语法"><br>操作成功<br><img src="/assets/blogImg/Windows10-PostgreSQL-delete2.png" alt=" Windows 10下PostgreSQL语法"></p><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><ul><li>PostgreSQL的语法和其它数据库语法基本一样，可以说，几乎所有的数据库语法都是通用的</li><li>使用SQL脚本方便了数据表格的创建，可以跨平台使用，从而使得数据库迁移变得较为方便</li></ul><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06-参考资料"></a>0x06-参考资料</h1><ul><li><a href="https://www.postgresql.org/docs/10/static/index.html" target="_blank" rel="noopener">PostgreSQL文档</a></li><li><a href="https://www.yiibai.com/postgresql/" target="_blank" rel="noopener">PostgreSQL教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PostgreSQL语法学习&quot;&gt;&lt;a href=&quot;#PostgreSQL语法学习&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL语法学习&quot;&gt;&lt;/a&gt;PostgreSQL语法学习&lt;/h1&gt;&lt;h3 id=&quot;2018-7-16-2018-7-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/29/PostgreSQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/29/PostgreSQL环境搭建/</id>
    <published>2018-07-29T07:18:26.148Z</published>
    <updated>2018-08-10T02:28:01.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL环境搭建"><a href="#PostgreSQL环境搭建" class="headerlink" title="PostgreSQL环境搭建"></a>PostgreSQL环境搭建</h1><h3 id="2018-7-9-2018-7-16"><a href="#2018-7-9-2018-7-16" class="headerlink" title="2018-7-9~2018-7-16"></a>2018-7-9~2018-7-16</h3><h2 id="标签：-实习-PostgreSQL"><a href="#标签：-实习-PostgreSQL" class="headerlink" title="标签： 实习 PostgreSQL"></a>标签： 实习 PostgreSQL</h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><ul><li>熟悉数据库设计基本原理，安装数据库开发环境</li><li>了解PostgreSQL的特点及工具，为后期项目开发做准备</li></ul><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><ul><li>对于规范开发具有参考意义</li><li>有利于对PostgreSQL的理解</li></ul><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h2><p>是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序共享。数据库存放数据是按数据所提供的数据模式存放的，具有集成与共享的特点。</p><h2 id="PostgreSQL简介"><a href="#PostgreSQL简介" class="headerlink" title="PostgreSQL简介"></a>PostgreSQL简介</h2><h3 id="PostgreSQL是什么"><a href="#PostgreSQL是什么" class="headerlink" title="PostgreSQL是什么"></a>PostgreSQL是什么</h3><p>PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。 它是开源的，其源代码是免费提供的。PostgreSQL是跨平台的，可以在许多操作系统上运行，如Linux，FreeBSD，OS X，Solaris和Microsoft Windows等。自从MySQL被Oracle收购以后，PostgreSQL逐渐成为开源关系型数据库的首选。</p><h3 id="PostgreSQL的历史"><a href="#PostgreSQL的历史" class="headerlink" title="PostgreSQL的历史"></a>PostgreSQL的历史</h3><p>PostgreSQL由计算机科学教授Michael Stonebraker在UCB创建。 它最初叫做Postgres。 1986年由Michael Stonebraker教授作为后续项目和Ingres项目启动，克服了当代数据库系统的问题。 PostgreSQL现在是任何地方都很先进的开源数据库。</p><h3 id="PostgreSQL的特点"><a href="#PostgreSQL的特点" class="headerlink" title="PostgreSQL的特点"></a>PostgreSQL的特点</h3><p>PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。</p><p>PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。</p><p>PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。</p><p>在PostgreSQL中，表可以设置为从“父”表继承其特征。</p><p>可以安装多个扩展以向PostgreSQL添加附加功能。</p><h3 id="PostgreSQL的工具"><a href="#PostgreSQL的工具" class="headerlink" title="PostgreSQL的工具"></a>PostgreSQL的工具</h3><p>有一些开放源码以及付费工具可用作PostgreSQL的前端工具。 这里列出几个被广泛使用的工具：</p><ol><li>psql：<br>它是一个命令行工具，也是管理PostgreSQL的主要工具。 pgAdmin是PostgreSQL的免费开源图形用户界面管理工具。</li><li>phpPgAdmin:<br>它是用PHP编写的PostgreSQL的基于Web的管理工具。 它基于phpMyAdmin工具管理MySQL功能来开发。它可以用作PostgreSQL的前端工具。</li><li>pgFouine：<br>它是一个日志分析器，可以从PostgreSQL日志文件创建报告。 </li></ol><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>处理器：i7</li><li>内存：8G</li><li>显示器：VGA 或更高</li><li>硬盘空间：128G<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2></li><li>Windows 10系统</li><li>Debian 9系统</li></ul><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="图形安装"><a href="#图形安装" class="headerlink" title="图形安装"></a>图形安装</h2><p>使用鼠标操作完成安装（适用于Windows 10系统）</p><h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><p>使用shell命令完成安装（适用于Debian 9系统）</p><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h3 id="Windows-10下图形安装"><a href="#Windows-10下图形安装" class="headerlink" title="Windows 10下图形安装"></a>Windows 10下图形安装</h3><ol><li>选择合适的PostgreSQL的版本号以及对应系统，并从这里下载并下载：<a href="http://www.enterprisedb.com/products-services-training/pgdownload#windows" target="_blank" rel="noopener">http://www.enterprisedb.com/products-services-training/pgdownload#windows</a><br>由于我的系统是 Windows 10 64位，所以选择以下对应的版本 -</li></ol><ul><li>PostgreSQL 10.4</li><li>Windows x86-64<br><img src="/assets/blogImg/windows10-graph.png" alt=" Windows 10下图形安装"></li></ul><ol start="2"><li>以管理员身份运行下载的postgresql-10.4-1-windows-x64来安装PostgreSQL。<br><img src="/assets/blogImg/windows10-graph-2.png" alt=" Windows 10下图形安装"></li><li>与安装其它软件一样，没有什么特别之处，选择下一步就好。<br><img src="/assets/blogImg/windows10-graph-3.png" alt=" Windows 10下图形安装"></li><li>选择要安装的位置。 默认情况下，它安装在程序文件夹(C:\Program File)中。<br><img src="/assets/blogImg/windows10-graph-4.png" alt=" Windows 10下图形安装"></li><li>设置将要求您输入密码，因此请您输入密码，这里我输入的密码是：password。<br><img src="/assets/blogImg/windows10-graph-5.png" alt=" Windows 10下图形安装"></li><li>设置PostgreSQL服务器的端口，保持默认，点击下一步。<br><img src="/assets/blogImg/windows10-graph-6.png" alt=" Windows 10下图形安装"></li><li>安装过程就绪。完成安装过程需要一些时间。 完成安装过程后，您将看到以下屏幕<br><img src="/assets/blogImg/windows10-graph-7.png" alt=" Windows 10下图形安装"><br>取消选中复选框按钮，然后单击完成按钮完成安装。<h3 id="Debian-9下命令安装"><a href="#Debian-9下命令安装" class="headerlink" title="Debian 9下命令安装"></a>Debian 9下命令安装</h3>以root用户进行安装：<br> root@bogon:/home/debian/Downloads# apt-get install postgres<br><img src="/assets/blogImg/Debian9-graph.png" alt=" Debian下命令安装"><br> root@bogon:/home/debian/Downloads# apt-get install pgadmin3<br>安装pgadmin（以pgAdmin3为例）<br><img src="/assets/blogImg/Debian9-graph2.png" alt=" Debian下命令安装"><h2 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h2><h3 id="Windows-10下图形安装-1"><a href="#Windows-10下图形安装-1" class="headerlink" title="Windows 10下图形安装"></a>Windows 10下图形安装</h3>在开始菜单点击SQL Shell (psql)，输入相关信息即可启动数据库。<br><img src="/assets/blogImg/windows10-graph-8.png" alt=" Windows 10下图形安装"><br><img src="/assets/blogImg/windows10-graph-9.png" alt=" Windows 10下图形安装"><br>安装成功！<h3 id="Debian-9下命令安装-1"><a href="#Debian-9下命令安装-1" class="headerlink" title="Debian 9下命令安装"></a>Debian 9下命令安装</h3><img src="/assets/blogImg/Debian9-graph-1.png" alt=" Debian下命令安装"><br><img src="/assets/blogImg/Debian9-graph3.png" alt=" Debian下命令安装"><br>安装成功！<h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1></li></ol><ul><li>PostgreSQL兼容性强，可以跨平台使用</li><li>PostgreSQL安装过程较为简单，环境搭建较为方便</li></ul><h1 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06-参考资料"></a>0x06-参考资料</h1><ul><li><a href="https://www.postgresql.org/docs/10/static/index.html" target="_blank" rel="noopener">PostgreSQL文档</a></li><li><a href="https://www.yiibai.com/postgresql/" target="_blank" rel="noopener">PostgreSQL教程</a></li><li><a href="https://blog.csdn.net/wangyezi19930928/article/details/11990279" target="_blank" rel="noopener">PostgreSQL在debian下安装、使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PostgreSQL环境搭建&quot;&gt;&lt;a href=&quot;#PostgreSQL环境搭建&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL环境搭建&quot;&gt;&lt;/a&gt;PostgreSQL环境搭建&lt;/h1&gt;&lt;h3 id=&quot;2018-7-9-2018-7-1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/29/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2018/07/29/项目模板/</id>
    <published>2018-07-29T03:26:50.957Z</published>
    <updated>2018-07-31T10:24:26.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h1><h3 id="日期1-日期2"><a href="#日期1-日期2" class="headerlink" title="日期1~日期2"></a>日期1~日期2</h3><h2 id="标签：-模板"><a href="#标签：-模板" class="headerlink" title="标签： 模板 "></a>标签： 模板 </h2><blockquote><ul><li>0x00-项目背景</li><li>0x01-技能储备</li><li>0x02-开发环境</li><li>0x03-方案设计</li><li>0x04-测试验证</li><li>0x05-调试优化</li><li>0x06-项目源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-项目背景"><a href="#0x00-项目背景" class="headerlink" title="0x00-项目背景"></a>0x00-项目背景</h1><h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p>AI操作系统，以01为基因，内核为灵魂，</p><h2 id="项目前景"><a href="#项目前景" class="headerlink" title="项目前景"></a>项目前景</h2><h1 id="0x01-技能储备"><a href="#0x01-技能储备" class="headerlink" title="0x01-技能储备"></a>0x01-技能储备</h1><h2 id="Linux内核开发经验"><a href="#Linux内核开发经验" class="headerlink" title="Linux内核开发经验"></a>Linux内核开发经验</h2><h2 id="人工智能开发经验"><a href="#人工智能开发经验" class="headerlink" title="人工智能开发经验"></a>人工智能开发经验</h2><h2 id="数据分析开发经验"><a href="#数据分析开发经验" class="headerlink" title="数据分析开发经验"></a>数据分析开发经验</h2><h2 id="Linux基本操作"><a href="#Linux基本操作" class="headerlink" title="Linux基本操作"></a>Linux基本操作</h2><h1 id="0x02-开发环境"><a href="#0x02-开发环境" class="headerlink" title="0x02-开发环境"></a>0x02-开发环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><p>复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。</p><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-测试验证"><a href="#0x04-测试验证" class="headerlink" title="0x04-测试验证"></a>0x04-测试验证</h1><h2 id="测试操作"><a href="#测试操作" class="headerlink" title="测试操作"></a>测试操作</h2><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><h1 id="0x05-调试优化（折中与平衡）"><a href="#0x05-调试优化（折中与平衡）" class="headerlink" title="0x05-调试优化（折中与平衡）"></a>0x05-调试优化（折中与平衡）</h1><h2 id="用户体验："><a href="#用户体验：" class="headerlink" title="用户体验："></a>用户体验：</h2><h2 id="应用性能："><a href="#应用性能：" class="headerlink" title="应用性能："></a>应用性能：</h2><h1 id="0x06-项目源码"><a href="#0x06-项目源码" class="headerlink" title="0x06-项目源码"></a>0x06-项目源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目模板&quot;&gt;&lt;a href=&quot;#项目模板&quot; class=&quot;headerlink&quot; title=&quot;项目模板&quot;&gt;&lt;/a&gt;项目模板&lt;/h1&gt;&lt;h3 id=&quot;日期1-日期2&quot;&gt;&lt;a href=&quot;#日期1-日期2&quot; class=&quot;headerlink&quot; title=&quot;日期1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/29/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2018/07/29/博客模板/</id>
    <published>2018-07-29T03:23:23.541Z</published>
    <updated>2018-08-03T10:24:03.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客模板"><a href="#博客模板" class="headerlink" title="博客模板"></a>博客模板</h1><h3 id="日期1-日期2"><a href="#日期1-日期2" class="headerlink" title="日期1~日期2"></a>日期1~日期2</h3><h2 id="标签：-模板"><a href="#标签：-模板" class="headerlink" title="标签： 模板 "></a>标签： 模板 </h2><blockquote><ul><li>0x00-文章前言</li><li>0x01-知识储备</li><li>0x02-测试环境</li><li>0x03-方案设计</li><li>0x04-实践验证</li><li>0x05-总结分析</li><li>0x06-程序源码</li><li>0x07-参考资料</li></ul></blockquote><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00-文章前言"></a>0x00-文章前言</h1><h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><h2 id="文章前景"><a href="#文章前景" class="headerlink" title="文章前景"></a>文章前景</h2><h1 id="0x01-知识储备"><a href="#0x01-知识储备" class="headerlink" title="0x01-知识储备"></a>0x01-知识储备</h1><h2 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><h2 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h2><h1 id="0x02-测试环境"><a href="#0x02-测试环境" class="headerlink" title="0x02-测试环境"></a>0x02-测试环境</h1><h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h1 id="0x03-方案设计"><a href="#0x03-方案设计" class="headerlink" title="0x03-方案设计"></a>0x03-方案设计</h1><h2 id="方案A"><a href="#方案A" class="headerlink" title="方案A"></a>方案A</h2><h2 id="方案B"><a href="#方案B" class="headerlink" title="方案B"></a>方案B</h2><h1 id="0x04-实践验证"><a href="#0x04-实践验证" class="headerlink" title="0x04-实践验证"></a>0x04-实践验证</h1><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h2 id="实践结果"><a href="#实践结果" class="headerlink" title="实践结果"></a>实践结果</h2><h1 id="0x05-总结分析"><a href="#0x05-总结分析" class="headerlink" title="0x05-总结分析"></a>0x05-总结分析</h1><h2 id="文章结论"><a href="#文章结论" class="headerlink" title="文章结论"></a>文章结论</h2><h2 id="文章分析"><a href="#文章分析" class="headerlink" title="文章分析"></a>文章分析</h2><h1 id="0x06-程序源码"><a href="#0x06-程序源码" class="headerlink" title="0x06-程序源码"></a>0x06-程序源码</h1><h2 id="代码A"><a href="#代码A" class="headerlink" title="代码A"></a>代码A</h2><h2 id="代码B"><a href="#代码B" class="headerlink" title="代码B"></a>代码B</h2><h1 id="0x07-参考资料"><a href="#0x07-参考资料" class="headerlink" title="0x07-参考资料"></a>0x07-参考资料</h1><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li><li><a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></li></ul><p>截图时间点（I/O）：</p><p>输入：命令、按钮</p><p>输出：变化、结果</p><p>——&gt;I/O截图法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;博客模板&quot;&gt;&lt;a href=&quot;#博客模板&quot; class=&quot;headerlink&quot; title=&quot;博客模板&quot;&gt;&lt;/a&gt;博客模板&lt;/h1&gt;&lt;h3 id=&quot;日期1-日期2&quot;&gt;&lt;a href=&quot;#日期1-日期2&quot; class=&quot;headerlink&quot; title=&quot;日期1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E5%90%91/"/>
    <id>http://yoursite.com/2018/07/29/数据库方向/</id>
    <published>2018-07-29T01:53:31.708Z</published>
    <updated>2018-07-30T10:44:07.866Z</updated>
    
    <content type="html"><![CDATA[<p>2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境<br>PostgreSQL环境搭建:原理、安装</p><p>2018/7/16    熟悉数据库操作基本流程、数据操作命令、编程接口<br>PostgreSQL语法学习：操作教程、命令语法、编程接口</p><p>2018/7/23    研究HTML界面开发框架数据库操作以及相关开发语言<br>前端学习：Electron开源库+blur-admin响应式模板学习、安装、介绍、接口</p><p>2018/7/30    分析应用场景（场景1：日志分析）数据操作以及数据展示要求，设计数据库表、字段，设计服务程序，创造数据，写入数据库<br>表格创建：应用场景</p><p>2018/8/6    应用场景1：日志分析 中展示要求1，2 界面框架数据库查询接口<br>PostgreSQL连接接口（一）：实现</p><p>2018/8/13    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版以及查询接口”<br>自测功能（一）：</p><p>2018/8/20    应用场景1：日志分析 中展示要求3 界面框架数据库查询接口<br>PostgreSQL接口封装（二）：封装</p><p>2018/8/27    “自测功能（包括查询性能），并优化数据库表设计。<br>打包，提供测试版、更新查询接口”<br>自测功能（二）：</p><p>2018/9/3    配合HTML界面调试<br>全栈调试（一）：</p><p>2018/9/10    配合HTML界面调试<br>全栈调试（二）：</p><p>2018/9/17    测试、优化<br>测试优化（一）：</p><p>2018/9/24    测试、优化<br>测试优化（二）：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018/7/9    熟悉数据库设计基本原理，安装数据库开发环境&lt;br&gt;PostgreSQL环境搭建:原理、安装&lt;/p&gt;
&lt;p&gt;2018/7/16    熟悉数据库操作基本流程、数据操作命令、编程接口&lt;br&gt;PostgreSQL语法学习：操作教程、命令语法、编程接口&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/14/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90-%E5%AD%9F%E5%AE%81/"/>
    <id>http://yoursite.com/2018/06/14/Linux内核分析-孟宁/</id>
    <published>2018-06-14T00:15:42.945Z</published>
    <updated>2018-06-14T00:15:42.945Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/05/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/05/JavaScript笔记/</id>
    <published>2018-06-05T09:01:21.856Z</published>
    <updated>2018-06-05T09:36:38.231Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript笔记</p><ul><li>在 JavaScript 中，用分号来结束语句是可选的。</li><li>块的作用是使语句序列一起执行。</li><li>反斜杠对代码行进行换行</li><li>JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等</li><li>如果把数字与字符串相加，结果将成为字符串。</li><li>JavaScript 库常被称为 JavaScript 框架：jQuery、Prototype、MooTools</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript笔记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JavaScript 中，用分号来结束语句是可选的。&lt;/li&gt;
&lt;li&gt;块的作用是使语句序列一起执行。&lt;/li&gt;
&lt;li&gt;反斜杠对代码行进行换行&lt;/li&gt;
&lt;li&gt;JavaScript 中的所有事物都是对象：字符串、数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/05/JavaScript%20%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/05/JavaScript 教程/</id>
    <published>2018-06-05T08:42:17.647Z</published>
    <updated>2018-06-05T08:58:15.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h1><h2 id="JavaScript-是世界上最流行的编程语言。"><a href="#JavaScript-是世界上最流行的编程语言。" class="headerlink" title="JavaScript 是世界上最流行的编程语言。"></a>JavaScript 是世界上最流行的编程语言。</h2><p>这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</p><p>JavaScript 是脚本语言<br>JavaScript 是一种轻量级的编程语言。</p><p>JavaScript 是可插入 HTML 页面的编程代码。</p><p>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</p><p>JavaScript 很容易学习。</p><h2 id="JavaScript：写入-HTML-输出"><a href="#JavaScript：写入-HTML-输出" class="headerlink" title="JavaScript：写入 HTML 输出"></a>JavaScript：写入 HTML 输出</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code>document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;This is a paragraph&lt;/p&gt;&quot;);</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。</p><h2 id="JavaScript：对事件作出反应"><a href="#JavaScript：对事件作出反应" class="headerlink" title="JavaScript：对事件作出反应"></a>JavaScript：对事件作出反应</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><pre><code>&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;Welcome!&apos;)&quot;&gt;点击这里&lt;/button&gt;</code></pre><h3 id="亲自试一试"><a href="#亲自试一试" class="headerlink" title="亲自试一试"></a>亲自试一试</h3><p>alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</p><p>onclick 事件只是您即将在本教程中学到的众多事件之一。</p><h2 id="JavaScript：改变-HTML-内容"><a href="#JavaScript：改变-HTML-内容" class="headerlink" title="JavaScript：改变 HTML 内容"></a>JavaScript：改变 HTML 内容</h2><p>使用 JavaScript 来处理 HTML 内容是非常强大的功能。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><pre><code>x=document.getElementById(&quot;demo&quot;)  //查找元素x.innerHTML=&quot;Hello JavaScript&quot;;//改变内容</code></pre><h3 id="亲自试一试-1"><a href="#亲自试一试-1" class="headerlink" title="亲自试一试"></a>亲自试一试</h3><p>您会经常看到 document.getElementByID(“some id”)。这个方法是 HTML DOM 中定义的。</p><p>DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。</p><p>您将在本教程的多个章节中学到有关 HTML DOM 的知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-简介&quot;&gt;&lt;a href=&quot;#JavaScript-简介&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 简介&quot;&gt;&lt;/a&gt;JavaScript 简介&lt;/h1&gt;&lt;h2 id=&quot;JavaScript-是世界上最流行的编程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo主题修改</title>
    <link href="http://yoursite.com/2018/05/29/hexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2018/05/29/hexo主题修改/</id>
    <published>2018-05-29T11:48:21.000Z</published>
    <updated>2018-06-05T06:23:57.059Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/com_ma/article/details/76039859" target="_blank" rel="noopener">https://blog.csdn.net/com_ma/article/details/76039859</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/com_ma/article/details/76039859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/com_ma/article/detai
      
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>内存管理之伙伴算法</title>
    <link href="http://yoursite.com/2018/05/29/%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/29/伙伴算法/</id>
    <published>2018-05-29T11:48:21.000Z</published>
    <updated>2018-06-05T06:22:42.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buddy算法的优缺点："><a href="#Buddy算法的优缺点：" class="headerlink" title="Buddy算法的优缺点："></a>Buddy算法的优缺点：</h1><p>1）尽管伙伴内存算法在内存碎片问题上已经做的相当出色，但是该算法中，一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。</p><p>2）算法中有一定的浪费现象，伙伴算法是按2的幂次方大小进行分配内存块，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。比如原来是1024个块，申请了16个块，再申请600个块就申请不到了，因为已经被分割了。</p><p>3）另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。</p><h1 id="Buddy（伙伴的定义）："><a href="#Buddy（伙伴的定义）：" class="headerlink" title="Buddy（伙伴的定义）："></a>Buddy（伙伴的定义）：</h1><p>这里给出伙伴的概念，满足以下三个条件的称为伙伴：<br>1）两个块大小相同；<br>2）两个块地址连续；<br>3）两个块必须是同一个大块中分离出来的；</p><h1 id="Buddy算法的分配原理："><a href="#Buddy算法的分配原理：" class="headerlink" title="Buddy算法的分配原理："></a>Buddy算法的分配原理：</h1><p>假如系统需要4(22)个页面大小的内存块，该算法就到free_area[2]中查找，如果链表中有空闲块，就直接从中摘下并分配出去。如果没有，算法将顺着数组向上查找free_area[3],如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去，free_area[3]中也没有，就再向上查找，如果free_area[4]中有，就将这16(2222)个页面等分成两份，前一半挂如free_area[3]的链表头部，后一半的8个页等分成两等分，前一半挂free_area[2]<br>的链表中，后一半分配出去。假如free_area[4]也没有，则重复上面的过程，知道到达free_area数组的最后，如果还没有则放弃分配。</p><h1 id="Buddy算法的释放原理："><a href="#Buddy算法的释放原理：" class="headerlink" title="Buddy算法的释放原理："></a>Buddy算法的释放原理：</h1><p>内存的释放是分配的逆过程，也可以看作是伙伴的合并过程。当释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块(222222222个页面)。</p><p>整个过程中，位图扮演了重要的角色，如图2所示，位图的某一位对应两个互为伙伴的块，为1表示其中一块已经分配出去了，为0表示两块都空闲。伙伴中无论是分配还是释放都只是相对的位图进行异或操作。分配内存时对位图的<br>是为释放过程服务，释放过程根据位图判断伙伴是否存在，如果对相应位的异或操作得1，则没有伙伴可以合并，如果异或操作得0，就进行合并，并且继续按这种方式合并伙伴，直到不能合并为止。</p><h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><h1 id="心得体会-："><a href="#心得体会-：" class="headerlink" title="心得体会 #："></a>心得体会 #：</h1><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>Github：<a href="https://github.com/hurley25/hurlex-II/blob/master/mm/buddy_mm.c" target="_blank" rel="noopener">https://github.com/hurley25/hurlex-II/blob/master/mm/buddy_mm.c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Buddy算法的优缺点：&quot;&gt;&lt;a href=&quot;#Buddy算法的优缺点：&quot; class=&quot;headerlink&quot; title=&quot;Buddy算法的优缺点：&quot;&gt;&lt;/a&gt;Buddy算法的优缺点：&lt;/h1&gt;&lt;p&gt;1）尽管伙伴内存算法在内存碎片问题上已经做的相当出色，但是该
      
    
    </summary>
    
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>实验-内存管理(FF、BF、WF)</title>
    <link href="http://yoursite.com/2018/05/28/%E5%AE%9E%E9%AA%8C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/28/实验-内存管理/</id>
    <published>2018-05-28T01:48:11.000Z</published>
    <updated>2018-06-05T06:11:47.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-实验目的及实验环境"><a href="#一-实验目的及实验环境" class="headerlink" title="一. 实验目的及实验环境"></a>一. 实验目的及实验环境</h1><h2 id="一-、实验环境"><a href="#一-、实验环境" class="headerlink" title="(一)、实验环境"></a>(一)、实验环境</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>处理器：i7；<br>内存：8G；<br>显示器：VGA 或更高；<br>硬盘空间：128G。</p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>Centos 7下gcc编译器、gdb调试工具。</p><h2 id="二-、实验目的"><a href="#二-、实验目的" class="headerlink" title="(二)、实验目的"></a>(二)、实验目的</h2><ol><li>掌握内存分配FF，BF，WF策略及实现的思路；</li><li>掌握内存回收过程及实现思路；</li><li>参考本程序思路，实现内存的申请、释放的管理程序，调试运行，总结程序设计中出现的问题并找出原因。<h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1></li><li>补充完整FF，BF，WF等算法的代码；</li><li>掌握内存回收过程及实现思路；</li><li>实现内存的申请和释放。<h1 id="三．方案设计"><a href="#三．方案设计" class="headerlink" title="三．方案设计"></a>三．方案设计</h1><h2 id="一-、实现功能"><a href="#一-、实现功能" class="headerlink" title="(一)、实现功能"></a>(一)、实现功能</h2></li><li>Set memory size (default=1024)</li><li>Select memory allocation algorithm</li><li>New process</li><li>Terminate a process</li><li>Display memory usage</li><li>Exit<h2 id="二-、关键算法思想设计与分析"><a href="#二-、关键算法思想设计与分析" class="headerlink" title="(二)、关键算法思想设计与分析"></a>(二)、关键算法思想设计与分析</h2><h3 id="首次适应算法（First-Fit）"><a href="#首次适应算法（First-Fit）" class="headerlink" title="首次适应算法（First Fit）"></a>首次适应算法（First Fit）</h3>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</li></ol><h3 id="最佳适应算法（Best-Fit）"><a href="#最佳适应算法（Best-Fit）" class="headerlink" title="最佳适应算法（Best Fit）"></a>最佳适应算法（Best Fit）</h3><p>它从全部空闲区中找出能满足作业要求的、 且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分 区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到 第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的 空闲区。</p><h3 id="最差适应算法（Worst-Fit）"><a href="#最差适应算法（Worst-Fit）" class="headerlink" title="最差适应算法（Worst Fit）"></a>最差适应算法（Worst Fit）</h3><p>它从全部空闲区中找出能满足作业要求的、 且大小最大的空闲分区，从而使链表中的结点大小趋于均匀，适用于请求分 配的内存大小范围较窄的系统。为适应此算法，空闲分区表（空闲区链）中 的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求<br>的自由分区分配。该算法保留小的空闲区，尽量减少小的碎片产生。</p><h1 id="四．测试数据及运行结果"><a href="#四．测试数据及运行结果" class="headerlink" title="四．测试数据及运行结果"></a>四．测试数据及运行结果</h1><ol><li>设置内存大小</li><li>选择算法</li><li>创建进程</li><li>选择杀死进程</li><li>查看内存以及进程<br>退出程序并释放内存空间<h1 id="五．总结"><a href="#五．总结" class="headerlink" title="五．总结"></a>五．总结</h1>这次实验刚开始的时候不知道整个实验的思路，还好老师在课堂上大概讲解了一下，并且给出了大部分代码，剩下的工作就是填写部分代码，这样实验就简单多了。通过本次的内存实验我了解到了内存的管理模型的知识，在内存紧缩合并回收部分还遇到了一些问题，最终通过查资料解决了问题，虽然对内存的管理掌握得不是很熟练，但这激励了我下来后看书，努力学习不懂的知识，通过让我对其有了更加深入的了解，让我认识到了，操作系统是一项真正实用，而且很有意义的学科，增加了我对操作系统的兴趣，也为以后的学习打下理论基础。</li></ol><h1 id="六-源代码"><a href="#六-源代码" class="headerlink" title="六. 源代码"></a>六. 源代码</h1><pre><code>#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define PROCESS_NAME_LEN 32   //进程名长度#define MIN_SLICE10 //最小碎片的大小#define DEFAULT_MEM_SIZE 1024//内存大小#define DEFAULT_MEM_START 0 //起始位置/*内存分配算法*/#define MA_FF 1#define MA_BF 2#define MA_WF 3/*描述每一个空闲块的数据结构*/struct free_block_type{int size;//空闲块大小int start_addr;//空闲块起始地址struct free_block_type *next;//指向下一个空闲块};/*指向内存中空闲块链表的首指针*/struct free_block_type *free_block = NULL;/*每个进程分配到的内存块的描述*/struct allocated_block{int pid;//进程标识符int size;//进程大小int start_addr;//进程分配到的内存块的起始地址char process_name[PROCESS_NAME_LEN];//进程名struct allocated_block *next;//指向下一个进程控制块};/*进程分配内存块链表的首指针*/struct allocated_block *allocated_block_head = NULL;int free_block_count = 0;//空闲块个数int mem_size = DEFAULT_MEM_SIZE; //内存大小int current_free_mem_size = 0;//当前空闲内存大小int ma_algorithm = MA_FF;   //当前分配算法static int pid = 0; //初始PIDint flag = 0;//设置内存大小标志,表示内存大小是否设置/*函数声明*/struct free_block_type* init_free_block(int mem_size);void display_menu();int set_mem_size();void set_algorithm();void rearrange(int algorithm);int rearrange_WF();int rearrange_BF();int rearrange_FF();int new_process();int allocate_mem(struct allocated_block *ab);void kill_process();int free_mem(struct allocated_block *ab);int dispose(struct allocated_block *free_ab);int display_mem_usage();struct allocated_block *find_process(int pid);int do_exit();int allocate_FF(struct allocated_block *ab);int allocate_BF(struct allocated_block *ab);int allocate_WF(struct allocated_block *ab);int allocate(struct free_block_type *pre, struct free_block_type *allocate_free_nlock, struct allocated_block *ab);int mem_retrench(struct allocated_block *ab);//  通过内存紧缩技术给新进程分配内存空间int mem_retrench(struct allocated_block *ab){struct allocated_block *allocated_work, *allocated_pre = allocated_block_head;struct free_block_type *free_work, *free_pre = free_block-&gt;next;if(allocated_pre == NULL)return -1;allocated_pre-&gt;start_addr = 0;allocated_work = allocated_pre-&gt;next;while(allocated_work != NULL){allocated_work-&gt;start_addr = allocated_pre-&gt;start_addr + allocated_pre-&gt;size;allocated_pre = allocated_work;allocated_work = allocated_work-&gt;next;}free_block-&gt;start_addr = allocated_pre-&gt;start_addr + allocated_pre-&gt;size;free_block-&gt;size = current_free_mem_size;free_block-&gt;next = NULL;free_work = free_pre;while(free_pre != NULL){free(free_pre);free_pre = free_work;if(free_pre != NULL)free_work = free_work-&gt;next;}allocate(NULL, free_block, ab);return 1;}// 给新进程分配内存空间 int allocate(struct free_block_type *pre, struct free_block_type *allocate_free_block, struct allocated_block *ab){struct allocated_block *p = allocated_block_head;ab-&gt;start_addr = allocate_free_block-&gt;start_addr;if(allocate_free_block-&gt;size - ab-&gt;size &lt; MIN_SLICE){ab-&gt;size = allocate_free_block-&gt;size;if(pre != NULL){pre-&gt;next = allocate_free_block;}else{free_block = allocate_free_block-&gt;next;}free(allocate_free_block);}else{allocate_free_block-&gt;start_addr += ab-&gt;size;allocate_free_block-&gt;size -=  ab-&gt;size;}if(p == NULL){allocated_block_head = ab;}else{while(p-&gt;next != NULL)p = p-&gt;next;p-&gt;next = ab;}current_free_mem_size -= ab-&gt;size;if(current_free_mem_size == 0)free_block = NULL;return 0;}//按照最坏适应算法给新进程分配内存空间int allocate_WF(struct allocated_block *ab){int ret;struct free_block_type *wf = free_block;if(wf == NULL)return -1;if(wf-&gt;size &gt;= ab-&gt;size)allocate(NULL, wf, ab);else if(current_free_mem_size &gt;= ab-&gt;size)ret = mem_retrench(ab);elseret = -2;rearrange_WF();return ret;}// 按照最佳适应算法给新进程分配内存空间int allocate_BF(struct allocated_block *ab){int ret;struct free_block_type *pre = NULL, *bf = free_block;if(bf == NULL)return -1;while(bf != NULL){if(bf-&gt;size &gt;= ab-&gt;size){ret = allocate(pre, bf,ab);break;}pre = bf;pre = pre-&gt;next;}if(bf == NULL &amp;&amp; current_free_mem_size &gt; ab-&gt;size)ret = mem_retrench(ab);elseret = -2;rearrange_BF();return ret;}// 按照首次适应算法给新进程分配内存空间int allocate_FF(struct allocated_block *ab){int ret;struct free_block_type *pre = NULL, *ff = free_block;if(ff == NULL)return -1;while(ff != NULL){if(ff-&gt;size &gt;= ab-&gt;size){ret = allocate(pre, ff,ab);break;}pre = ff;pre = pre-&gt;next;}if(ff == NULL &amp;&amp; current_free_mem_size &gt; ab-&gt;size)ret = mem_retrench(ab);elseret = -2;rearrange_FF();return ret;}//分配内存模块int allocate_mem(struct allocated_block *ab){int ret ;struct free_block_type *fbt, *pre;int request_size = ab-&gt;size;fbt = pre = free_block;switch(ma_algorithm){case MA_FF :ret = allocate_FF(ab);break;case MA_BF :ret = allocate_BF(ab);break;case MA_WF :ret = allocate_WF(ab);break;default :break;}return ret;}// 创建一个新的进程。int new_process(){struct allocated_block *ab;int size;int ret;ab = (struct allocated_block *)malloc(sizeof(struct allocated_block));if(!ab)exit(-5);ab-&gt;next = NULL;pid++;sprintf(ab-&gt;process_name, &quot;PROCESS-%02d&quot;, pid);//sprintf()函数将格式化的数据写入某字符串中ab-&gt;pid = pid;printf(&quot;Memory for %s:&quot;, ab-&gt;process_name);for(; ; ){scanf(&quot;%d&quot;, &amp;size);getchar();if(size &gt; 0){ab-&gt;size = size;break;}elseprintf(&quot;The size have to greater than zero! Please input again!&quot;);}ret = allocate_mem(ab);  //从空闲区分配内存，ret==1表示分配okif((ret == 1) &amp;&amp; (allocated_block_head == NULL))//如果此时allocated_block_head尚未赋值，则赋值{ //进程分配链表为空allocated_block_head = ab;return 1;}else if(ret == 1) //分配成功，将该已分配块的描述插入已分配链表{ab-&gt;next = allocated_block_head;//头插法allocated_block_head = ab;return 2;}else if(ret == -1) //分配不成功{printf(&quot;Allocation fail\n&quot;);free(ab);return -1;   }return 3;}//退出程序并释放内存空间。int do_exit(){struct allocated_block *allocated_ab, *allocated_pre;struct free_block_type *free_ab, *free_pre;free_pre = free_block;allocated_pre = allocated_block_head;if(free_pre != NULL){free_ab = free_pre-&gt;next;while(free_ab != NULL){free(free_pre);free_pre = free_ab;free_ab = free_ab-&gt;next;}}if(allocated_pre != NULL){allocated_ab = allocated_pre-&gt;next;while(allocated_ab != NULL){free(allocated_pre);allocated_pre = allocated_ab;allocated_ab = allocated_ab-&gt;next;}}allocated_ab = allocated_ab-&gt;next;return 0;}//在进程分配链表中寻找指定进程。struct allocated_block *find_process(int pid){struct allocated_block *ab = allocated_block_head;if(ab == NULL){printf(&quot;Here??????111111111\n&quot;);return NULL;}while(ab-&gt;pid != pid &amp;&amp; ab-&gt;next != NULL)ab = ab-&gt;next;if(ab-&gt;next == NULL &amp;&amp; ab-&gt;pid != pid){printf(&quot;Here??????2222222\n&quot;);return NULL;}return ab;}//显示当前内存的使用情况，包括空闲区的情况和已经分配的情况。int display_mem_usage(){struct free_block_type *fbt = free_block;struct allocated_block *ab = allocated_block_head;printf(&quot;----------------------------------------------------------\n&quot;);//显示空闲区printf(&quot;Free Memory:\n&quot;);printf(&quot;%20s %20s\n&quot;, &quot;  start_addr&quot;, &quot;   size&quot;);while(fbt != NULL){printf(&quot;%20d %20d\n&quot;, fbt-&gt;start_addr, fbt-&gt;size);fbt = fbt-&gt;next;}//显示已分配区printf(&quot;\nUsed Memory:\n&quot;);printf(&quot;%10s %20s %10s %10s\n&quot;, &quot;PID&quot;, &quot;ProcessName&quot;, &quot;start_addr&quot;, &quot; size&quot;);while(ab != NULL){printf(&quot;%10d %20s %10d %10d\n&quot;, ab-&gt;pid, ab-&gt;process_name, ab-&gt;start_addr, ab-&gt;size);ab = ab-&gt;next;}printf(&quot;----------------------------------------------------------\n&quot;);return 1;}// 释放ab数据结构节点。int dispose(struct allocated_block *free_ab){struct allocated_block *pre, *ab;if(free_block == NULL)return -1;if(free_ab == allocated_block_head)//如果要释放第一个节点{allocated_block_head = allocated_block_head-&gt;next;free(free_ab);}else{pre = allocated_block_head;  ab = allocated_block_head-&gt;next;//找到free_abwhile(ab != free_ab){pre = ab;ab = ab-&gt;next;}pre-&gt;next = ab-&gt;next;free(ab);}return 1;}/*将ab所表示的已分配区归还，并进行可能的合并*/int free_mem(struct allocated_block *ab){int algorithm = ma_algorithm;struct free_block_type *fbt, *pre, *work;fbt = (struct free_block_type*)malloc(sizeof(struct free_block_type));if(!fbt)return -1;pre = free_block;fbt-&gt;start_addr = ab-&gt;start_addr;fbt-&gt;size = ab-&gt;size;fbt-&gt;next = NULL;if(pre != NULL){while(pre-&gt;next != NULL)pre = pre-&gt;next;pre-&gt;next = fbt;}else{free_block = fbt;}rearrange_FF();pre = free_block;work = pre-&gt;next;while(work != NULL){if(pre-&gt;start_addr + pre-&gt;size == work-&gt;start_addr){pre-&gt;size += work-&gt;size;free(work);work = pre-&gt;next;}else{pre = work;work = work-&gt;next;}}current_free_mem_size += ab-&gt;size;return 1;}// 删除进程，归还分配的存储空间，并删除描述该进程内存分配的节点。void kill_process(){struct allocated_block *ab;int pid;printf(&quot;Kill Process, pid=&quot;);scanf(&quot;%d&quot;, &amp;pid);getchar();ab = find_process(pid);if(ab != NULL){free_mem(ab); /*释放ab所表示的分配区*/dispose(ab);  /*释放ab数据结构节点*/}}//按FF算法重新整理内存空闲块链表,按空闲块首地址排序。int rearrange_FF(){struct free_block_type *head = free_block;struct free_block_type *forehand, *pre, *rear;int i;if(head == NULL)return -1;//冒泡排序for(i = 0; i &lt; free_block_count-1; i++){forehand = head;pre = forehand-&gt;next;rear = pre-&gt;next;while(pre-&gt;next != NULL){if(forehand == head &amp;&amp; forehand-&gt;start_addr &gt;= pre-&gt;start_addr)//比较空闲链表中第一个空闲块与第二个空闲块的开始地址的大小{head-&gt;next = pre-&gt;next;pre-&gt;next = head;head = pre;forehand = head-&gt;next;pre = forehand-&gt;next;rear = pre-&gt;next;}else if(pre-&gt;start_addr &gt;= rear-&gt;start_addr)//比较链表中其他相邻两节点的开始地址的大小{pre-&gt;next = rear-&gt;next;forehand-&gt;next = rear;rear-&gt;next = pre;forehand = rear;rear = pre-&gt;next;}else{forehand = pre;pre = rear;rear = rear-&gt;next;}}}return 0;}// 按BF算法重新整理内存空闲块链表,按空闲块大小从小到大排序。int rearrange_BF(){struct free_block_type *head = free_block;struct free_block_type *forehand, *pre, *rear;int i;if(head == NULL)return -1;//冒泡排序for(i = 0; i &lt; free_block_count-1; i++){forehand = head;pre = forehand-&gt;next;rear = pre-&gt;next;while(pre-&gt;next != NULL){if(forehand == head &amp;&amp; forehand-&gt;size &lt;= pre-&gt;size)//比较空闲链表中第一个空闲块与第二个空闲块的空间的大小{head-&gt;next = pre-&gt;next;pre-&gt;next = head;head = pre;forehand = head-&gt;next;pre = forehand-&gt;next;rear = pre-&gt;next;}else if(pre-&gt;size &lt;= rear-&gt;size)//比较链表中其他相邻两节点的空间的大小{pre-&gt;next = rear-&gt;next;forehand-&gt;next = rear;rear-&gt;next = pre;forehand = rear;rear = pre-&gt;next;}else{forehand = pre;pre = rear;rear = rear-&gt;next;}}}return 0;}//按WF算法重新整理内存空闲块链表,按空闲块大小从大到小排序。int rearrange_WF(){struct free_block_type *head = free_block;struct free_block_type *forehand, *pre, *rear;int i;if(head == NULL)return -1;//冒泡排序for(i = 0; i &lt; free_block_count-1; i++){forehand = head;pre = forehand-&gt;next;rear = pre-&gt;next;while(pre-&gt;next != NULL){if(forehand == head &amp;&amp; forehand-&gt;size &gt;= pre-&gt;size)//比较空闲链表中第一个空闲块与第二个空闲块空间的大小{head-&gt;next = pre-&gt;next;pre-&gt;next = head;head = pre;forehand = head-&gt;next;pre = forehand-&gt;next;rear = pre-&gt;next;}else if(pre-&gt;size &gt;= rear-&gt;size)//比较链表中其他相邻两节点的空间的大小{pre-&gt;next = rear-&gt;next;forehand-&gt;next = rear;rear-&gt;next = pre;forehand = rear;rear = pre-&gt;next;}else{forehand = pre;pre = rear;rear = rear-&gt;next;}}}return 0;}//按指定的算法整理内存空闲块链表。void rearrange(int algorithm){switch(algorithm){case MA_FF:rearrange_FF();break;case MA_BF:rearrange_BF();break;case MA_WF:rearrange_WF();break;}}//设置当前的分配算法void set_algorithm(){int algorithm;//system(&quot;clear&quot;);printf(&quot;\t1 - First Fit\n&quot;);//首次适应算法printf(&quot;\t2 - Best Fit \n&quot;);//最佳适应算法printf(&quot;\t3 - Worst Fit \n&quot;);//最坏适应算法printf(&quot;\nPlease choose(1~3):&quot;);for(; ; ){scanf(&quot;%d&quot;, &amp;algorithm);getchar();if(algorithm &gt;= 1 &amp;&amp; algorithm &lt;= 3){  ma_algorithm = algorithm;break;}else{printf(&quot;\nCannot input %d, Please input 1~3 : &quot;, algorithm);}}//按指定算法重新排列空闲区链表rearrange(ma_algorithm); }//设置内存的大小int set_mem_size(){int size;if(flag != 0)//防止重复设置{printf(&quot;Cannot set memory size again\n&quot;);return 0;}printf(&quot;Total memory size = &quot;);for(; ; ){scanf(&quot;%d&quot;, &amp;size);getchar();if(size &gt; 0){current_free_mem_size = size;mem_size = size;//设置内存大小为sizefree_block-&gt;size = mem_size;//设置空闲块大小为sizebreak;}else{printf(&quot;The size must greater than zero! Please input again:&quot;);}}flag = 1;//内存大小已经设置return 1;}//显示主菜单void display_menu(){printf(&quot;\n&quot;);//system(&quot;clear&quot;);printf(&quot;1 - Set memory size (default=%d)\n&quot;, DEFAULT_MEM_SIZE);printf(&quot;2 - Select memory allocation algorithm\n&quot;);printf(&quot;3 - New process \n&quot;);printf(&quot;4 - Terminate a process \n&quot;);printf(&quot;5 - Display memory usage \n&quot;);printf(&quot;0 - Exit\n&quot;);}// 初始化空闲块，默认为一块，可以指定大小及起始地址struct free_block_type* init_free_block(int mem_size){struct free_block_type *fb;fb = (struct free_block_type *)malloc(sizeof(struct free_block_type));if(fb == NULL)//初始化失败{printf(&quot;No mem\n&quot;);return NULL;}current_free_mem_size = mem_size;fb-&gt;size = mem_size;//设置空闲块大小fb-&gt;start_addr = DEFAULT_MEM_START;//空闲块起始地址fb-&gt;next = NULL;//首地址指向NULLreturn fb;}/*主函数*/int main(void){char choice;pid = 0;free_block = init_free_block(mem_size); //初始化空闲区while(1){display_menu();//显示菜单fflush(stdin);choice = getchar();//获取用户输入getchar();switch(choice){case &apos;1&apos;: //设置内存大小set_mem_size(); break;case &apos;2&apos;: //设置算法set_algorithm();flag = 1;break;case &apos;3&apos;: //创建新进程new_process();flag = 1;break;case &apos;4&apos;://删除进程kill_process();flag = 1;break;case &apos;5&apos;://显示内存使用display_mem_usage();flag = 1;break;case &apos;0&apos;: //释放链表并退出do_exit();exit(0);default: break;}} }</code></pre><h1 id="七、改进"><a href="#七、改进" class="headerlink" title="七、改进"></a>七、改进</h1><ul><li>内存整理： 删除空闲内存，重新过一遍算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-实验目的及实验环境&quot;&gt;&lt;a href=&quot;#一-实验目的及实验环境&quot; class=&quot;headerlink&quot; title=&quot;一. 实验目的及实验环境&quot;&gt;&lt;/a&gt;一. 实验目的及实验环境&lt;/h1&gt;&lt;h2 id=&quot;一-、实验环境&quot;&gt;&lt;a href=&quot;#一-、实验环境&quot;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>面试-操作系统</title>
    <link href="http://yoursite.com/2018/05/23/%E9%9D%A2%E8%AF%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/05/23/面试-操作系统/</id>
    <published>2018-05-23T07:38:44.000Z</published>
    <updated>2018-06-05T06:18:17.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-请问下面的程序一共输出多少个“-”？"><a href="#1-请问下面的程序一共输出多少个“-”？" class="headerlink" title="1.请问下面的程序一共输出多少个“-”？"></a>1.请问下面的程序一共输出多少个“-”？</h1><pre><code>#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int main(){int i;for(i=0;i&lt;2;i++){  fork();  printf(&quot;-&quot;);}wait(NULL);wait(NULL);return 0;}</code></pre><p>输出：8个“-”</p><h2 id="若：-n"><a href="#若：-n" class="headerlink" title="若：\n"></a>若：\n</h2><pre><code>#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int main(){int i;for(i=0;i&lt;2;i++){  fork();  printf(&quot;-\n&quot;);}wait(NULL);wait(NULL);return 0;}</code></pre><p>输出：6个“-”</p><h2 id="若：fflush-stdout"><a href="#若：fflush-stdout" class="headerlink" title="若：fflush(stdout);"></a>若：fflush(stdout);</h2><pre><code>#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int main(){int i;for(i=0;i&lt;2;i++){  fork();  printf(&quot;-&quot;);  fflush(stdout);}wait(NULL);wait(NULL);return 0;}</code></pre><p>输出：6个“-”</p><h2 id="若：EOF"><a href="#若：EOF" class="headerlink" title="若：EOF"></a>若：EOF</h2><pre><code>#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;int main(){int i;int c;for(i=0;i&lt;2;i++){  fork();  printf(&quot;-&quot;);  c=getchar();}wait(NULL);wait(NULL);return 0;}</code></pre><p>输出：6个“-”</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><pre><code>-          //产生两个进程 </code></pre><p>i=0    -     -       //2个</p><p>i=1  -  -  -   -     //4个</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为printf（“-”）语句有buffer，把“-”放在了缓存中，并没有真正的输出，在fork的时候，缓存被复制了子进程空间，就成了8个。</li><li>Unix下的设备有“块设备”，就是以一块一块的数据存取的设备，如磁盘和内存；“字符设备”是一个存取一个字符设备，如键盘和串口。<br>块设备一般都有缓存，而字符设备一般没有缓存。</li><li>遇到“\n”、主动flush、EOF、缓存区满、文件描述符关闭、程序退出，等就会把数据刷出缓存区</li></ul><hr><h1 id="2-在物理内存为1G的计算机中能否malloc-1-2G-？"><a href="#2-在物理内存为1G的计算机中能否malloc-1-2G-？" class="headerlink" title="2.在物理内存为1G的计算机中能否malloc(1.2G)？"></a>2.在物理内存为1G的计算机中能否malloc(1.2G)？</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>不同平台上去测试malloc()最多能分配多大内存空间时，为什么结果有时不同？</p><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><h3 id="Linux环境下："><a href="#Linux环境下：" class="headerlink" title="Linux环境下："></a>Linux环境下：</h3><h3 id="Windows环境："><a href="#Windows环境：" class="headerlink" title="Windows环境："></a>Windows环境：</h3><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned maximum=1024*1024*1024;int main(int argc, char *argv[]){unsigned blocksize[]={1024*1024,1024,1}; int i,count;void *block;for(i=0;i&lt;sizeof(blocksize)/sizeof(unsigned);i++) { for(count=1; ;count++)   {  block=malloc(maximum+blocksize[i]*count);  if(block!=NULL)  {  maximum=maximum+blocksize[i]*count;  free(block);  }  else   {break;  }}}/*printf(&quot;maximummalloc size=%u bytes\n&quot;,maximum);*/printf(&quot;2&quot;);return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-请问下面的程序一共输出多少个“-”？&quot;&gt;&lt;a href=&quot;#1-请问下面的程序一共输出多少个“-”？&quot; class=&quot;headerlink&quot; title=&quot;1.请问下面的程序一共输出多少个“-”？&quot;&gt;&lt;/a&gt;1.请问下面的程序一共输出多少个“-”？&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
