<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kernel前辈教C小子探案  3.18-3.20 | xiafei-xupt's blog</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kernel前辈教C小子探案  3.18-3.20</h1><a id="logo" href="/.">xiafei-xupt's blog</a><p class="description">汝之意志所向,即吾剑之所指</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Kernel前辈教C小子探案  3.18-3.20</h1><div class="post-meta"><a href="/Kernel前辈教C小子探案/#comments" class="comment-count"></a><p><span class="date">Mar 20, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p><img src="/assets/blogImg/14dad7989ae020d6899aaa09d57632bd.jpg" alt=""><br><a id="more"></a> </p>
<h2 id="111与221"><a href="#111与221" class="headerlink" title="111与221"></a>111与221</h2><p><strong>C小子：</strong><br><code>int main()</code><br><code>{</code><br><code>int n=1;</code><br><code>printf(&quot;%d %d %d\n&quot;,n,++n,n--);</code><br><code>}</code><br>Kernel前辈，请问它怎么在不同的编译器下答案不一样<br><img src="/assets/blogImg/微信图片_20180320173936.png" alt=""><br><img src="/assets/blogImg/微信图片_20180320173821.png" alt=""><br><strong>Kernel前辈:</strong>C小子，你自己的答案是什么？<br><strong>C小子：</strong>官方答案1 1 1<br><strong>Kernel前辈:</strong>为什么会不一样，这很有意思。回答一下这个问题<br><strong>C小子：</strong>好<br><strong>Kernel前辈:</strong>学习Linux内核，需要具备的知识基础，非常熟练的C，数据结构，编译原理，操作系统，软件工程，计算机原理，如果要了解网络，还需要网络知识。如果没有这些基础，真的学的很痛苦，就像空中楼阁，还有汇编语言。考试与实际代码还有相当的距离的，你看过Linux的一点代码，应该有感觉的。还有shell脚本语言<br><strong>C小子：</strong>是的，坚持了理论有时就要放弃实践，坚持了实践就有时就要放弃理论。shell之前也写过<br><strong>Kernel前辈:</strong>学内核这块，必须在理论和实践之间来回转换，因为，必须拿出东西才能给自己信心<br><strong>C小子：</strong>是的。技术是基本功!<br><strong>C小子：</strong><br><code>#include &lt;stdio.h&gt;</code><br><code>int main()</code><br><code>{</code><br>    <code>int n=1;</code><br>    <code>printf(&quot;%d %d %d\n&quot;,n,++n,n--);</code><br><code>}</code></p>
<p>vc++   ：2 2 1<br>Turbo C: 1 1 1</p>
<p>VC++环境下连续自增(自减)运算规则在一般表达式中和在函数参数中计算的结果相同;<br>规则：<br>1.先参考运算优先级;（++n的优先级高）<br>2.然后再从右至左依次对每个表达式求解;（n–=1，n=1;++n=2，n=2;n=2）<br>3.然后再从左到右输出每个表达式的值;（2 2 1 ）<br>4.最后变量n的值再自减1次。</p>
<p>Turbo C环境中当自增、自减运算出现在函数参数中时，计算方法采用扫描格式决定;<br>规则：<br>1.Turbo C编译环境中在从右至左依次对每个表达式求解时，先得到n–的值，然后n的值减1;（n–=1，n=0）<br>2.然后n加上1，得到++n的值;（n=0+1=1,++n=1）<br>3.最后n为1。（n=1）<br><strong>C小子：</strong><img src="/assets/blogImg/微信图片_20180320134425.jpg" alt=""><br><strong>Kernel前辈:</strong>（1）把这些汇编指令解释一下  （2）从编译角度说明二者这样做的理以及带来的问题 （3）在实际项目中遇到这样的问题如何解决 （4）在Linux 下运行看看结果 （5）谁遵循了标准   C<br><strong>C小子：</strong>好的<br><strong>C小子：</strong><br>（1）把这些汇编指令解释一下<br>汇编代码：<br>          <code>int n=1;</code><br><code>00401028   mov         dword ptr [ebp-4],1</code>//将1存放到ebp-4中，ebp-4此时为1<br>          <code>printf(&quot;%d %d %d\n&quot;,n,++n,n--);</code>//  2 2 1<br><code>0040102F   mov         eax,dword ptr [ebp-4]</code>//把ebp-4的值存放到寄存器eax中，eax此时为1<br><code>00401032   mov         dword ptr [ebp-8],eax</code>//将寄存器的值存放到地址为ebp-8的临时量中，此临时量ebp-8保存的值是1<br><code>00401035   mov         ecx,dword ptr [ebp-8]</code>//将ebp-8的值存放到寄存器ecx中，ecx此时是1<br><code>00401038   push        ecx</code>//将ecx的值压入栈中，1<br><code>00401039   mov         edx,dword ptr [ebp-4]</code>//将ebp-4的值放到edx中，edx此时为1<br><code>0040103C   add         edx,1</code>//对寄存器edx的值进行+1操作，edx为2<br><code>0040103F   mov         dword ptr [ebp-4],edx</code>//将寄存器edx的值重新写到ebp-4中，ebp-4此时为2<br><code>00401042   mov         eax,dword ptr [ebp-4]/</code>/将ebp-4的值取出来放到寄存器eax中，eax为2<br><code>00401045   push        eax</code>//将eax的值压入栈中,1 2<br><code>00401046   mov         ecx,dword ptr [ebp-4]</code>//将ebp-4的值放到ecx中，ecx为2<br><code>00401049   push        ecx</code>////将ecx的值压入栈中， 1 2 2<br><code>0040104A   push        offset string &quot;%d&quot; (0042201c)</code>//压入字符串参数<br><code>0040104F   mov         edx,dword ptr [ebp-4]</code>//将ebp-4的值放到edx中，edx 为2<br><code>00401052   sub         edx,1</code>//对edx寄存器进行-1操作，edx 为1<br><code>00401055   mov         dword ptr [ebp-4],edx</code>//将eax放到ebp-4中<br><code>00401058   call        printf (00401090)</code>//开始执行printf函数    2 2 1<br><code>0040105D   add         esp,10h</code>//释放局部变量空间</p>
<p>（2）从编译角度说明二者这样做的理由以及带来的问题<br>理由：编译时不同编译器处理方法不同，在vc++中编译时，需要考虑优先级，（add         edx,1）。编译角度很底层，规则不同，或许是因为更底层的一些东西限制，我再查查</p>
<p>问题：会出现歧义， 使得一些程序不能很好的移植，不能跨平台使用</p>
<p>（3）在实际项目中遇到这样的问题如何解决<br>应避免歧义，以稳定兼容为原则，将自增自减运算用变量代替，根据要求改写,可写成：<br><code>#include &lt;stdio.h&gt;</code><br><code>int main()</code><br><code>{</code><br>    <code>int i,j,k;</code><br>    <code>int n=1;</code><br>    <code>i=n;</code><br>    <code>j=++n;</code><br>    <code>k=n--;</code><br>    <code>printf(&quot;%d %d %d\n&quot;,n,++n,n--);</code><br><code>}</code></p>
<p>（4）在Linux 下运行看看结果<br>1 1 1<br><img src="/assets/blogImg/微信图片_20180320173032.png" alt=""><br>（5）谁遵循了标准   C<br>linux 下的编译器gcc遵循了标准 c<br><strong>Kernel前辈:</strong>回答的不错，还有一个问题，为什么要压栈？<br><strong>C小子：</strong>压栈可能是为何后面便于一条输出语句可以输出多个结果吧<br><strong>Kernel前辈:</strong>不对<br><strong>C小子：</strong>那是为什么呀，从右向左的压栈，从左向右的输出，多个结果保证顺序。编译系统我不是非常了解<br><strong>Kernel前辈:</strong>手上要有一本深入理解计算机系统的书，查看函数的执行过程就明白了<br><strong>C小子：</strong>嗯嗯，我了解的深度不够<br><strong>Kernel前辈:</strong>不是不够，皮毛尚未触及<br><strong>Kernel前辈:</strong>刚才你回答问题的思路和方法是正确的<br><strong>C小子：</strong>Kernel前辈，虽然我用户态的程序不太了解，但不是完全不可用学内核，只要方法正确，对比着学，内核态用户态相互验证，这样更好。那到底为什么要压栈呀？<br><strong>Kernel前辈:</strong>这个需要你系统的去了解，不能等答案。会涉及到编译程序如何对函数进程编译处理。执行程序如何执行函数<br><strong>C小子：</strong>是一种约定的规则<br><strong>Kernel前辈:</strong>对，计算机中有很多的标准和接口<br><strong>C小子：</strong>会不会编译程序对函数处理 在不同的条件下也不同，就像不同的编译器那个程序结果也不同。就是说有不同的规则<br><strong>Kernel前辈:</strong>编译器不一样，处理规则上有差异<br><strong>C小子：</strong>好有意思呀，一切可定义<br><strong>Kernel前辈:</strong>但业界也有统一标准，这些标准相当于基类，是最低原则，各家还会定自己的规则<br><strong>C小子：</strong>各家自己定义是为了便于自己的一些应用，统一标准是为了传播交流。多谢Kernel前辈指点。</p>
<h2 id="20001与19496"><a href="#20001与19496" class="headerlink" title="20001与19496"></a>20001与19496</h2><p><strong>Kernel前辈:</strong>一个加1操作就可以把计算机方方面面的知识都带出来。加1操作系统会引发很多有趣的话题，在并发环境下又发生什么不可思议的事？写一个简单的程序，两个线程共享变量n, 初值为1，分别对N加1000次后，结果是什么，为什么<br><strong>C小子：</strong><br><code>#include &lt;stdio.h&gt;</code><br><code>#include &quot;windows.h&quot;</code><br><code>int n = 1;</code><br><code>bool p1 = false;</code><br><code>bool p2 = false;</code><br><code>DWORD WINAPI proc1(LPVOID lparentet)</code><br><code>{</code><br><code>for(int i = 0;i&lt;1000;i++)</code><br><code>{</code><br><code>n++;</code><br><code>}</code><br><code>p1= true;</code><br><code>return 0;</code><br><code>}</code><br><code>DWORD WINAPI proc2(LPVOID lparentet)</code><br><code>{</code><br><code>for(int i = 0;i&lt;1000;i++)</code><br><code>{</code><br><code>n++;</code><br><code>}</code><br><code>p2 = true;</code><br><code>return 0;</code><br><code>}</code><br><code>int main()</code><br><code>{</code><br><code>CreateThread(NULL,0,proc1,NULL,0,NULL);</code><br><code>CreateThread(NULL,0,proc2,NULL,0,NULL);</code><br><code>while(1)</code><br><code>{</code><br><code>if(p1 &amp;&amp; p2)</code><br><code>{</code><br><code>printf(&quot;%d\n&quot;,n);</code><br><code>break;</code><br><code>}</code><br><code>}</code><br><code>return 0;</code><br><code>}</code><br>1000次，运行结果一直都是2001，没有发现异常，但是1W次有时会有异常，按理说是20001，但有时就是其它数，10W次的话经常异常。好奇怪，次数越多，异常现象越明显<img src="/assets/blogImg/微信图片_20180320175826.png" alt=""><img src="/assets/blogImg/微信图片_20180320140639.jpg" alt="">1000次很难发现异常。这和处理器性能有没有关系？<br><strong>Kernel前辈:</strong>这个问题，自己探索，如果方向对了，再给你说<br><strong>C小子：</strong>好，会不会是一个线程访问这个全局变量时而另一个线程将其修改，从而产生异常。而异常结果小于正常结果是因为是n++这个运算。如果是n–则会大于正常结果。异常结果与正常结果之差不一定是发生异常的次数，一个线程访问这个全局变量时而另一个线程或许会将其修改再修改。次数越多，异常现象越明显，这和处理器性能应该没有关系，因为执行的次数一定。全局变量为1，n– 1000次后应是-1999，异常结果大于正常结果<br><strong>Kernel前辈:</strong>从线程的并发执行考虑<br><strong>C小子：</strong>一个线程访问这个全局变量时而另一个线程将其修改，从而产生异常<br><strong>Kernel前辈:</strong>同步机制<br><strong>C小子：</strong>多谢Kernel前辈指点<br><strong>Kernel前辈:</strong>为什么异常还没说到根本上<br><strong>C小子：</strong>没有上锁，经常无序执行，虽然效率高，但是容易出错。再次感谢Kernel前辈的指点。</p>
</div><div class="tags"><a href="/tags/Kernel/">Kernel</a></div><div class="post-share"></div><div class="post-nav"><a href="/实验-进程管理/" class="pre">实验-进程管理(线程、进程、互斥与死锁)</a><a href="/diary-2017-0528-0601/" class="next">安全 中华人民共和国网络安全法 5.28-6.1</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#111与221"><span class="toc-text">111与221</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20001与19496"><span class="toc-text">20001与19496</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/Linux内核模块编程入门/">Linux内核模块编程入门</a></li><li class="post-list-item"><a class="post-list-link" href="/Gitbook教程/">Gitbook教程</a></li><li class="post-list-item"><a class="post-list-link" href="/博客模板/">博客模板</a></li><li class="post-list-item"><a class="post-list-link" href="/什么是“平均负载”(二)？/">什么是“平均负载”(二)？</a></li><li class="post-list-item"><a class="post-list-link" href="/什么是“平均负载”(一)？/">什么是“平均负载”(一)？</a></li><li class="post-list-item"><a class="post-list-link" href="/任务安排/">任务安排</a></li><li class="post-list-item"><a class="post-list-link" href="/阿里云9.9元学生服务器的购买和配置/">阿里云9.9元学生服务器的购买和配置</a></li><li class="post-list-item"><a class="post-list-link" href="/IPFS历史、现状及未来/">IPFS历史、现状及未来</a></li><li class="post-list-item"><a class="post-list-link" href="/IPFS私有网络搭建/">IPFS私有网络搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/IPFS环境搭建与入门教程/">IPFS环境搭建与入门教程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/模板/" style="font-size: 15px;">模板</a> <a href="/tags/FAQ/" style="font-size: 15px;">FAQ</a> <a href="/tags/MariaDB/" style="font-size: 15px;">MariaDB</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/PostgreSQL/" style="font-size: 15px;">PostgreSQL</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/旧事/" style="font-size: 15px;">旧事</a> <a href="/tags/BlurAdmin/" style="font-size: 15px;">BlurAdmin</a> <a href="/tags/Kernel/" style="font-size: 15px;">Kernel</a> <a href="/tags/安排/" style="font-size: 15px;">安排</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Electron/" style="font-size: 15px;">Electron</a> <a href="/tags/系统优化/" style="font-size: 15px;">系统优化</a> <a href="/tags/红线/" style="font-size: 15px;">红线</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/09/">September 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">About</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">xiafei-xupt.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>