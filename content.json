{"meta":{"title":"xiafei-xupt's blog","subtitle":"汝之意志所向,即吾剑之所指","description":null,"author":"xiafei-xupt","url":"http://yoursite.com"},"pages":[{"title":"About me","date":"2018-11-03T13:11:20.930Z","updated":"2018-08-03T03:01:32.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"热爱技术与远方 目前在学习内核"}],"posts":[{"title":"Linux内核模块编程入门","slug":"Linux内核模块编程入门","date":"2026-09-11T16:00:00.000Z","updated":"2018-09-23T04:48:18.000Z","comments":true,"path":"Linux内核模块编程入门/","link":"","permalink":"http://yoursite.com/Linux内核模块编程入门/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的文章前景0x01-知识储备linux系统数据结构深入理解计算机系统操作系统原理0x02-测试环境硬件环境软件环境0x03-方案设计方案A方案B0x04-实践验证实践操作实践结果0x05-总结分析文章结论文章分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}],"keywords":[]},{"title":"Gitbook教程","slug":"Gitbook教程","date":"2026-01-03T16:00:00.000Z","updated":"2018-08-13T18:52:38.000Z","comments":true,"path":"Gitbook教程/","link":"","permalink":"http://yoursite.com/Gitbook教程/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的在线文档 文章前景0x01-知识储备linux系统数据结构深入理解计算机系统操作系统原理0x02-测试环境硬件环境软件环境0x03-方案设计pdf – –&gt; md md、HTML、world、pdf等格式互相转换 方案A方案B0x04-实践验证实践操作实践结果0x05-总结分析文章结论文章分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下 考虑到： 理论与实践 抽象与具体 现状与未来 调试优化（折中与平衡）用户体验：应用性能： 截图时间点（I/O）： 输入：命令、按钮 输出：变化、结果 ——&gt;I/O截图法 #########################","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}],"keywords":[]},{"title":"博客模板","slug":"博客模板","date":"2026-01-03T16:00:00.000Z","updated":"2018-10-08T02:06:42.000Z","comments":true,"path":"博客模板/","link":"","permalink":"http://yoursite.com/博客模板/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的AI操作系统，以01为基因，内核为灵魂， 文章前景0x01-知识储备0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git0x03-方案设计 复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。 方案A方案B0x04-实践操作0x05-总结分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下 考虑到： 理论与实践 抽象与具体 现状与未来 调试优化（折中与平衡）用户体验：应用性能： 截图时间点（I/O）： 输入：命令、按钮 输出：变化、结果 ——&gt;I/O截图法","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}],"keywords":[]},{"title":"任务安排","slug":"任务安排","date":"2018-12-11T16:00:00.000Z","updated":"2018-10-08T03:02:48.000Z","comments":true,"path":"任务安排/","link":"","permalink":"http://yoursite.com/任务安排/","excerpt":"","text":"前期准备2018/7/9 熟悉数据库设计基本原理，安装数据库开发环境PostgreSQL环境搭建:原理、安装 2018/7/16 熟悉数据库操作基本流程、数据操作命令、编程接口PostgreSQL语法学习：操作教程、命令语法、编程接口 2018/7/23 研究HTML界面开发框架数据库操作以及相关开发语言前端学习：Electron开源库+blur-admin响应式模板学习、安装、介绍、接口 2018/7/30 分析应用场景（场景1：日志分析）数据操作以及数据展示要求，设计数据库表、字段，设计服务程序，创造数据，写入数据库表格创建：应用场景 2018/8/6 应用场景1：日志分析 中展示要求1，2 界面框架数据库查询接口PostgreSQL连接接口（一）：实现 2018/8/13 “自测功能（包括查询性能），并优化数据库表设计。打包，提供测试版以及查询接口”自测功能（一）： 2018/8/20 应用场景1：日志分析 中展示要求3 界面框架数据库查询接口PostgreSQL接口封装（二）：封装 2018/8/27 “自测功能（包括查询性能），并优化数据库表设计。打包，提供测试版、更新查询接口”自测功能（二）： 2018/9/3 配合HTML界面调试全栈调试（一）： 2018/9/10 配合HTML界面调试全栈调试（二）： 2018/9/17 测试、优化测试优化（一）： 2018/9/24 测试、优化测试优化（二）： 第一阶段一周：9.10 表格设计与查询显示服务器管理 从数据表server中获取所有服务器并显示 可筛选查看 日志查询 通过条件从warning中查询日志并显示 多条件查询，时间、消息类型、电厂名称等 一周：9.17 实时警告模块设计与实现实时告警 实时（通过定时器）从数据表warning中获取最新的日志显示 可选择要显示的日志类型、可清空、对日志可以操作状态（已解决、未解决） 根据重要性统计以饼状图显示（紧急、重要、一般）、并以线性图显示趋势（近一周、近一月、近一年） 上面显示图表，下面以列表显示日志 二周：10.1系统运行统计图9.24柱状图设计与显示： 按消息类型统计，以柱状图显示 按操作类型统计，以柱状图显示 10.1饼状图显示与统计： 按电厂属性统计，以饼状图显示 在线统计 按告警级别统计，以饼状图统计 第二阶段10.8 MariaDB数据库学习 10.15 BLurAdmin界面设计 系统时间、 10.22 内核基础4月初-7月初 Linux基本操作 Linux C编程基础： 工具：gcc、gdb c primer plus 源码 c++ primer plus 原理、实验、心得 Unix实践编程 内核代码阅读 多版本源码注释 新旧版本知识点对比-&gt;内核演化 09-12 Linux内核模块编程入门 list.h 分页 进程","categories":[],"tags":[{"name":"安排","slug":"安排","permalink":"http://yoursite.com/tags/安排/"}],"keywords":[]},{"title":"","slug":"新建文件夹/IPFS","date":"2018-11-06T04:14:31.951Z","updated":"2018-11-06T04:21:22.796Z","comments":true,"path":"新建文件夹/IPFS/","link":"","permalink":"http://yoursite.com/新建文件夹/IPFS/","excerpt":"","text":"IPFS搭建私有网络","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"开源大学","date":"2018-11-03T05:02:48.000Z","updated":"2018-10-01T23:29:08.000Z","comments":true,"path":"开源大学/","link":"","permalink":"http://yoursite.com/开源大学/","excerpt":"","text":"开源大学","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"编译、链接与装载","date":"2018-11-03T05:02:48.000Z","updated":"2018-09-02T02:31:50.000Z","comments":true,"path":"编译、链接与装载/","link":"","permalink":"http://yoursite.com/编译、链接与装载/","excerpt":"","text":"第一章 编译、链接与装载C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编译和链接，形成可执行文件在操作系统下执行时，我们是否会发出以下疑问： C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？ C代码中经常会包含头文件，那么，什么是头文件？什么又是C语言库？ 我们经常说main函数是C语言程序的入口，难道不能把其它函数当入口？ 不同的操作系统上编译好的程序可以直接拷贝过去运行吗？ 如果上面的问题你都能回答的话，那么就可以跳过本节。如果你不知道或者不是很清楚，那么我们就顺着这个思路探究下去。 1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？我们以最经典的HelloWorld程序为例。先使用vim等文本编辑器写好代码，接着在终端执行编译命令（使用的Linux系统是Debian）： gcc HelloWorld.c -o HelloWorld 这条命令在编译的同时进行了链接，形成了可执行文件HelloWorld，最后我们在终端执行 ./HelloWorld，顺利地显示了输出结果。 debian@bogon:~$ vim HelloWorld.c debian@bogon:~$ gcc HelloWorld.c -o HelloWorld debian@bogon:~$ ./HelloWorld Hello World! debian@bogon:~$ 可是，简单的命令背后经过了什么样的处理过程？gcc真的就“直接”生成了最后的可执行文件了？当然不是，我们在gcc编译命令行加上参数 –verbose要求gcc输出完整的处理过程(命令行加上 -v 也行)，我们看到了一段较长的过程输出。 debian@bogon:~$ gcc --verbose HelloWorld.c -o HelloWorld Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapper Target: x86_64-linux-gnu Configured with: ../src/configure -v --with-pkgversion=&apos;Debian 6.3.0-18+deb9u1&apos; ...... 在此，我们不截取输出结果的完整图了，但你可以自己试验，然后试着分析整个流程。 图1是gcc编译过程的分解图： 从图中我们大致可以看出gcc处理HelloWorld.c的大致过程： 预处理(Prepressing)—&gt;编译(Compilation)—&gt;汇编(Assembly)—&gt;链接(Linking) 括号中注明了各个过程中实际执行任务的程序名称：预处理器cpp、编译器cc1、汇编器as以及最后的链接器ld。 2. 预处理到底做什么？我们在终端输入命令 gcc -E HelloWorld.c -o HelloWorld.i，然后打开输出文件HelloWorld.i： # 1 &quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot; 1 3 4 # 28 &quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot; 2 3 4 typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; 首先是大段的变量和函数的声明，我们的代码找不到了，到底去哪了？在vim编辑环境的普通模式中按下shift+g(大写G)跳到文件的底部，终于在几千行以后看到了我们可怜兮兮的几行代码。 int main(){ printf(&quot;Hello World!\\n&quot;); return 0; } 前面几千行代码是做什么的？其实它就是 /usr/include/stdio.h 文件的所有内容，预处理器把所有的#include替换为实际文件的内容了。这个过程是递归进行的，所以stdio.h里面的#include也被实际内容所替换了。 而且我在HelloWorld.c里面的所有注释被预处理器全部删除了。就连printf语句前的Tab缩进也被替换为一个空格了，显得代码都不美观了。 通过观察这些内容，我们梳理出预处理器处理的大致所做的事情： 展开所有的宏定义并删除 #define 处理所有的条件编译指令，例如 #if #else #endif #ifndef … 把所有的 #include 替换为头文件实际内容，递归进行 把所有的注释 // 和 / / 替换为空格 添加行号和文件名标识以供编译器使用 保留所有的 #pragma 指令，因为编译器要使用 基本上就是这些内容。（在这里顺便插播一个小技巧，在代码中有时候宏定义比较复杂的时候我们很难判断其处理后的结构是否正确。这个时候我们就可以使用gcc的-E参数输出处理结果来判断） 前文中我们提到头文件中存放的是变量定义和函数声明等等内容。这些内容到底是什么？其实在早期调用函数时并不需要声明，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，所有编译器开始要求对所有使用的变量或者函数给出声明，以支持编译器进行参数检查和类型匹配。头文件包含的基本上就是这些东西和一些预先的宏定义来方便程序员编程。其实对于我们的HelloWorld.c程序来说不需要这个庞大的头文件，只需要在main函数前声明printf函数，不需要#include即可通过编译。 声明如下： int printf(const char *format, ...); 大家可以自行测试。另外再补充一点，gcc其实并不要求函数一定要在被调用之前定义或者声明，因为gcc在处理到某个未知类型的函数时，会为其创建一个隐式声明，并假设该函数返回值类型为int。但gcc此时无法检查传递给该函数的实参类型和个数是否正确，不利于编译器为我们排除错误（而且如果该函数的返回值不是int的话也会出错）。所以还是建议大家在函数调用前，先对其定义或声明。 3. 编译做什么？了解了预处理之后，我们接着看编译和汇编。什么是编译？一句话描述：编译就是把预处理之后的文件进行一系列词法分析、语法分析、语义分析以及优化后生成的相应汇编代码文件。 怎么查看编译后的汇编代码？命令： gcc -S HelloWorld.c -o HelloWorld.s 这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意。顺便说一句，这里生成的汇编是AT&amp;T风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 -masm=intel ,这样gcc就会生成Intel风格的汇编代码了（如图）。不过gcc的内联汇编只支持AT&amp;T风格，我们在第二章会给予介绍。 .file &quot;HelloWorld.c&quot; .intel_syntax noprefix .section .rodata .LC0: .string &quot;Hello World!&quot; .text .globl main .type main, @function main: .LFB0: .cfi_startproc push rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov rbp, rsp .cfi_def_cfa_register 6 lea rdi, .LC0[rip] call puts@PLT mov eax, 0 pop rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &quot;GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 4. 汇编做什么？我们继续用一句话来描述：汇编就是将编译后的汇编代码翻译为机器码，几乎每一条汇编指令对应一句机器码。 命令： gcc -c HelloWorld.c 可以让编译器只进行到生成目标文件这一步，这样我们就能在目录下看到HelloWorld.o文件了。 Linux下的可执行文件以及目标文件的格式叫作ELF(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，Linux下的ELF也罢，都是COFF(Common file format)格式的一种变种，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因不只是这一点，不同的操作系统接口（windows API和Linux的API不同）以及相关的类库不同也是原因之一。 更详细的内容可以参看《程序员的自我修养》了解。 5. 链接做什么？这一步是将汇编产生的目标文件和所使用的库函数的目标文件链接生成一个可执行文件的过程。在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一是链接造成的错误通常难以理解和处理，二是在开发中使用第三方库越来越常见了，大家可能更需要稍微了解一些细节。 首先介绍一下gnu binutils工具包，这是一整套的二进制分析处理工具包。详细介绍请大家参考维基百科：http://zh.wikipedia.org/wiki/GNU_Binutils 一般系统安装包中都带了这套工具包，如果你的发行版没有，请自行搜索进行安装。 这套工具包含了足够多的工具，我们甚至可以用来研究ELF文件的格式等内容。不过本节只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。 链接这个话题涉及的内容相当广泛，为了避免本节牵扯到过多的话题导致言之泛泛，我们先设定本节讨论的范围。在这里只讨论链接进行的大致步骤及其规则、静态链接库与动态链接库的创建和使用这两大问题。至于可执行文件的加载、可执行文件的运行时储存器映像之类的内容我们暂时不讨论。那么，什么是链接？我们引用《深入理解计算机系统》中的定义：链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。 需要强调的是，链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时（run time），由应用程序来执行。 那么，了解链接到底有什么用？继续引用《深入理解计算机系统》的说法，如下： 理解链接器将帮助你构造大型程序。 理解链接器将帮助你避免一些危险的编程错误。 理解链接将帮助你理解语言的作用域是如何实现的。 理解链接将帮助你理解其他重要的系统概念。 理解链接将使你能够利用共享库。 言归正传。为了避免我们的描述过于枯燥，我们还是以C语言为例。大家通过我们前面的描述，已经知道C代码编译后的目标文件了。目标文件最终要和标准库进行链接生成最后的可执行文件。那么，标准库和我们生成的目标文件是什么关系？ 其实，任何一个程序，它的背后都有一套庞大的代码在支撑着它，以使得该程序能够正常运行。这套代码至少包括入口函数、以及其所依赖的函数构成的函数集合。当然，它还包含了各种标准库函数的实现。 这个“支撑模块”就叫做运行时库（Runtime Library）。而C语言的运行库，即被称为C运行时库（CRT）。 CRT大致包括：启动与退出相关的代码（包括入口函数及入口函数所依赖的其他函数）、标准库函数（ANSI C标准规定的函数实现）、I/O相关、堆的封装实现、语言特殊功能的实现以及调试相关。其中标准库函数的实现占据了主要地位。标准库函数比如我们平时常用的printf，scanf函数等。C语言标准库在不同的平台上实现了不同的版本，我们只要依赖其接口定义，就能保证程序在不同平台上的一致行为。C语言标准库有24个，囊括标准输入输出、文件操作、字符串操作、数学函数以及日期等等内容。大家有兴趣的可以自行搜索。 5.1 静态链接库既然C语言提供了标准库函数供我们使用，那么以什么形式提供？是源代码吗？当然不是。下面引入静态链接库的概念。我们几乎每一次写程序都难免去使用库函数，那么每一次去编译岂不是太麻烦了。干嘛不把标准库函数提前编译好，需要的时候直接链接？是的，标准库就是这么做的。那么，标准库以什么形式存在？是一个目标文件？我们知道，链接的最小单位就是一个个目标文件，如果我们只用到一个printf函数，但需要和整个库链接的话岂不是太浪费资源了么？但是，如果把库函数分别定义在彼此独立的代码文件中，这样编译出后就形成一大堆目标文件。所以，编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库（static library）。当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。这样就解决了资源浪费的问题。 Linux/Unix系统下ANSI C的库名叫做libc.a，另外数学函数单独在libm.a库中。当了解以上相关知识后，我们试着自己做一个静态库。为了简单起见我们就做一个只有两个函数的私有库。 在swap.c里定义一个swap函数，在add.c里定义了一个add函数。最后还有含有它们声明的calc.h头文件。 // swap.c void swap(int *num1, int *num2) { int tmp = *num1; *num1 = *num2; *num2 = tmp; } // add.c int add(int a, int b) { return a + b; } // calc.h #ifndef CALC_H_ #define CALC_H_ #ifdef _cplusplus extern &quot;C&quot; { #endif void swap(int *, int *); int add(int, int); #ifdef _cplusplus } #endif #endif // CALC_H_ 我们分别编译它们得到了swap.o和add.o这两个目标文件，最后使用ar命令将其打包为一个静态库。 debian@bogon:~/link$ gcc add.c -c -o add.o debian@bogon:~/link$ gcc swap.c -c -o swap.o debian@bogon:~/link$ ls add.c add.o calc.h swap.c swap.o debian@bogon:~/link$ ar rcs libcalc.a swap.o add.o debian@bogon:~/link$ ls add.c add.o calc.h libcalc.a swap.c swap.o debian@bogon:~/link$ 现在我们怎么使用这个静态库呢？我们写一个test.c使用这个库中的swap函数。代码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &quot;calc.h&quot; int main(int argc, char *argv[]) { int a = 1, b = 2; swap(&amp;a, &amp;b); printf(&quot;%d %d\\n&quot;, a, b); return EXIT_SUCCESS; } 下来是编译执行，命令行执行gcc test.c ./libcalc.a -o test编译，执行。如图，我们输出了预期的结果。 debian@bogon:~/link$ gcc test.c ./libcalc.a -o test debian@bogon:~/link$ ./test 2 1 debian@bogon:~/link$ 可能你会问，我们使用C语言标准库的时候，编译时并不需要加库名。是的，的确不需要，那是因为标准库已经是标准了，所以会被默认链接。不过因为数学函数库libm.a没有默认链接，所以我们使用了数学函数的代码在编译时需要在命令行指定 -lm 链接（-l是指定链接库，m是去掉lib之后的库名），不过现在好多gcc都默认链接libm.c库了。 正如我们所看到的，静态链接库解决了一些问题，但是它同时带来了另一些问题。比如说每一个使用了相同的C标准函数的程序都需要和相关目标文件进行链接，浪费磁盘空间；当一个程序有多个副本执行时，相同的库代码部分被载入内存，浪费内存；当库代码更新之后，使用这些库的函数必须全部重新编译等等。 5.2 动态链接库是否有更好的办法？当然有。我们接下来引入动态链接库/共享库（shared library）。 动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。这个过程就是动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序完成的。 Unix/Linux中共享库的后缀名通常是.so（微软就是DLL文件）。那么，如何建立一个动态链接库？ 我们还是以上面的代码为例，首先删除之前的静态库和目标文件。要建立动态链接库，在命令行输入： gcc swap.c add.c -shared -o libcalc.so 顺便说一下，最好在gcc命令行加上一句-fPIC让其生成与位置无关的代码（PIC），具体原因超出本文范围，故暂不予讨论。 debian@bogon:~/link$ gcc swap.c add.c -shared -o libcalc.so debian@bogon:~/link$ ls add.c add.o calc.h libcalc.a libcalc.so swap.c swap.o test test.c debian@bogon:~/link$ 如何使用动态链接库？我们继续编译测试代码，执行gcc test.c -o test ./libcalc.so即可。运行后我们仍旧得到了预期的结果。 debian@bogon:~/link$ gcc test.c -o test ./libcalc.so debian@bogon:~/link$ ./test 2 1 debian@bogon:~/link$ 这看起来也没什么不一样的。其实不然，我们用ldd命令（ldd是我们推荐的GNU binutils工具包的组成之一）检查test文件的依赖。 debian@bogon:~/link$ ldd ./test linux-vdso.so.1 (0x00007fff3d3fb000) ./libcalc.so (0x00007f61c97de000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61c943f000) /lib64/ld-linux-x86-64.so.2 (0x00007f61c9be2000) debian@bogon:~/link$ 我们看到这个文件能顺利运行需要依赖libcalc.so这个动态库，我们还能看到C语言的标准库默认也是动态链接的（在gcc编译的命令行加上 -static 可以要求静态链接）。 好处何在？第一，库更新之后，只需要替换掉动态库文件即可，无需编译所有依赖库的可执行文件。第二，程序有多个副本执行时，内存中只需要一份库代码，节省空间。 大家想想，C语言标准库好多程序都在用，但内存只有一份代码，这样节省的空间就相当可观了，而且假如库代码发现bug，只需要更新libc.so即可，所有程序即可使用新的代码，代码的可维护性提高。 关于库的内容还很多，就此介绍到这里。 5.3 链接的步骤我们来看看链接过程中具体做的事情。链接的步骤大致包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等主要步骤。 首先是地址和空间分配，我们之前提到的目标文件其实全称叫做可重定位目标文件（这只是一种名称，还有其他名称）。目标文件的格式已经无限度接近可执行文件了，Unix/Linux下的目标文件的格式叫做ELF（Executable and Linkable Format，可执行连接格式）。本节暂不详细讨论可执行文件的格式，我们只需要知道可执行文件中代码，数据，符号等内容分别存储在不同的段中就可以，这也和第二章保护模式下的内存分段是有一定关系的。我们简单叙述了地址和空间分配以及重定位，但是稍微详细说明一下符号决议。 什么是符号（symbol）？简单说我们在代码中定义的函数和变量可以统称为符号。符号名（symbol name）就是函数名和变量名了。 目标文件的拼合其实也就是对目标文件之间相互的符号引用的一个修正。我们知道一个C语言代码文件只要所有的符号被声明过就可以通过编译了，可是对某符号的引用怎么知道位置呢？比如我们调用了printf函数，编译时留下了要填入的函数地址，那么printf函数的实际地址在哪里？这个空位什么时候修正呢？当然是链接的时候，重定位那一步就是做这个的。但是在修改地址之前需要做符号决议，那什么是符号决议？正如前文所说，编译期间留下了很多需要重新定位的符号，所以目标文件中会有一块区域专门保存符号表。链接器如何知道具体位置？其实链接器并不知道，所以链接器会搜索全部的待链接的目标文件，寻找这个符号的位置，然后修正每一个符号的地址。 在此我们要重点介绍一下在编译程序时几乎所有人会遇见的问题——符号查找问题。在编译时通常会碰到两种编译错误，即找不到某符号或者符号重定义。 首先介绍找不到符号的情况，比如，当我们声明了一个swap函数却没有定义它的时候，我们调用这个函数的代码可以通过编译，但是在链接期间却会遇到错误。形如“test.c:(.text+0x29): undefined reference to ‘swap’”这样，特别的，MSVC编译器报错是找不到符号_swap。这个下划线从哪里来的？这得从C语言刚诞生说起。当C语言刚面世的时候，已经存在不少用汇编语言写好的库了，因为链接器的符号唯一规则，假如该库中存在main函数，我们就不能在C代码中出现main函数了，因为会遭遇符号重定义错误，倘若放弃这些库又是一大损失。所以当时的编译器会对代码中的符号进行修饰（name decoration），C语言的代码会在符号前加下划线，fortran语言在符号前后都加下划线，这样各个目标文件就不会同名了，就解决了符号冲突的问题。随着时间的流逝，操作系统和编译器都被重写了好多遍，当前的这个问题已经可以忽略。所以新版的gcc一般不会再加下划线做符号修饰（也可以在编译的命令行加上-fleading-underscore/-fno-fleading-underscore开打开/关闭这个是否加下划线）。而MSVC依旧保留了这个传统，所以我们可以看到_swap这样的修饰。 顺便说一下，符号冲突是很常见的事情，特别是在大型项目的开发中，所以我们需要一个约定良好的命名规则。C++也引入了命名空间来帮助我们解决这些问题，因为C++中存在函数重载，所以C++的符号修饰更加复杂难懂（Linux下有c++filt命令帮助我们翻译一个被C++编译器修饰过的符号）。 那么，当出现同名符号时链接器到底如何处理。刚才说过会报告重名错误，为什么还要进行探讨？实际上，不仅仅这么简单。在编译时，编译器会向汇编器输出每个全局符号，分为强（strong）符号和弱符号（weak），汇编器把这个信息隐含的编码在可重定位目标文件的符号表里。其中函数和已初始化过的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义，GNU链接器采用的规则如下： 不允许多个强符号 如果有一个强符号和一个或多个弱符号，则选择强符号 如果有多个弱符号，则随机选择一个 其中，第一条会报符号重名错误的，而后两条默认情况下甚至连警告都不会有。关键就在这里，默认甚至连警告都没有。 我们来个实验具体说一下： // link1.c #include &lt;stdio.h&gt; int n; int main(int argc, char *argv[]) { printf(&quot;It is %d\\n&quot;, n); return 0; } // link2.c int n = 5; 这两个文件编译运行会输出什么呢？想必你已经知道了结果，没错，就是5 debian@bogon:~/link$ vim link1.c debian@bogon:~/link$ vim link2.c debian@bogon:~/link$ gcc link1.c link2.c -o link debian@bogon:~/link$ ./link It is 5 debian@bogon:~/link$ 初始化过的n是强符号，被优先选择了。但是，在很复杂的项目代码中，这样的错误很难发现，特别是多线程的代码，不过当我们怀疑代码中的bug可能是因为此原因引起的时候，我们可以在gcc命令行加上-fno-common这个参数，这样链接器在遇到多重定义的符号时，都会给出一条警告信息，而无关强弱符号。如下所示： debian@bogon:~/link$ gcc link1.c link2.c -o link -fno-common /tmp/ccJnlWp9.o:(.data+0x0): multiple definition of `n&apos; /tmp/ccM5uYLR.o:(.bss+0x0): first defined here collect2: error: ld returned 1 exit status debian@bogon:~/link$ 进程虚拟地址空间每个程序被运行起来以后，将拥有独立的虚拟地址空间（virtual address space），该虚拟地址空间的大小由计算机的硬件平台决定，具体的说由CPU的位数决定。硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为 0 到 2^32 - 1 ，即0x00000000 ~ 0xFFFFFFFF，也就是常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了 2^64 字节，即0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，总共17 179 869 184 GB. 从程序的角度看，可以通过判断C语言程序中的指针所占的空间来计算虚拟地址空间的大小，一般来说，C语言指针大小的位数与虚拟空间的位数相同，如 32 位平台下的指针为 32 位，即 4字节； 64位平台下的指针为64位，即8字节。有些特殊情况这种规则不成立。 对于32平台来说，4GB的虚拟内存空间，只有较低的3GB（从虚地址0x00000000 到 0xBFFFFFFF）供各个进程自己使用，称为用户空间；而最高的1GB（从虚地址0xC0000000 到 0xFFFFFFFF）供内核使用（所有的进程共享），称为内核空间，如下图所示。 装载的方式程序执行时所需要的指令和数据必须在内存中才能正常运行，最简单的就是将程序运行所需要的指令和数据全都装入内存中，这就是最简单的静态装入的办法。但是大多数情况程序所需的内存大于物理内存，内存昂贵，希望在不添加内存时让更多的程序运行起来。研究发现，程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。 覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。 覆盖装入在没有虚拟存储之前使用广泛，现在已经淘汰，跳过。 页映射页映射是虚拟存储机制的一部分，随着虚拟存储的发明而诞生。将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页。 实例：假设有台32位机器，共16KB内存，每个页为4KB（4096字节）。假设程序所有的指令和数据总和为32KB，那么程序总共被分为8个页，编号P0~P7.16KB的物理内存无法同时装入32KB程序，按照动态装入的原理进行整个装入过程。若程序刚开始执行时的入口地址在P0，这时装载管理器发现程序的P0不在内存中，于是将物理内存F0分配给P0，，并且将P0的内容装入F0；运行一段时间后，程序需要用到P5，于是装载管理器将P5装入F1；当程序用到P3、P6时，分别被装入F2和F3，如下映射： 如图此时程序用到了P0、P3、P5和P6，占据了所有的物理内存，若程序需要访问P4，那么装载管理器（OS的存储管理器）必须做出抉择，它必须放弃目前正在使用的4个内存页中的一个来装载P4。至于选择哪个页，有多种算法可以选择，比如可以选择F0，因为它是第一个被分配掉的内存页（FIFO，先进先出算法）；假设装载管理器发现F2很少被访问到，那么可以选择F2（LRU，Least Recently Used，最少使用算法）。目前主流的操作系统都是按照这种方式装载可执行文件。 从操作系统角度看可执行文件的装载从OS角度看，一个进程最关键的特征是它拥有独立的虚拟地址空间，使得它有别于其他进程。很多时候一个程序被执行同时伴随着一个新进程的创建：创建一个进程，装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情： 创建一个独立的虚拟地址空间。 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。 1.创建虚拟地址空间 一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。 2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。当操作系统捕获到缺页错误时，应该知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。这是整个装载过程中最重要的一步。 可执行文件在装载时实际上是被映射到虚拟空间，所以可执行文件又被叫做映像文件image。Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。VMA是一个很重要的概念，对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。 3.将CPU指令寄存器设置成可执行文件入口，启动运行操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步在操作系统层面上比较复杂，涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。在进程的角度看可以简单地认为操作系统执行了一条跳转指令，直接跳转至可执行文件的入口地址，也就是ELF文件头保存的地址。 页错误上面的步骤执行完以后，实际上可执行文件的真正指令和数据都没有被转入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。当CPU准备执行某个地址的指令时，发现其是个空页面，就认为是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况，这时候转载过程的第二步建立的数据结构起到了关键作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权交还给进程，进程从刚才页错误的位置重新开始执行。 进程虚存空间分布操作系统只关心一些跟装载相关的问题，最主要的就是段的权限（可读、可写、可执行）。ELF问减重往往只有为数不多的几种组合，基本如下三种： 以代码段为代表的权限为可读可执行的段。 以数据段和BSS段为代表的权限为可读可写的段。 以只读数据段为代表的权限为只读的段。 操作系统通过使用VMA来对进程的地址空间进行管理，栈、堆在进程的虚拟空间中同样也是以VMA的形式存在。在Linux下，可以通过查看/proc/$PID/maps获取指定进程的虚拟空间分布： 第一列是VMA的地址范围； 第二列是VMA的权限，r-读，w-写，x-可执行，p-表示私有（COW,Copy on Write），s-共享； 第三列是偏移，表示VMA对应的Segment在映像文件中的偏移； 第四列表示映像文件所在设备的主设备号和次设备号； 第五列表示映像文件的节点号； 最后一列是映像文件的路径。 该进程的5个VMA中，只有前两个是映射到可执行文件中的两个segment，另外3个主次设备号和节点号都是0，没有映射到文件中，这种VMA叫做匿名虚拟内存区域（Anonymous Virtual Memory Area）。堆占140KB，栈占88KB，这两个VMA几乎所有的进程都存在，malloc内存分配就是从堆里分配，堆由系统库管理。最后一个VMA叫做“vdso”，它的地址已经位于内核空间（即大于0xC0000000的地址），事实上它是一个内核模块，进程可以通过访问这个VMA来跟内核进行一些通信。 操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几个VMA区域： 代码VMA，只读、可执行；有映像文件。 数据VMA，可读写、可执行；有映像文件。 堆VMA，可读写，可执行；无映像文件，匿名，可向上扩展。 栈VMA，可读写、不可执行；无映像文件，匿名，可向下扩展。 Linux内核装载ELF过程在Linux的bash下输入一个命令执行某个ELF程序时，首先在用户层面，bash进程会调用fork系统调用创建一个新的进程，然后新的进程调用execve系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 在进入execve系统调用之后，Linux内核就开始进行真正的装载工作。在内核中，execve系统调用相应函数定义在exec.c(3.14版内核)文件中： SYSCALL_DEFINE3(execve, const char __user *, filename, const char __user *const __user *, argv, const char __user *const __user *, envp) { return do_execve(getname(filename), argv, envp); } 最终调用do_execve会查找被执行的文件，如果找到文件检查权限，则读取文件的前128字节(BINPRM_BUF_SIZE)。 为什么要读取前128字节呢?众所周知，Linux支持的可执行文件不止ELF一种，还有a.out、Java程序和以“#！”开始的脚本程序，读取文件的前128字节目的是判断文件的格式，每种可执行文件的格式开头几个字节都是很特殊的，特别是开头4个字节，常常被称为魔数（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如ELF的可执行文件格式的头4个字节为0x7F、e、l、f；而java的可执行文件格式头4个字节为c、a、f、e；如果被执行的是Shell或者perl、python等解释型脚本语言，那么他的第一行往往是”#!/bin/bash”或“#!/usr/bin/perl”或“#!/usr/bin/python”，这时候前两个字节‘#’和“！”就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。 当do_execve()读取了前128字节的文件头部之后，然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handle()会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做load_elf_bingary()；a.out可执行文件的装载处理过程叫做load_aout_binary()；而装载可执行脚本程序的处理过程叫做load_script()。ELF的load_elf_binary()被定义在fs/Binfmt_elf.c，主要步骤是： 检查ELF可执行文件格式的有效性。比如魔数、程序头表中段（segment）的数量； 寻找动态链接的“.interp”段，设置动态链接器路径（与动态链接有关）。 根据ELF可执行文件程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。 初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。 将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是iELFwenjian的文件头中e_entry所指的地址了对于动态链接的ELF可执行文件，程序入口点是动态链接器。 当load_elf_binary()执行完毕，返回至do_execve，上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了。所以当execve()系统调用从内核态返回到用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"编译和链接","date":"2018-11-03T05:02:48.000Z","updated":"2018-08-28T22:29:22.000Z","comments":true,"path":"编译和链接/","link":"","permalink":"http://yoursite.com/编译和链接/","excerpt":"","text":"第一章 编译和链接C语言是我们熟悉的一门语言，当我们编辑了一个C程序，然后再编译和链接，形成可执行文件在操作系统下执行时，我们是否会发出以下疑问： C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？ C代码中经常会包含头文件，那么，什么是头文件？什么又是C语言库？ 我们经常说main函数是C语言程序的入口，难道不能把其它函数当入口？ 不同的操作系统上编译好的程序可以直接拷贝过去运行吗？ 如果上面的问题你都能回答的话，那么就可以跳过本节。如果你不知道或者不是很清楚，那么我们就顺着这个思路探究下去。 1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？我们以最经典的HelloWorld程序为例。先使用vim等文本编辑器写好代码，接着在终端执行编译命令（使用的Linux系统是Debian）： gcc HelloWorld.c -o HelloWorld 这条命令在编译的同时进行了链接，形成了可执行文件HelloWorld，最后我们在终端执行 ./HelloWorld，顺利地显示了输出结果。 debian@bogon:~/Documents/HelloWorld$ vim HelloWorld.c debian@bogon:~/Documents/HelloWorld$ gcc HelloWorld.c -o HelloWorld debian@bogon:~/Documents/HelloWorld$ ./HelloWorld Hello World! debian@bogon:~/Documents/HelloWorld$ 可是，简单的命令背后经过了什么样的处理过程？gcc真的就“直接”生成了最后的可执行文件了？当然不是，我们在gcc编译命令行加上参数 –verbose要求gcc输出完整的处理过程(命令行加上 -v 也行)，我们看到了一段较长的过程输出。 debian@bogon:~/Documents/HelloWorld$ gcc --verbose HelloWorld.c -o HelloWorld Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapper Target: x86_64-linux-gnu Configured with: ../src/configure -v --with-pkgversion=&apos;Debian 6.3.0-18+deb9u1&apos; --with-bugurl=file:///usr/share/doc/gcc-6/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-6 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-6-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-6-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-6-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu Thread model: posix gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; /usr/lib/gcc/x86_64-linux-gnu/6/cc1 -quiet -v -imultiarch x86_64-linux-gnu HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/ccKizfOU.s GNU C11 (Debian 6.3.0-18+deb9u1) version 6.3.0 20170516 (x86_64-linux-gnu) compiled by GNU C version 6.3.0 20170516, GMP version 6.1.2, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15 GGC heuristics: --param ggc-min-expand=62 --param ggc-min-heapsize=60678 ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot; ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/include&quot; #include &quot;...&quot; search starts here: #include &lt;...&gt; search starts here: /usr/lib/gcc/x86_64-linux-gnu/6/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/6/include-fixed /usr/include/x86_64-linux-gnu /usr/include End of search list. GNU C11 (Debian 6.3.0-18+deb9u1) version 6.3.0 20170516 (x86_64-linux-gnu) compiled by GNU C version 6.3.0 20170516, GMP version 6.1.2, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15 GGC heuristics: --param ggc-min-expand=62 --param ggc-min-heapsize=60678 Compiler executable checksum: b8e5d7f3c4236757ee0871869b8330f3 COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; as -v --64 -o /tmp/ccyb9gCU.o /tmp/ccKizfOU.s GNU assembler version 2.28 (x86_64-linux-gnu) using BFD version (GNU Binutils for Debian) 2.28 COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; /usr/lib/gcc/x86_64-linux-gnu/6/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/6/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/6/lto-wrapper -plugin-opt=-fresolution=/tmp/ccj2W1uU.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o HelloWorld /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/6/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/6 -L/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/6/../../.. /tmp/ccyb9gCU.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/6/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/crtn.o COLLECT_GCC_OPTIONS=&apos;-v&apos; &apos;-o&apos; &apos;HelloWorld&apos; &apos;-mtune=generic&apos; &apos;-march=x86-64&apos; debian@bogon:~/Documents/HelloWorld$ 在此，我们不截取输出结果的完整图了，但你可以自己试验，然后试着分析整个流程。 图1是gcc编译过程的分解图： 从图中我们大致可以看出gcc处理HelloWorld.c的大致过程： 预处理(Prepressing)—&gt;编译(Compilation)—&gt;汇编(Assembly)—&gt;链接(Linking) 括号中注明了各个过程中实际执行任务的程序名称：预处理器cpp、编译器cc1、汇编器as以及最后的链接器ld。 2. 预处理到底做什么？我们在终端输入命令 gcc -E HelloWorld.c -o HelloWorld.i，然后打开输出文件HelloWorld.i： # 1 &quot;/usr/include/x86_64-linux-gnu/bits/wordsize.h&quot; 1 3 4 # 28 &quot;/usr/include/x86_64-linux-gnu/bits/types.h&quot; 2 3 4 typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; 首先是大段的变量和函数的声明，我们的代码找不到了，到底去哪了？在vim编辑环境的普通模式中按下shift+g(大写G)跳到文件的底部，终于在几千行以后看到了我们可怜兮兮的几行代码。 int main(){ printf(&quot;Hello World!\\n&quot;); return 0; } 前面几千行代码是做什么的？其实它就是 /usr/include/stdio.h 文件的所有内容，预处理器把所有的#include替换为实际文件的内容了。这个过程是递归进行的，所以stdio.h里面的#include也被实际内容所替换了。 而且我在HelloWorld.c里面的所有注释被预处理器全部删除了。就连printf语句前的Tab缩进也被替换为一个空格了，显得代码都不美观了。 通过观察这些内容，我们梳理出预处理器处理的大致所做的事情： 展开所有的宏定义并删除 #define 处理所有的条件编译指令，例如 #if #else #endif #ifndef … 把所有的 #include 替换为头文件实际内容，递归进行 把所有的注释 // 和 / / 替换为空格 添加行号和文件名标识以供编译器使用 保留所有的 #pragma 指令，因为编译器要使用 基本上就是这些内容。（在这里顺便插播一个小技巧，在代码中有时候宏定义比较复杂的时候我们很难判断其处理后的结构是否正确。这个时候我们就可以使用gcc的-E参数输出处理结果来判断） 前文中我们提到头文件中存放的是变量定义和函数声明等等内容。这些内容到底是什么？其实在早期调用函数时并不需要声明，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，所有编译器开始要求对所有使用的变量或者函数给出声明，以支持编译器进行参数检查和类型匹配。头文件包含的基本上就是这些东西和一些预先的宏定义来方便程序员编程。其实对于我们的HelloWorld.c程序来说不需要这个庞大的头文件，只需要在main函数前声明printf函数，不需要#include即可通过编译。 声明如下： int printf(const char *format, ...); 大家可以自行测试。另外再补充一点，gcc其实并不要求函数一定要在被调用之前定义或者声明，因为gcc在处理到某个未知类型的函数时，会为其创建一个隐式声明，并假设该函数返回值类型为int。但gcc此时无法检查传递给该函数的实参类型和个数是否正确，不利于编译器为我们排除错误（而且如果该函数的返回值不是int的话也会出错）。所以还是建议大家在函数调用前，先对其定义或声明。 3. 编译做什么？了解了预处理之后，我们接着看编译和汇编。什么是编译？一句话描述：编译就是把预处理之后的文件进行一系列词法分析、语法分析、语义分析以及优化后生成的相应汇编代码文件。 怎么查看编译后的汇编代码？命令： gcc -S HelloWorld.c -o HelloWorld.s 这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意。顺便说一句，这里生成的汇编是AT&amp;T风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 -masm=intel ,这样gcc就会生成Intel风格的汇编代码了（如图）。不过gcc的内联汇编只支持AT&amp;T风格，我们在第二章会给予介绍。 .file &quot;HelloWorld.c&quot; .intel_syntax noprefix .section .rodata .LC0: .string &quot;Hello World!&quot; .text .globl main .type main, @function main: .LFB0: .cfi_startproc push rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 mov rbp, rsp .cfi_def_cfa_register 6 lea rdi, .LC0[rip] call puts@PLT mov eax, 0 pop rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident &quot;GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 4. 汇编做什么？我们继续用一句话来描述：汇编就是将编译后的汇编代码翻译为机器码，几乎每一条汇编指令对应一句机器码。 命令： gcc -c HelloWorld.c 可以让编译器只进行到生成目标文件这一步，这样我们就能在目录下看到HelloWorld.o文件了。 Linux下的可执行文件以及目标文件的格式叫作ELF(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，Linux下的ELF也罢，都是COFF(Common file format)格式的一种变种，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因不只是这一点，不同的操作系统接口（windows API和Linux的API不同）以及相关的类库不同也是原因之一。 更详细的内容可以参看《程序员的自我修养》了解。 5. 链接做什么？这一步是将汇编产生的目标文件和所使用的库函数的目标文件链接生成一个可执行文件的过程。在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一是链接造成的错误通常难以理解和处理，二是在开发中使用第三方库越来越常见了，大家可能更需要稍微了解一些细节。 首先介绍一下gnu binutils工具包，这是一整套的二进制分析处理工具包。详细介绍请大家参考维基百科：http://zh.wikipedia.org/wiki/GNU_Binutils 一般系统安装包中都带了这套工具包，如果你的发行版没有，请自行搜索进行安装。 这套工具包含了足够多的工具，我们甚至可以用来研究ELF文件的格式等内容。不过本节只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。 链接这个话题涉及的内容相当广泛，为了避免本节牵扯到过多的话题导致言之泛泛，我们先设定本节讨论的范围。在这里只讨论链接进行的大致步骤及其规则、静态链接库与动态链接库的创建和使用这两大问题。至于可执行文件的加载、可执行文件的运行时储存器映像之类的内容我们暂时不讨论。那么，什么是链接？我们引用《深入理解计算机系统》中的定义：链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。 需要强调的是，链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时（run time），由应用程序来执行。 那么，了解链接到底有什么用？继续引用《深入理解计算机系统》的说法，如下： 理解链接器将帮助你构造大型程序。 理解链接器将帮助你避免一些危险的编程错误。 理解链接将帮助你理解语言的作用域是如何实现的。 理解链接将帮助你理解其他重要的系统概念。 理解链接将使你能够利用共享库。 言归正传。为了避免我们的描述过于枯燥，我们还是以C语言为例。大家通过我们前面的描述，已经知道C代码编译后的目标文件了。目标文件最终要和标准库进行链接生成最后的可执行文件。那么，标准库和我们生成的目标文件是什么关系？ 其实，任何一个程序，它的背后都有一套庞大的代码在支撑着它，以使得该程序能够正常运行。这套代码至少包括入口函数、以及其所依赖的函数构成的函数集合。当然，它还包含了各种标准库函数的实现。 这个“支撑模块”就叫做运行时库（Runtime Library）。而C语言的运行库，即被称为C运行时库（CRT）。 CRT大致包括：启动与退出相关的代码（包括入口函数及入口函数所依赖的其他函数）、标准库函数（ANSI C标准规定的函数实现）、I/O相关、堆的封装实现、语言特殊功能的实现以及调试相关。其中标准库函数的实现占据了主要地位。标准库函数比如我们平时常用的printf，scanf函数等。C语言标准库在不同的平台上实现了不同的版本，我们只要依赖其接口定义，就能保证程序在不同平台上的一致行为。C语言标准库有24个，囊括标准输入输出、文件操作、字符串操作、数学函数以及日期等等内容。大家有兴趣的可以自行搜索。 5.1 静态链接库既然C语言提供了标准库函数供我们使用，那么以什么形式提供？是源代码吗？当然不是。下面引入静态链接库的概念。我们几乎每一次写程序都难免去使用库函数，那么每一次去编译岂不是太麻烦了。干嘛不把标准库函数提前编译好，需要的时候直接链接？是的，标准库就是这么做的。那么，标准库以什么形式存在？是一个目标文件？我们知道，链接的最小单位就是一个个目标文件，如果我们只用到一个printf函数，但需要和整个库链接的话岂不是太浪费资源了么？但是，如果把库函数分别定义在彼此独立的代码文件中，这样编译出后就形成一大堆目标文件。所以，编辑器系统提供了一种机制，将所有的编译出来的目标文件打包成一个单独的文件，叫做静态库（static library）。当链接器和静态库链接的时候，链接器会从这个打包的文件中“解压缩”出需要的部分目标文件进行链接。这样就解决了资源浪费的问题。 Linux/Unix系统下ANSI C的库名叫做libc.a，另外数学函数单独在libm.a库中。当了解以上相关知识后，我们试着自己做一个静态库。为了简单起见我们就做一个只有两个函数的私有库。 在swap.c里定义一个swap函数，在add.c里定义了一个add函数。最后还有含有它们声明的calc.h头文件。 // swap.c void swap(int *num1, int *num2) { int tmp = *num1; *num1 = *num2; *num2 = tmp; } // add.c int add(int a, int b) { return a + b; } // calc.h #ifndef CALC_H_ #define CALC_H_ #ifdef _cplusplus extern &quot;C&quot; { #endif void swap(int *, int *); int add(int, int); #ifdef _cplusplus } #endif #endif // CALC_H_ 我们分别编译它们得到了swap.o和add.o这两个目标文件，最后使用ar命令将其打包为一个静态库。 debian@bogon:~/Documents/link$ gcc add.c -c -o add.o debian@bogon:~/Documents/link$ gcc swap.c -c -o swap.o debian@bogon:~/Documents/link$ ls add.c add.o calc.h swap.c swap.o debian@bogon:~/Documents/link$ ar rcs libcalc.a swap.o add.o debian@bogon:~/Documents/link$ ls add.c add.o calc.h libcalc.a swap.c swap.o debian@bogon:~/Documents/link$ 现在我们怎么使用这个静态库呢？我们写一个test.c使用这个库中的swap函数。代码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &quot;calc.h&quot; int main(int argc, char *argv[]) { int a = 1, b = 2; swap(&amp;a, &amp;b); printf(&quot;%d %d\\n&quot;, a, b); return EXIT_SUCCESS; } 下来是编译执行，命令行执行gcc test.c ./libcalc.a -o test编译，执行。如图，我们输出了预期的结果。 debian@bogon:~/Documents/link$ gcc test.c ./libcalc.a -o test debian@bogon:~/Documents/link$ ./test 2 1 debian@bogon:~/Documents/link$ 可能你会问，我们使用C语言标准库的时候，编译时并不需要加库名。是的，的确不需要，那是因为标准库已经是标准了，所以会被默认链接。不过因为数学函数库libm.a没有默认链接，所以我们使用了数学函数的代码在编译时需要在命令行指定 -lm 链接（-l是指定链接库，m是去掉lib之后的库名），不过现在好多gcc都默认链接libm.c库了。 正如我们所看到的，静态链接库解决了一些问题，但是它同时带来了另一些问题。比如说每一个使用了相同的C标准函数的程序都需要和相关目标文件进行链接，浪费磁盘空间；当一个程序有多个副本执行时，相同的库代码部分被载入内存，浪费内存；当库代码更新之后，使用这些库的函数必须全部重新编译等等。 5.2 动态链接库是否有更好的办法？当然有。我们接下来引入动态链接库/共享库（shared library）。 动态链接库/共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个正在运行的程序链接起来。这个过程就是动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序完成的。 Unix/Linux中共享库的后缀名通常是.so（微软就是DLL文件）。那么，如何建立一个动态链接库？ 我们还是以上面的代码为例，首先删除之前的静态库和目标文件。要建立动态链接库，在命令行输入： gcc swap.c add.c -shared -o libcalc.so 顺便说一下，最好在gcc命令行加上一句-fPIC让其生成与位置无关的代码（PIC），具体原因超出本文范围，故暂不予讨论。 debian@bogon:~/Documents/link$ gcc swap.c add.c -shared -o libcalc.so debian@bogon:~/Documents/link$ ls add.c add.o calc.h libcalc.a libcalc.so swap.c swap.o test test.c debian@bogon:~/Documents/link$ 如何使用动态链接库？我们继续编译测试代码，执行gcc test.c -o test ./libcalc.so即可。运行后我们仍旧得到了预期的结果。 debian@bogon:~/Documents/link$ gcc test.c -o test ./libcalc.so debian@bogon:~/Documents/link$ ./test 2 1 debian@bogon:~/Documents/link$ 这看起来也没什么不一样的。其实不然，我们用ldd命令（ldd是我们推荐的GNU binutils工具包的组成之一）检查test文件的依赖。 debian@bogon:~/Documents/link$ ldd ./test linux-vdso.so.1 (0x00007fff3d3fb000) ./libcalc.so (0x00007f61c97de000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61c943f000) /lib64/ld-linux-x86-64.so.2 (0x00007f61c9be2000) debian@bogon:~/Documents/link$ 我们看到这个文件能顺利运行需要依赖libcalc.so这个动态库，我们还能看到C语言的标准库默认也是动态链接的（在gcc编译的命令行加上 -static 可以要求静态链接）。 好处何在？第一，库更新之后，只需要替换掉动态库文件即可，无需编译所有依赖库的可执行文件。第二，程序有多个副本执行时，内存中只需要一份库代码，节省空间。 大家想想，C语言标准库好多程序都在用，但内存只有一份代码，这样节省的空间就相当可观了，而且假如库代码发现bug，只需要更新libc.so即可，所有程序即可使用新的代码，代码的可维护性提高。 关于库的内容还很多，就此介绍到这里。 5.3 链接的步骤我们来看看链接过程中具体做的事情。链接的步骤大致包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等主要步骤。 首先是地址和空间分配，我们之前提到的目标文件其实全称叫做可重定位目标文件（这只是一种名称，还有其他名称）。目标文件的格式已经无限度接近可执行文件了，Unix/Linux下的目标文件的格式叫做ELF（Executable and Linkable Format，可执行连接格式）。本节暂不详细讨论可执行文件的格式，我们只需要知道可执行文件中代码，数据，符号等内容分别存储在不同的段中就可以，这也和第二章保护模式下的内存分段是有一定关系的。我们简单叙述了地址和空间分配以及重定位，但是稍微详细说明一下符号决议。 什么是符号（symbol）？简单说我们在代码中定义的函数和变量可以统称为符号。符号名（symbol name）就是函数名和变量名了。 目标文件的拼合其实也就是对目标文件之间相互的符号引用的一个修正。我们知道一个C语言代码文件只要所有的符号被声明过就可以通过编译了，可是对某符号的引用怎么知道位置呢？比如我们调用了printf函数，编译时留下了要填入的函数地址，那么printf函数的实际地址在哪里？这个空位什么时候修正呢？当然是链接的时候，重定位那一步就是做这个的。但是在修改地址之前需要做符号决议，那什么是符号决议？正如前文所说，编译期间留下了很多需要重新定位的符号，所以目标文件中会有一块区域专门保存符号表。链接器如何知道具体位置？其实链接器并不知道，所以链接器会搜索全部的待链接的目标文件，寻找这个符号的位置，然后修正每一个符号的地址。 在此我们要重点介绍一下在编译程序时几乎所有人会遇见的问题——符号查找问题。在编译时通常会碰到两种编译错误，即找不到某符号或者符号重定义。 首先介绍找不到符号的情况，比如，当我们声明了一个swap函数却没有定义它的时候，我们调用这个函数的代码可以通过编译，但是在链接期间却会遇到错误。形如“test.c:(.text+0x29): undefined reference to ‘swap’”这样，特别的，MSVC编译器报错是找不到符号_swap。这个下划线从哪里来的？这得从C语言刚诞生说起。当C语言刚面世的时候，已经存在不少用汇编语言写好的库了，因为链接器的符号唯一规则，假如该库中存在main函数，我们就不能在C代码中出现main函数了，因为会遭遇符号重定义错误，倘若放弃这些库又是一大损失。所以当时的编译器会对代码中的符号进行修饰（name decoration），C语言的代码会在符号前加下划线，fortran语言在符号前后都加下划线，这样各个目标文件就不会同名了，就解决了符号冲突的问题。随着时间的流逝，操作系统和编译器都被重写了好多遍，当前的这个问题已经可以忽略。所以新版的gcc一般不会再加下划线做符号修饰（也可以在编译的命令行加上-fleading-underscore/-fno-fleading-underscore开打开/关闭这个是否加下划线）。而MSVC依旧保留了这个传统，所以我们可以看到_swap这样的修饰。 顺便说一下，符号冲突是很常见的事情，特别是在大型项目的开发中，所以我们需要一个约定良好的命名规则。C++也引入了命名空间来帮助我们解决这些问题，因为C++中存在函数重载，所以C++的符号修饰更加复杂难懂（Linux下有c++filt命令帮助我们翻译一个被C++编译器修饰过的符号）。 那么，当出现同名符号时链接器到底如何处理。刚才说过会报告重名错误，为什么还要进行探讨？实际上，不仅仅这么简单。在编译时，编译器会向汇编器输出每个全局符号，分为强（strong）符号和弱符号（weak），汇编器把这个信息隐含的编码在可重定位目标文件的符号表里。其中函数和已初始化过的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义，GNU链接器采用的规则如下： 不允许多个强符号 如果有一个强符号和一个或多个弱符号，则选择强符号 如果有多个弱符号，则随机选择一个 其中，第一条会报符号重名错误的，而后两条默认情况下甚至连警告都不会有。关键就在这里，默认甚至连警告都没有。 我们来个实验具体说一下： // link1.c #include &lt;stdio.h&gt; int n; int main(int argc, char *argv[]) { printf(&quot;It is %d\\n&quot;, n); return 0; } // link2.c int n = 5; 这两个文件编译运行会输出什么呢？想必你已经知道了结果，没错，就是5 debian@bogon:~/Documents/link$ vim link1.c debian@bogon:~/Documents/link$ vim link2.c debian@bogon:~/Documents/link$ gcc link1.c link2.c -o link debian@bogon:~/Documents/link$ ./link It is 5 debian@bogon:~/Documents/link$ 初始化过的n是强符号，被优先选择了。但是，在很复杂的项目代码中，这样的错误很难发现，特别是多线程的代码，不过当我们怀疑代码中的bug可能是因为此原因引起的时候，我们可以在gcc命令行加上-fno-common这个参数，这样链接器在遇到多重定义的符号时，都会给出一条警告信息，而无关强弱符号。如下所示： debian@bogon:~/Documents/link$ gcc link1.c link2.c -o link -fno-common /tmp/ccJnlWp9.o:(.data+0x0): multiple definition of `n&apos; /tmp/ccM5uYLR.o:(.bss+0x0): first defined here collect2: error: ld returned 1 exit status debian@bogon:~/Documents/link$","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"第一阶段计划表","date":"2018-11-03T05:02:48.000Z","updated":"2018-10-08T00:35:10.000Z","comments":true,"path":"第一阶段计划表/","link":"","permalink":"http://yoursite.com/第一阶段计划表/","excerpt":"","text":"一周：9.10服务器管理 从数据表server中获取所有服务器并显示 可筛选查看 日志查询 通过条件从warning中查询日志并显示 多条件查询，时间、消息类型、电厂名称等 一周：9.17实时告警 实时（通过定时器）从数据表warning中获取最新的日志显示 可选择要显示的日志类型、可清空、对日志可以操作状态（已解决、未解决） 根据重要性统计以饼状图显示（紧急、重要、一般）、并以线性图显示趋势（近一周、近一月、近一年） 上面显示图表，下面以列表显示日志 二周：10.1系统运行统计图 按消息类型统计，以柱状图显示 按操作类型统计，以柱状图显示 按电厂属性统计，以饼状图显示 在线统计 按告警级别统计，以饼状图统计 第二阶段","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Linux内核分析-孟宁","date":"2018-11-03T05:02:46.000Z","updated":"2018-06-13T16:15:42.000Z","comments":true,"path":"Linux内核分析-孟宁/","link":"","permalink":"http://yoursite.com/Linux内核分析-孟宁/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Hello Docker World","date":"2018-11-03T05:02:46.000Z","updated":"2018-09-28T05:17:50.000Z","comments":true,"path":"Hello Docker World/","link":"","permalink":"http://yoursite.com/Hello Docker World/","excerpt":"","text":"安装Docker命令： #wget -qO- https://get.docker.com | sh 允许非root用户： #usermod -aG docker xxx //把xxx用户添加到docker用户组中 拉docker镜像： #docker pull nginx 查看已安装docker镜像： #docker images 启动nginx服务 #docker run -p 8080:80 -d nginx 列出运行中的容器 #docker ps 编辑html文件，添加Hello Docker World #vim index.html 拷贝文件： #docker cp index.html 容器id://usr/share/nginx/html 查看主页：localhost:8080","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"JavaScript 教程","date":"2018-11-03T05:02:46.000Z","updated":"2018-06-05T00:58:14.000Z","comments":true,"path":"JavaScript 教程/","link":"","permalink":"http://yoursite.com/JavaScript 教程/","excerpt":"","text":"JavaScript 简介JavaScript 是世界上最流行的编程语言。这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。 JavaScript 很容易学习。 JavaScript：写入 HTML 输出实例document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;); document.write(&quot;&lt;p&gt;This is a paragraph&lt;/p&gt;&quot;); 提示您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。 JavaScript：对事件作出反应实例&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;Welcome!&apos;)&quot;&gt;点击这里&lt;/button&gt; 亲自试一试alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。 onclick 事件只是您即将在本教程中学到的众多事件之一。 JavaScript：改变 HTML 内容使用 JavaScript 来处理 HTML 内容是非常强大的功能。 实例x=document.getElementById(&quot;demo&quot;) //查找元素 x.innerHTML=&quot;Hello JavaScript&quot;;//改变内容 亲自试一试您会经常看到 document.getElementByID(“some id”)。这个方法是 HTML DOM 中定义的。 DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。 您将在本教程的多个章节中学到有关 HTML DOM 的知识。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"JavaScript笔记","date":"2018-11-03T05:02:46.000Z","updated":"2018-06-05T01:36:38.000Z","comments":true,"path":"JavaScript笔记/","link":"","permalink":"http://yoursite.com/JavaScript笔记/","excerpt":"","text":"JavaScript笔记 在 JavaScript 中，用分号来结束语句是可选的。 块的作用是使语句序列一起执行。 反斜杠对代码行进行换行 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等 如果把数字与字符串相加，结果将成为字符串。 JavaScript 库常被称为 JavaScript 框架：jQuery、Prototype、MooTools","categories":[],"tags":[],"keywords":[]},{"title":"BLurAdmin界面设计","slug":"BLurAdmin界面设计","date":"2018-10-14T16:00:00.000Z","updated":"2018-10-08T02:13:46.000Z","comments":true,"path":"BLurAdmin界面设计/","link":"","permalink":"http://yoursite.com/BLurAdmin界面设计/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的AI操作系统，以01为基因，内核为灵魂， 文章前景0x01-知识储备0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git0x03-方案设计 复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。 方案A方案B0x04-实践操作0x05-总结分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下 考虑到： 理论与实践 抽象与具体 现状与未来 调试优化（折中与平衡）用户体验：应用性能： 截图时间点（I/O）： 输入：命令、按钮 输出：变化、结果 ——&gt;I/O截图法","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}],"keywords":[]},{"title":"MariaDB数据库学习","slug":"MariaDB数据库学习","date":"2018-10-07T16:00:00.000Z","updated":"2018-10-09T02:59:16.000Z","comments":true,"path":"MariaDB数据库学习/","link":"","permalink":"http://yoursite.com/MariaDB数据库学习/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-参考资料 0x00-文章前言文章目的 熟悉数据库操作基本流程、数据操作命令、编程接口 建立一个简单表格，可以通过相关语句进行操作 了解MariaDB的相关语法，为后期项目开发做准备 文章前景 有益于对数据库基本操作的掌握 有助于对MariDB语法的学习 有利于对后期相关项目的顺利进展 0x01-知识储备MariaDB命令大全MariaDB语法大全0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 MariaDB 0x03-方案设计UI操作操作起来较为简单，适合于小量数据，用户体验度高 命令操作使用SQL语句操作，由于使用命令，可复用操作大量数据，效率高 0x04-实践验证安装 创建数据库查看数据库删除数据库 创建表格 删除表格 插入数据 查询数据 更新数据 删除数据 0x05-总结分析0x06-参考资料 百度一下 百度一下","categories":[],"tags":[{"name":"MariaDB","slug":"MariaDB","permalink":"http://yoursite.com/tags/MariaDB/"}],"keywords":[]},{"title":"饼状图显示与统计","slug":"表格操作与功能完善","date":"2018-09-30T16:00:00.000Z","updated":"2018-10-08T02:12:36.000Z","comments":true,"path":"表格操作与功能完善/","link":"","permalink":"http://yoursite.com/表格操作与功能完善/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的文章前景0x01-知识储备linux系统数据结构深入理解计算机系统操作系统原理0x02-测试环境硬件环境软件环境0x03-方案设计方案A方案B0x04-实践验证实践操作实践结果0x05-总结分析文章结论文章分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下","categories":[],"tags":[{"name":"BlurAdmin","slug":"BlurAdmin","permalink":"http://yoursite.com/tags/BlurAdmin/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://yoursite.com/tags/MariaDB/"}],"keywords":[]},{"title":"柱状图设计与显示","slug":"柱状图设计与显示","date":"2018-09-23T16:00:00.000Z","updated":"2018-10-08T02:11:44.000Z","comments":true,"path":"柱状图设计与显示/","link":"","permalink":"http://yoursite.com/柱状图设计与显示/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的AI操作系统，以01为基因，内核为灵魂， 文章前景0x01-知识储备0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git0x03-方案设计 复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。 方案A方案B0x04-实践操作0x05-总结分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下 考虑到： 理论与实践 抽象与具体 现状与未来 调试优化（折中与平衡）用户体验：应用性能： 截图时间点（I/O）： 输入：命令、按钮 输出：变化、结果 ——&gt;I/O截图法","categories":[],"tags":[{"name":"BlurAdmin","slug":"BlurAdmin","permalink":"http://yoursite.com/tags/BlurAdmin/"}],"keywords":[]},{"title":"list.h源码解读","slug":"list.h源码解读","date":"2018-09-18T16:00:00.000Z","updated":"2018-09-25T00:29:36.000Z","comments":true,"path":"list.h源码解读/","link":"","permalink":"http://yoursite.com/list.h源码解读/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的文章前景0x01-知识储备条件编译 0x02-测试环境硬件环境软件环境0x03-方案设计方案B0x04-实践验证实践操作实践结果0x05-总结分析文章结论文章分析0x06-程序源码linux-2.6.11 代码A代码B0x07-参考资料 百度一下 百度一下","categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://yoursite.com/tags/Kernel/"}],"keywords":[]},{"title":"实时警告模块设计与实现","slug":"实时警告模块设计与实现","date":"2018-09-16T16:00:00.000Z","updated":"2018-10-08T02:10:56.000Z","comments":true,"path":"实时警告模块设计与实现/","link":"","permalink":"http://yoursite.com/实时警告模块设计与实现/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的AI操作系统，以01为基因，内核为灵魂， 文章前景0x01-知识储备0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git0x03-方案设计 复杂系统，标准的过程应当在业务建模，需求分析，分析设计，实施开发，测试，部署完整过程的分析设计（与开发语言无关）或实施开发（分析设计的成果映射为具体语言，例如Java、.NET等）阶段才考虑设计模式、架构模式的引入。设计模式的使用会经历僵化-&gt;固化-&gt;优化的阶段，类似禅修中“看山是山、看水是水”的三个阶段，才能体会模式的运用之妙。 方案A方案B0x04-实践操作0x05-总结分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下 考虑到： 理论与实践 抽象与具体 现状与未来 调试优化（折中与平衡）用户体验：应用性能： 截图时间点（I/O）： 输入：命令、按钮 输出：变化、结果 ——&gt;I/O截图法","categories":[],"tags":[{"name":"BlurAdmin","slug":"BlurAdmin","permalink":"http://yoursite.com/tags/BlurAdmin/"}],"keywords":[]},{"title":"表格设计与查询显示","slug":"表格设计与查询显示","date":"2018-09-09T16:00:00.000Z","updated":"2018-10-08T02:04:14.000Z","comments":true,"path":"表格设计与查询显示/","link":"","permalink":"http://yoursite.com/表格设计与查询显示/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的服务器管理 从数据表server中获取所有服务器并显示 可筛选查看 日志查询 通过条件从warning中查询日志并显示 多条件查询，时间、消息类型、电厂名称等 文章前景0x01-知识储备0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git0x03-方案设计 方案Aserver服务器管理 warning日志查询实时警告 系统运行图 方案B0x04-实践操作0x05-总结分析文章结论文章分析0x06-程序源码代码A代码B0x07-参考资料 百度一下 百度一下","categories":[],"tags":[{"name":"BlurAdmin","slug":"BlurAdmin","permalink":"http://yoursite.com/tags/BlurAdmin/"}],"keywords":[]},{"title":"Ajax数据显示","slug":"Ajax数据显示","date":"2018-09-02T16:00:00.000Z","updated":"2018-10-08T02:03:50.000Z","comments":true,"path":"Ajax数据显示/","link":"","permalink":"http://yoursite.com/Ajax数据显示/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的 实现页面数据动态刷新，而不是全部刷新整个页面 页面在首次加载后，剩下的所有数据通过Ajax更新 文章前景 节约系统资源，使得浏览器页面占用更少硬件资源 加快响应速度，使得浏览器运行更加流畅，机器效率更高 0x01-知识储备Ajax基础Ajax框架介绍 Ajax的全称是Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），其中，Asynchronous 是 异步 的意思，它有别于传统web开发中采用的同步的方式。 Ajax不是编程语言，是一种在与服务器交换数据无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换。Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页面。 Ajax的应用使用支持以上技术的web浏览器作为运行平台。这些浏览器目前包括：Mozilla、Firefox、Internet Explorer、Opera、Konqueror及Safari。但是Opera不支持XSL格式对象，也不支持XSLT。 Ajax工作原理 Ajax工作原理是提供与服务器异步通信的能力，从而使用户从请求/响应的循环中解脱出来。 借助于Ajax，可以在用户单击按钮时，使用JavaScript和DHTML立即更新UI，并向服务器发出异步请求，以执行更新或查询数据库。 当请求返回时，就可以使用JavaScript和CSS来相应地更新UI，而不是刷新整个页面。 最重要的是，用户甚至不知道浏览器正在与服务器通信：Web站点看起来是即时响应的。 Node.js基础 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。 除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git 0x03-方案设计静态数据方案使用Ajax框架传递静态数据给页面，查看页面数据 动态数据方案使用Ajax框架传递动态数据给页面，观察页面数据变化 0x04-实践操作静态数据方案启动服务器node server 打开页面index.html 动态数据方案打开页面index2.html 修改重启 数据库数据显示基于PostgreSQL操作接口中所创建的数据库表Log_Inf，server3.js和index.html为数据库数据显示代码 安装pg模块 启动服务器 打开页面index3.html 查看数据库表格 插入数据 查看当前表格 查看GitBash输出 查看页面 0x05-总结分析Ajax特点 Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。 AJAX请求是异步执行的，也就是说，要通过回调函数获得响应 传统交互模型 浏览器直接将请求发送给服务器，服务器回送响应，直接发给浏览器 同步交互模式，客户端提交请求，等待，在响应回到客户端前，客户端无法进行其他操作 Ajax交互模型 浏览器首先将请求 发送 Ajax引擎（以XMLHttpRequest为核心），AJax引擎再将请求发送给 服务器，服务器回送响应先发给Ajax引擎，再由引擎传给浏览器显示 异步交互模型，客户端将请求提交给Ajax引擎，客户端可以继续操作，由Ajax引擎来完成与服务武器端通信 0x06-程序源码server.jsvar http = require(&apos;http&apos;); var urlLib = require(&apos;url&apos;); var data = { content:`你好`//动态数据方案中需修改 content:`你好` 为： content:`你好呀！` }; http.createServer(function(req,res){ //parse用于从一个字符串中解析出json对象 var parms = urlLib.parse(req.url,true); //stringify()用于从一个对象解析出字符串 var str = parms.query.callback + &apos;(&apos; + JSON.stringify(data) +&apos;)&apos;; res.end(str); }).listen(8088); console.log(&apos;Server running on port http://127.0.0.1:8088/&apos;); index.html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;div id=&quot;date&quot;&gt;&lt;/div&gt; &lt;!-- &lt;button id=&quot;btn&quot;&gt;请点击&lt;/button&gt;--&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() { // $(&quot;#btn&quot;).click(function(){ $.ajax({ url: &apos;http://127.0.0.1:8088/&apos;, dataType: &quot;jsonp&quot;,//jsonp是针对于get的跨域解决办法 data: &apos;{&quot;data&quot;: &quot;TEST&quot;}&apos;, type: &apos;GET&apos;, jsonpCallback: &apos;callback&apos;, // 这与POST不相关 success: function (data) { console.log(data); // var ret = jQuery.parseJSON(data);//jQuery.parseJSON() 函数用于将格式完好的JSON字符串转为与之对应的JavaScript对象。 //所谓&quot;格式完好&quot;，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。 $(&apos;#date&apos;).html(data.content); // console.log(&apos;Success!&apos;) }, error: function (xhr, status, error) { console.log(&apos;Error: &apos; + error.message); $(&apos;#lblResponse&apos;).html(&apos;Error connecting to the server.&apos;); }, }); // }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; index2.html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;div id=&quot;date&quot;&gt;&lt;/div&gt; &lt;!-- &lt;button id=&quot;btn&quot;&gt;请点击&lt;/button&gt;--&gt; &lt;script type=&quot;text/javascript&quot;&gt; function doUpdate() { $(document).ready(function() { // $(&quot;#btn&quot;).click(function(){ $.ajax({ url: &apos;http://127.0.0.1:8088/&apos;, dataType: &quot;jsonp&quot;,//jsonp是针对于get的跨域解决办法 data: &apos;{&quot;data&quot;: &quot;TEST&quot;}&apos;, type: &apos;GET&apos;, jsonpCallback: &apos;callback&apos;, // 这与POST不相关 success: function (data) { console.log(data); // var ret = jQuery.parseJSON(data);//jQuery.parseJSON() 函数用于将格式完好的JSON字符串转为与之对应的JavaScript对象。 //所谓&quot;格式完好&quot;，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。 $(&apos;#date&apos;).html(data.content); // console.log(&apos;Success!&apos;) }, error: function (xhr, status, error) { console.log(&apos;Error: &apos; + error.message); $(&apos;#lblResponse&apos;).html(&apos;Error connecting to the server.&apos;); }, }); // }); }); console.log(&quot;doUpdate&quot;); window.setTimeout(&quot;doUpdate()&quot;, 3000); } doUpdate(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; server3.jsvar http = require(&apos;http&apos;); var urlLib = require(&apos;url&apos;); var data; function doUpdate(){ function _select(client,selectSQLString) { // console.log(&quot;select beginning&quot;); client.query(selectSQLString, function selectCb(error, results, fields) { // console.log(&quot;in select callback function&quot;); if (error) { console.log(&apos;GetData Error: &apos; + error.message), client.end(); return; } if(results.rowCount &gt; 0) { var firstResult, resultSet = &apos;&apos;; for(var i = 0, len = results.rowCount; i &lt; len; i++) { firstResult = results.rows[i]; resultSet += &apos;id:&apos; + firstResult[&apos;id&apos;] + &apos; &apos; + &apos;type:&apos; + firstResult[&apos;type&apos;] + &apos; &apos; + &apos;rank:&apos; + firstResult[&apos;rank&apos;] + &apos; &apos;; } } console.log(resultSet); data = { content:&apos;你好吗？&apos;, content1:resultSet }; /* 添加功能：使查询结果集返回到客户端并保证此函数的通用性. */ }); // console.log(&quot;select end\\n&quot;); } var pg = require(&apos;pg&apos;); var conString = &quot;tcp://postgres:111111@localhost:5432/test&quot;;//1.连接 var client = new pg.Client(conString); selectSQLString = &apos;select * from Log_Inf&apos;; client.connect(function(error, results) { if(error){ console.log(&apos;ClientConnectionReady Error: &apos; + error.message); client.end(); return; } _select(client,selectSQLString); }); console.log(&quot;hello&quot;); setTimeout(doUpdate,3000); } doUpdate(); http.createServer(function(req,res){ //parse用于从一个字符串中解析出json对象 var parms = urlLib.parse(req.url,true); //stringify()用于从一个对象解析出字符串 var str = parms.query.callback + &apos;(&apos; + JSON.stringify(data) +&apos;)&apos;; res.end(str); }).listen(8088); console.log(&apos;Server running on port http://127.0.0.1:8088/&apos;); index3.html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; 文件数据： &lt;div id=&quot;date&quot;&gt;&lt;/div&gt; &lt;br&gt; 数据库数据： &lt;div id=&quot;date1&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function doUpdate() { $(document).ready(function() { // $(&quot;#btn&quot;).click(function(){ $.ajax({ url: &apos;http://127.0.0.1:8088/&apos;, dataType: &quot;jsonp&quot;,//jsonp是针对于get的跨域解决办法 data: &apos;{&quot;data&quot;: &quot;TEST&quot;}&apos;, type: &apos;GET&apos;, jsonpCallback: &apos;callback&apos;, // 这与POST不相关 success: function (data) { console.log(data); // var ret = jQuery.parseJSON(data);//jQuery.parseJSON() 函数用于将格式完好的JSON字符串转为与之对应的JavaScript对象。 //所谓&quot;格式完好&quot;，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。 $(&apos;#date&apos;).html(data.content); $(&apos;#date1&apos;).html(data.content1); // console.log(&apos;Success!&apos;) }, error: function (xhr, status, error) { console.log(&apos;Error: &apos; + error.message); $(&apos;#lblResponse&apos;).html(&apos;Error connecting to the server.&apos;); }, }); // }); }); console.log(&quot;hello&quot;); window.setTimeout(&quot;doUpdate()&quot;, 3000); } doUpdate(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 源码打包Ajax-Demo（密码：busg） 0x07-参考资料 AJAX教程 AJAX-廖雪峰的官方网站 PostgreSQL操作接口","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[]},{"title":"BlurAdmin应用开发","slug":"BlurAdmin应用开发","date":"2018-08-26T16:00:00.000Z","updated":"2018-10-06T06:08:20.000Z","comments":true,"path":"BlurAdmin应用开发/","link":"","permalink":"http://yoursite.com/BlurAdmin应用开发/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的 以BlurAdmin模板开发为主，结合Electron打包成桌面应用 学会使用基于Gulp的脚手架进行简单的构建，完善BlurAdmin应用开发 文章前景 一次开发产生多类应用，赋予应用跨平台特点，增加了产品的可移植性 Electron套用BlurAdmin模板打通了B/S架构与跨平台桌面应用程序之间的界限 结合自身需求选择合适的开发方式，提高开发效率，避免未来将会产生的一些问题 0x01-知识储备BlurAdmin简介 BlurAdmin是Angular前端Admin Dashboard模板。这意味着您可以在图表，图表表格中看到的所有数据都在Javascript中进行硬编码。您可以无限制地使用任何您想要的后端。 目前很多业务应用程序都有一些管理界面。有时它并不那么明显，但很多Web应用程序都有仪表板，带有面板，图表分析。 BlurAdmin旨在引导您的产品开发，并为构建原型甚至生产就绪应用程序提供生态系统。 尽管像Bootstrap这样的框架提供了许多组件，但通常它们还不足以构建真实世界的应用程序。此模板带有许多流行的UI组件和统一的配色方案。 Gulp基础Gulp简介Gulp是基于node.js的一个前端自动化构建工具，可以使用它构建自动化工作流程（前端集成开发环境）。使用Gulp你可以简化工作量，让你把重点放在功能的开发上，从而提高你的开发效率和工作质量。 Gulp特性 易于使用：通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。 构建快速：利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 插件高质：Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 易于学习：通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。 脚手架简介“脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多MVC框架都有运用这种思想。程序员编写一份specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份specification生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用！ 优势由“程序员手写代码”跨越到了“程序员指挥机器自动生成代码”的时代，并且利用脚手架，我们可以爬到更高的地方、建更高的楼房 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 WebStorm Node.js Git 0x03-方案设计方案A：父子目录下开发bluradmin单独开发，完成后在父目录下通过electron .启动应用 方案B：单级目录下开发将electron代码添加到bluradmin代码目录中 blur-admin源码中已存在Gulp脚手架,使用gulp dev-release即可生成打包未压缩文件（存放在dev-release目录中） 移动electron目录下main.js到子目录blur-admin中，并修改main.js、package.json文件，使electron开发和blur-admin开发在同一个目录下进行 创建后端数据库连接文件夹，为将来后端连接预留位置 0x04-实践操作下载源码 electron-v1.1.0（密码：tmb5），解压后修改子目录blur-admin-v1.1.0为blur-admin-v1.2.0,并将blur-admin-v1.2.0文件夹移动到开发目录（个人习惯移动到桌面~_~） 移动electron-v1.1.0目录下main.js文件到子目录blur-admin-v1.2.0中 Gulp构建安装Gulp$ npm install --global gulp 打包生成$ gulp dev-release 修改文件main.js package.json 启动应用 0x05-总结分析 使用Gulp构建出打包未压缩的文件，相对于打包压缩后的文件更加容易修改 将两种不同的开发从父子目录下集中到单级目录下进行，简化了开发步骤，是全栈开发的关键一步 一次开发可以产生Web网站和桌面应用两种产品，提高了开发效率，扩充了平台兼容性，增强了开发模式的多样性 0x06-程序源码main.jsconst {app, BrowserWindow} = require(&apos;electron&apos;); let win; let windowConfig = { width:800, height:600 }; function createWindow(){ win = new BrowserWindow(windowConfig); //加载index.html文件 win.loadURL(`file://${__dirname}/dev-release/index.html`); //开启调试工具 //win.webContents.openDevTools(); win.on(&apos;close&apos;,() =&gt; { //回收BrowserWindow对象 win = null; }); //调整页面大小后重新加载整个页面 //win.on(&apos;resize&apos;,() =&gt; { // win.reload(); //}) } app.on(&apos;ready&apos;,createWindow); app.on(&apos;window-all-closed&apos;,() =&gt; { app.quit(); }); app.on(&apos;activate&apos;,() =&gt; { if(win == null){ createWindow(); } }) package.json{ &quot;name&quot;: &quot;blur_admin&quot;, &quot;version&quot;: &quot;1.3.1&quot;, &quot;devDependencies&quot;: { &quot;bower&quot;: &quot;~1.8.4&quot;, &quot;browser-sync&quot;: &quot;^2.24.7&quot;, &quot;browser-sync-spa&quot;: &quot;~1.0.3&quot;, &quot;chalk&quot;: &quot;~1.1.1&quot;, &quot;del&quot;: &quot;~2.2.2&quot;, &quot;eslint-plugin-angular&quot;: &quot;~0.12.0&quot;, &quot;estraverse&quot;: &quot;~4.2.0&quot;, &quot;gulp&quot;: &quot;~3.9.0&quot;, &quot;gulp-angular-filesort&quot;: &quot;^1.2.1&quot;, &quot;gulp-angular-templatecache&quot;: &quot;~2.0.0&quot;, &quot;gulp-autoprefixer&quot;: &quot;~3.1.1&quot;, &quot;gulp-eslint&quot;: &quot;~1.0.0&quot;, &quot;gulp-filter&quot;: &quot;~4.0.0&quot;, &quot;gulp-flatten&quot;: &quot;~0.3.1&quot;, &quot;gulp-gh-pages&quot;: &quot;^0.5.4&quot;, &quot;gulp-inject&quot;: &quot;~4.1.0&quot;, &quot;gulp-load-plugins&quot;: &quot;~1.4.0&quot;, &quot;gulp-minify-css&quot;: &quot;~1.2.1&quot;, &quot;gulp-minify-html&quot;: &quot;~1.0.4&quot;, &quot;gulp-ng-annotate&quot;: &quot;~2.0.0&quot;, &quot;gulp-prompt&quot;: &quot;^0.2.0&quot;, &quot;gulp-protractor&quot;: &quot;~3.0.0&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-replace&quot;: &quot;~0.5.4&quot;, &quot;gulp-rev&quot;: &quot;~7.1.2&quot;, &quot;gulp-rev-replace&quot;: &quot;~0.4.2&quot;, &quot;gulp-sass&quot;: &quot;^4.0.1&quot;, &quot;gulp-shell&quot;: &quot;^0.5.2&quot;, &quot;gulp-size&quot;: &quot;~2.1.0&quot;, &quot;gulp-sourcemaps&quot;: &quot;~1.6.0&quot;, &quot;gulp-uglify&quot;: &quot;~2.0.0&quot;, &quot;gulp-useref&quot;: &quot;~1.3.0&quot;, &quot;gulp-util&quot;: &quot;~3.0.6&quot;, &quot;gulp-zip&quot;: &quot;^3.0.2&quot;, &quot;http-proxy-middleware&quot;: &quot;~0.17.2&quot;, &quot;lodash&quot;: &quot;~4.17.2&quot;, &quot;main-bower-files&quot;: &quot;~2.13.1&quot;, &quot;uglify-save-license&quot;: &quot;~0.4.1&quot;, &quot;wiredep&quot;: &quot;~4.0.0&quot;, &quot;wrench&quot;: &quot;~1.5.8&quot; }, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;postinstall&quot;: &quot;bower install&quot;, &quot;start&quot;: &quot;electron .&quot; } } 源码打包blur-admin-v1.2.0（密码：he5r） 0x07-参考资料 Gulp中文网 Electron官网 Electron应用开发","categories":[],"tags":[{"name":"BlurAdmin","slug":"BlurAdmin","permalink":"http://yoursite.com/tags/BlurAdmin/"}],"keywords":[]},{"title":"Electron应用开发","slug":"Electron应用开发","date":"2018-08-20T12:54:27.000Z","updated":"2018-10-06T05:56:10.000Z","comments":true,"path":"Electron应用开发/","link":"","permalink":"http://yoursite.com/Electron应用开发/","excerpt":"","text":"0x00-文章背景 0x01-技能储备 0x02-开发环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章背景文章目的 实现Electron应用原型开发，同时预留相应扩展接口及功能使得后续维护及扩展变得相对容易 完善Electron应用交互开发，结合具体需求添加相应功能使得整个开发周期、产品功能可控可调 文章前景 Electron套用BlurAdmin模板打通了B/S架构与跨平台桌面应用程序之间的界限 结合自身需求选择合适的开发方式，提高开发效率，避免未来将会产生的一些问题 原型开发的复用，使得一些相似应用也能直接使用这种开发成果，缩短开发周期，提高开发效率 0x01-技能储备BlurAdmin简介 BlurAdmin是Angular前端Admin Dashboard模板。这意味着您可以在图表，图表表格中看到的所有数据都在Javascript中进行硬编码。您可以无限制地使用任何您想要的后端。 目前很多业务应用程序都有一些管理界面。有时它并不那么明显，但很多Web应用程序都有仪表板，带有面板，图表分析。 BlurAdmin旨在引导您的产品开发，并为构建原型甚至生产就绪应用程序提供生态系统。 尽管像Bootstrap这样的框架提供了许多组件，但通常它们还不足以构建真实世界的应用程序。此模板带有许多流行的UI组件和统一的配色方案。 Electron简介Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。这是一个整合了Node，Chromium，V8的一个框架，通过它可以使用JavaScript，HTML, CSS技术来开发桌面应用程序 Node.js简介 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。 除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等 混合开发随着前端技术的发展，现在越来越多的桌面应用程序会嵌入一些Web技术来进行混合开发，结合了web端和传统桌面软件各自的优点。 全栈开发 权衡服务器、网络和服务器环境、数据建模、业务逻辑、API层、Action层、MVC、UI、用户体验等因素，找到适合当前环境应用开发的最优解。 开发者既要了解后端开发，也要了解前端开发。是“全方位”的工程师，熟悉服务端的同时又懂客户端用户体验。理解Web开发进程的每一个方面，同时又会就整体策略与最佳实践对相关方面提出建议与指导。 0x02-开发环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 WebStorm Node.js Git 0x03-方案设计方案A:单独开发Electron开发Electron直接开发，调用Node.js等相关API，编写应用 BlurAdmin开发BlurAdmin单独开发使用一些前端语言，使得变为一个Web网站项目 方案B:混合开发BlurAdmin开发完成后打包成Electron应用套用HTML5模板，使用Electron将网站变为应用 使用BlurAdmin打包压缩后的文件，结合Electron开发利用打包压缩后的BlurAdmin模板，将其变为应用，再在其基础上开发 使用BlurAdmin打包未压缩的文件，结合Electron开发利用打包未压缩的BlurAdmin模板，将其变为应用，再在其基础上开发 方案C:全栈开发BlurAdmin开发+使用BlurAdmin打包未压缩的文件+Electron开发在BlurAdmin模板基础上开发出网站，然后打包产生未压缩文件，结合Electron再次开发 0x04-实践操作下载源码 electron-v1.0.0（密码：dkes），解压改名为electron-v1.1.0，删除除main.js和package.json外其它文件 blur-admin-v1.0.0（密码：l48u）），解压改名为blur-admin-v1.1.0 将blur-admin-v1.1.0移到electron-v1.1.0文件夹中 修改文件 修改main.js中win.loadURL里的路径，使其指向release文件夹下index.html页面 注释掉mian.js中win.on()语句，避免重复加载整个页面 //调整页面大小后重新加载整个页面 //win.on(&apos;resize&apos;,() =&gt; { // win.reload(); //}) 修改package.json中name、vision、description main.jsconst {app, BrowserWindow} = require(&apos;electron&apos;); let win; let windowConfig = { width:800, height:600 }; function createWindow(){ win = new BrowserWindow(windowConfig); //加载index.html文件 win.loadURL(`file://${__dirname}/blur-admin-v1.1.0/release/index.html`); //开启调试工具 //win.webContents.openDevTools(); win.on(&apos;close&apos;,() =&gt; { //回收BrowserWindow对象 win = null; }); //调整页面大小后重新加载整个页面 //win.on(&apos;resize&apos;,() =&gt; { // win.reload(); //}) } app.on(&apos;ready&apos;,createWindow); app.on(&apos;window-all-closed&apos;,() =&gt; { app.quit(); }); app.on(&apos;activate&apos;,() =&gt; { if(win == null){ createWindow(); } }) package.json{ &quot;name&quot;: &quot;electron-v1.1.0&quot;, &quot;version&quot;: &quot;1.1.0&quot;, &quot;description&quot;: &quot;an electron application&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;build&quot;: { &quot;appId&quot;: &quot;com.xxx.app&quot;, &quot;win&quot;: { &quot;target&quot;: [ &quot;nsis&quot;, &quot;zip&quot; ] }, &quot;publish&quot;: [ { &quot;provider&quot;: &quot;generic&quot;, &quot;url&quot;: &quot;http://localhost:4000/version&quot; } ] }, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot;, &quot;dist&quot;: &quot;electron-builder --win --x64&quot; }, &quot;author&quot;: &quot;xiafei_xupt&quot;, &quot;license&quot;: &quot;ISC&quot; } 添加语句说明：由于BlurAdmin和Electron所用的模块有所不同，所以直接Electron直接引用BlurAdmin打包生成的文件是会报错的，故添加模块兼容语句，使其根据环境自动选择合适的模块，避免了模板不兼容情况的发生。 &lt;!--添加模块兼容语句--&gt; &lt;script&gt;if (typeof module === &apos;object&apos;) {window.module = module; module = undefined;}&lt;/script&gt; 启动应用浏览器中查看gulp serve:dist 注：blur-admin-v1.1.0目录下运行gulp serve:dist，既能查看BlurAdmin模板页面，又能生成打包后的release文件夹 Electron中查看electron . 0x05-总结分析单独开发优点：开发效率高，相关接口框架等比较成熟缺点：功能单一，先天不足，后期几乎无法扩充相关功能 混合开发优点：效率高，前后端混合开发，避免了前后端对接这一开发流程，缩短开发周期缺点：较难维护，高耦合低内聚 全栈开发（前后端分离开发）优点：前后端分离仍是当前主流开发模式，符合现代编程低耦合高内聚的要求，后端逻辑与页面显示完全解耦，容易维护与完善缺点：前后端分离是存在沟通成本，只有真正理解“全栈”，熟悉整个技术栈，权衡各个技术点与用户体验才有可能找到最优解 0x06-程序源码main.jsconst {app, BrowserWindow} = require(&apos;electron&apos;); let win; let windowConfig = { width:800, height:600 }; function createWindow(){ win = new BrowserWindow(windowConfig); //加载index.html文件 win.loadURL(`file://${__dirname}/blur-admin-v1.1.0/release/index.html`); //开启调试工具 //win.webContents.openDevTools(); win.on(&apos;close&apos;,() =&gt; { //回收BrowserWindow对象 win = null; }); //调整页面大小后重新加载整个页面 //win.on(&apos;resize&apos;,() =&gt; { // win.reload(); //}) } app.on(&apos;ready&apos;,createWindow); app.on(&apos;window-all-closed&apos;,() =&gt; { app.quit(); }); app.on(&apos;activate&apos;,() =&gt; { if(win == null){ createWindow(); } }) package.json{ &quot;name&quot;: &quot;electron-v1.1.0&quot;, &quot;version&quot;: &quot;1.1.0&quot;, &quot;description&quot;: &quot;an electron application&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;build&quot;: { &quot;appId&quot;: &quot;com.xxx.app&quot;, &quot;win&quot;: { &quot;target&quot;: [ &quot;nsis&quot;, &quot;zip&quot; ] }, &quot;publish&quot;: [ { &quot;provider&quot;: &quot;generic&quot;, &quot;url&quot;: &quot;http://localhost:4000/version&quot; } ] }, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot;, &quot;dist&quot;: &quot;electron-builder --win --x64&quot; }, &quot;author&quot;: &quot;xiafei_xupt&quot;, &quot;license&quot;: &quot;ISC&quot; } index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; ng-app=&quot;BlurAdmin&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Blur Admin&lt;/title&gt; &lt;!--添加模块兼容语句--&gt; &lt;script&gt;if (typeof module === &apos;object&apos;) {window.module = module; module = undefined;}&lt;/script&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900italic,900&amp;subset=latin,greek,greek-ext,vietnamese,cyrillic-ext,latin-ext,cyrillic&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;assets/img/favicon-16x16.png&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;assets/img/favicon-32x32.png&quot;&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;96x96&quot; href=&quot;assets/img/favicon-96x96.png&quot;&gt; &lt;!-- build:css({.tmp/serve,src}) styles/vendor.css --&gt; &lt;!-- bower:css --&gt; &lt;!-- run `gulp inject` to automatically populate bower styles dependencies --&gt; &lt;!-- endbower --&gt; &lt;!-- endbuild --&gt; &lt;!-- build:css({.tmp/serve,src}) styles/app.css --&gt; &lt;!-- inject:css --&gt; &lt;!-- css files will be automatically insert here --&gt; &lt;!-- endinject --&gt; &lt;!-- endbuild --&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;body-bg&quot;&gt;&lt;/div&gt; &lt;main ng-if=&quot;$pageFinishedLoading&quot; ng-class=&quot;{ &apos;menu-collapsed&apos;: $baSidebarService.isMenuCollapsed() }&quot;&gt; &lt;ba-sidebar&gt;&lt;/ba-sidebar&gt; &lt;page-top&gt;&lt;/page-top&gt; &lt;div class=&quot;al-main&quot;&gt; &lt;div class=&quot;al-content&quot;&gt; &lt;content-top&gt;&lt;/content-top&gt; &lt;div ui-view autoscroll=&quot;true&quot; autoscroll-body-top&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=&quot;al-footer clearfix&quot;&gt; &lt;div class=&quot;al-footer-right&quot;&gt;Created with &lt;i class=&quot;ion-heart&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;al-footer-main clearfix&quot;&gt; &lt;div class=&quot;al-copy&quot;&gt;Blur Admin 2016&lt;/div&gt; &lt;ul class=&quot;al-share clearfix&quot;&gt; &lt;li&gt;&lt;i class=&quot;socicon socicon-facebook&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;socicon socicon-twitter&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;socicon socicon-google&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;socicon socicon-github&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/footer&gt; &lt;back-top&gt;&lt;/back-top&gt; &lt;/main&gt; &lt;div id=&quot;preloader&quot; ng-show=&quot;!$pageFinishedLoading&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- build:js(src) scripts/vendor.js --&gt; &lt;!-- bower:js --&gt; &lt;!-- run `gulp inject` to automatically populate bower script dependencies --&gt; &lt;!-- endbower --&gt; &lt;!-- endbuild --&gt; &lt;!--去掉引用谷歌maps.js--&gt; &lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://maps.google.com/maps/api/js?sensor=false&quot;&gt;&lt;/script&gt;--&gt; &lt;!-- build:js({.tmp/serve,.tmp/partials,src}) scripts/app.js --&gt; &lt;!-- inject:js --&gt; &lt;!-- js files will be automatically insert here --&gt; &lt;!-- endinject --&gt; &lt;!-- inject:partials --&gt; &lt;!-- angular templates will be automatically converted in js and inserted here --&gt; &lt;!-- endinject --&gt; &lt;!-- endbuild --&gt; &lt;/body&gt; &lt;/html&gt; 源码打包electron-v1.1.0（密码：tmb5） 0x07-参考资料 Electron官网 BlurAdmin官网 Electron开发流程 BlurAdmin模板学习","categories":[],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}],"keywords":[]},{"title":"BlurAdmin模板学习","slug":"BlurAdmin模板学习","date":"2018-08-12T16:00:00.000Z","updated":"2018-10-05T23:09:18.000Z","comments":true,"path":"BlurAdmin模板学习/","link":"","permalink":"http://yoursite.com/BlurAdmin模板学习/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的 研究HTML界面开发框架以及相关开发语言 了解BlurAdmin模板的项目结构和简单使用 熟练定制BlurAdmin模板配色、主题、页面、组件等 文章前景 学习BlurAdmin模板可以加深对前端的理解 定制模板、修改组件可以得到合适的模板，缩减项目开发周期 0x01-知识储备BlurAdmin基础BlurAdmin介绍 BlurAdmin是Angular前端Admin Dashboard模板。这意味着您可以在图表，图表表格中看到的所有数据都在Javascript中进行硬编码。您可以无限制地使用任何您想要的后端。 目前很多业务应用程序都有一些管理界面。有时它并不那么明显，但很多Web应用程序都有仪表板，带有面板，图表分析。 BlurAdmin旨在引导您的产品开发，并为构建原型甚至生产就绪应用程序提供生态系统。 尽管像Bootstrap这样的框架提供了许多组件，但通常它们还不足以构建真实世界的应用程序。此模板带有许多流行的UI组件和统一的配色方案。 BlurAdmin文档主要介绍了BlurAdmin模板的特点、安装、定制等一些问题，是BlurAdmin学习必备的文档。 BlurAdmin特点 响应式布局 高分辨率 Bootstrap CSS 框架 Sass Gulp构建 AngularJS jQuery Jquery ui 图表（amChart，Chartist，Chart.js，Morris） 地图（Google，Leaflet，amMap） 总之，其图形界面比较炫酷，图表分析功能强大，各种组件比较齐全。 Node.js基础 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。 除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL WebStorm Node.js Git 0x03-方案设计改变配色方案修改BlurAdmin模板的背景色，文本颜色等 启用模糊主题计算面板的初始背景偏移，改变一些颜色，使主题变得模糊 分析项目结构详细了解该模板目录下每个文件/文件夹的内容、功能等 创建新页面创建一个新的HTML页面，写入内容：Hello BlurAdmin ! 修改侧边栏组件使用多种方式配置侧边栏菜单，使得主页可以打开所创建的页面 0x04-实践验证模板准备下载 GitHub官网下载 git clone https://github.com/akveo/blur-admin.git BlurAdmin官网下载 如果您在安装node.js和/或其他工具以在您的计算机上构建和运行BlurAdmin时遇到问题而您只想下载html / js / css文件，则可以在此页面上找到要下载的链接。 可以在{ARCHIVE_ROOT}/blur-admin-{VERSION}/dev-release目录中找到开发（非压缩）文件。压缩文件在{ARCHIVE_ROOT}/blur-admin-{VERSION}/release目录中。然后您可以打开index.html以查看您的本地版本。 请注意：由于chrome不支持AJAX请求，因此当您通过文件协议打开HTML文件时，可能需要禁用Web安全性才能运行模板。 OS X 上的示例命令： open -a Google\\ Chrome --args --disable-web-security --user-data-dir=~/ChromeDevSession/ Linux上的示例命令 google-chrome --user-data-dir=&quot;~/chrome-dev-session&quot; --disable-web-security Windows上的示例命令 start chrome --user-data-dir=&quot;C:/Chrome dev session&quot; --disable-web-security 下载链接 BlurAdmin 1.3.1BlurAdmin 1.2.0 安装cd blur-admin npm install //安装所需组件 npm install -g yo gulp bower //安装bower npm install -g generator-gulp-angular //安装generator-gulp-angular 注： 安装node如果没有翻墙的话可能会安装失败，使用淘宝镜像代替： npm install -g cnpm --registry=https://registry.npm.taobao.org 然后用 cnpm install 处理 去掉引用谷歌maps.js ### 去掉启动app.js的延迟时间设置和AmCharts预加载 启动 要在开发模式下运行本地副本，请执行： gulp serve 此脚本应在默认浏览器中自动打开模板。 要在生产模式下运行本地副本，请执行： gulp serve:dist 注：release文件即为发布所需文件 模板主页注：默认浅色主题 改变配色方案默认情况下，BlurAdmin有两种颜色配置文件：mint和blur。那么如何创建自己的颜色配置文件呢？假设你想让BlurAdmin变暗。首先，建议将一些colorscheme文件作为基础。对于浅色主题，建议采用src/sass/theme/conf/colorScheme/_mint.scss文件；对于黑暗主题，建议采用src/sass/theme/conf/colorScheme/_blur.scss文件。1）如果想要黑暗主题。复制src/sass/theme/conf/colorScheme/_blur.scss到src/sass/theme/conf/colorScheme/_dark.scss。 2）同时需修改colorscheme文件src/sass/theme/common.scs。请替换 @import &apos;theme/conf/colorScheme/mint&apos;; 至 @import &apos;theme/conf/colorScheme/dark&apos;; 3）现在可以开始改变颜色了。例如，为展示不同颜色的一些内容，可在_dark.scss文件中更改了5个主要变量： $default: rgba(#000000, 0.2); //Panel background color $body-bg: #F0F3F4; // Body background color $default-text: #ffffff; // Default text color $help-text: #eeeeee; // Default subtext color $label-text: #ffffff; // Text for labels in forms (Basically it should be equal to default-text in most cases) 4）完成此操作后，需要在构建图表和其他JavaScript组件时设置javascript以使用相同的颜色。为此，将以下代码添加到某个配置块，例如src/app/theme/theme.config.js： baConfigProvider.changeColors({ default: &apos;rgba(#000000, 0.2)&apos;, defaultText: &apos;#ffffff&apos;, dashboard: { white: &apos;#ffffff&apos;, }, }); 基本上就是这样！现在应用程序如下所示： 如需进一步修改，请参考 Colorscheme scss文件（src/sass/theme/conf/colorScheme/路径下） src/app/theme/theme.configProvider.js 了解哪些javascript颜色可以更改 启用模糊主题如果要将主题切换为模糊，则需要执行以下3个简单步骤： 1）模糊主题需要一些javascript来计算面板的初始背景偏移。这就是为什么你需要做的第一件事是启用该代码。这应该在Angular 配置块中完成。例如，您可以添加以下行src/app/theme/theme.config.js： baConfigProvider.changeTheme({blur: true}); 2）同样你需要改变一些颜色。。对于模糊主题，可以使用以下配置 baConfigProvider.changeColors({ default: &apos;rgba(#000000, 0.2)&apos;, defaultText: &apos;#ffffff&apos;, dashboard: { white: &apos;#ffffff&apos;, }, }); 3）CSS也应该重新编译。在运行构建命令之前，建议切换到模糊颜色配置文件。为此，请替换文件中的主题src/sass/theme/common.scss： @import &apos;theme/conf/colorScheme/mint&apos;; 至 @import &apos;theme/conf/colorScheme/blur&apos;; 或 @import &apos;theme/conf/colorScheme/dark&apos;; 主题效果 注：如果想使用一些不同的背景，请替换以下图像： src/app/assets/img/blur-bg.jpg （主要背景图片） src/app/assets/img/blur-bg-blurred.jpg （面板上使用的模糊背景图像） 分析项目结构该模板的目录结构如下： ├── bower.json &lt;- front-end library dependencies//前端库依赖 ├── gulpfile.js &lt;- main task runner file//主任务运行文件 ├── package.json &lt;- mostly task runner dependencies//许多任务运行依赖 ├── docs/&lt;- wintersmith documentation generator//wintersmith文档生成器 ├── gulp/&lt;- build tasks//项目构建 ├── src/ &lt;- main front-end assets//源代码 │ ├── 404.html │ ├── auth.html │ ├── index.html &lt;- main app dashboard page//主应用程序页面 │ ├── reg.html │ ├── app/&lt;- angular application files//angular应用程序文件 │ │ ├── app.js &lt;- angular application entry point. Used for managing dependencies//angular应用程序入口. 用于管理依赖项 │ │ ├── pages/ &lt;- UI router pages. Pages created for demonstration purposes. Put your application js and html files here//UI路由页面,为演示目的创建的页。将应用程序 js 和 html 文件放在这里 │ │ ├── theme/ &lt;- theme components. Contains various common widgets, panels which used across application//主题组件. 包含各种常用的小部件, 跨应用使用的模板 │ ├── assets/ &lt;- static files (images, fonts etc.)//静态文件 (图像, 字体等) │ ├── sass/ &lt;- sass styles//sass样式文件 │ │ ├── app/ &lt;- application styles. Used mostly for demonstration purposes. Put your app styles here.//应用程序样式。主要用于演示目的。将应用程序样式放在这里 │ │ ├── theme/ &lt;- theme styles. Used to customize bootstrap and other common components used in tempate.//主题样式。用于自定义bootstrap和模板中使用的其他常用组件。 在该模板中，尝试分离主题图层和表示层。大多数其他模板都将它们结合起来。这就是为什么当开始使用它们时，很难删除不需要的东西。 创建新页面BlurAdmin使用Angular UI路由器进行导航。这意味着要创建基本配置ui-router状态所需的新页面。 建议将页面放在单独的模块中。这将允许在将来根据需要轻松关闭某些页面。假设要创建一个标题为“我的新页面”的空白页面 1）创建一个新目录来包含新页面src/app/pages。叫这个目录myNewPage。然后创建空白角度模块以包含页面中名为’myNewPage.module.js’的内容src/app/pages/myNewPage： (function () { &apos;use strict&apos;; angular.module(&apos;BlurAdmin.pages.myNewPage&apos;, []) .config(routeConfig); /** @ngInject */ function routeConfig() { } })(); 2）然后在my-new-page.html里面创建一个空的html文件src/app/pages/myNewPage，写入内容：Hello BlurAdmin !3）最后为这个页面创建ui路由器状态。为此，需要修改第2步创建的module.js文件： (function () { &apos;use strict&apos;; angular.module(&apos;BlurAdmin.pages.myNewPage&apos;, []) .config(routeConfig); /** @ngInject */ function routeConfig($stateProvider) { $stateProvider .state(&apos;myNewPage&apos;, { url: &apos;/myNewPage&apos;, templateUrl: &apos;app/pages/myNewPage/my-new-page.html&apos;, title: &apos;My New Page&apos;, sidebarMeta: { order: 800, }, }); } })(); 修改侧边栏组件边栏用于在应用程序中提供方便的导航方式。应用程序仅支持每个角度应用程序一个侧栏。这意味着侧边栏基本上是一个单一对象。目前侧栏支持1级和2级子菜单。 可以使用baSidebar指令创建补充工具栏： &lt;ba-sidebar&gt;&lt;/ba-sidebar&gt; 目前它仅支持javascript配置。虽然可以手动配置或通过ui-router状态配置。这种方法可以一起使用，也可以一次使用一种。 1）手动配置对于手动配置，需要baSidebarServiceProvider在角度配置块中使用提供程序。提供者有addStaticItem方法，它接收menuItem对象作为参数，它可以具有以下属性： 属性 类型 含义 title String 菜单项的名称 icon String 要在标题附近显示的图标（它是一个类名） stateRef String ui-router 与此菜单项关联的状态 fixedHref String 与此菜单项关联的网址 blank String 指定是否应在新浏览器选项卡中打开以下Url subMenu Array of menu items 要显示为下一级子菜单的菜单项列表 手动配置示例： baSidebarServiceProvider.addStaticItem({ title: &apos;Menu Level 1&apos;, icon: &apos;ion-ios-more&apos; }); 例如启动效果 2）路由配置默认情况下，侧栏会遍历您在应用程序中定义的所有ui-router状态，并sidebarMeta在其中搜索对象。对于具有此属性的每个州，都会创建侧边栏元素。 各州按等级分组。这意味着如果某个状态存在父抽象状态并且它们都具有sidebarMeta属性，则它将显示为该抽象状态菜单项的子项。 该物品的名称取自state的title财产。示例状态配置，它将向侧栏添加项： $stateProvider .state(‘dashboard’, { url: ‘/dashboard’, templateUrl: ‘app/pages/dashboard/dashboard.html’, title: ‘Dashboard’, sidebarMeta: { icon: ‘ion-android-home’, order: 0, }, }); 例如 sidebarMeta 对象可以具有以下属性： 属性 类型 含义 icon String 要在标题附近显示的图标（它是一个类名） order Number 当前层次结构中元素的顺序 路由注册 启动效果 0x05-总结分析 熟悉了BlurAdmin模板，加深了对前端开发的理解 通过对BlurAdmin模板配色、主题、页面、组件等模块的使用，使得定制模板变得简单 其HTML、JavaScript、CSS等语言的操作和一般前端开发一样，当然也可以在后端通过Node.js调用一些模块来扩充操作 0x06-程序源码为避免与原模板命名重复，改名为blur-admin-v1.0.0（密码：l48u） 0x07-参考资料 一款基于angularjs、bootstrap免费的后台模板blur-admin使用 Mint version demo Blur version demo GitHub地址 BlurAdmin文档 BlurAdmin官网","categories":[],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yoursite.com/tags/PostgreSQL/"}],"keywords":[]},{"title":"PostgreSQL操作接口","slug":"PostgreSQL操作接口","date":"2018-08-06T12:54:27.000Z","updated":"2018-08-11T05:46:28.000Z","comments":true,"path":"PostgreSQL操作接口/","link":"","permalink":"http://yoursite.com/PostgreSQL操作接口/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的 日志分析中展示要求、界面框架数据库查询接口 PostgreSQL和Node.js、Electron应用之间的连接、通信、封装、优化、打包 文章前景 对于Node.js调用PostgreSQL接口的封装有利于面向对象的开发 通过Electron使用Node.js模块和数据库通信，可以加深对Electron框架的理解 对于Node.js和数据库通信的掌握可以打通前后端的界限，有利于形成全栈思维 0x01-知识储备PostgreSQL基础 自从MySQL被Oracle收购以后，PostgreSQL逐渐成为开源关系型数据库的首选。 PostgreSQL是一个功能强大的开源对象关系数据库系统，它使用并扩展了SQL语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。 PostgreSQL的起源可以追溯到1986年，作为加州大学伯克利分校POSTGRES项目的一部分，并在核心平台上进行了30多年的积极开发。 PostgreSQL凭借其经过验证的架构，可靠性，数据完整性，强大的功能集，可扩展性以及软件背后的开源社区的奉献精神赢得了良好的声誉，以始终如一地提供高性能和创新的解决方案。 PostgreSQL在所有主要操作系统上运行，自2001年以来一直是符合ACID标准的，并且具有强大的附加功能，例如流行的PostGIS地理空间数据库扩展器。毫无疑问，PostgreSQL已经成为许多人和组织的首选开源关系数据库。 Node.js基础 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。 除了Web应用外，Node.JS也被应用在许多方面，包括应用程序监控、媒体流、远程控制、桌面和移动应用等等 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 Debian 9系统 PostgreSQL Node.js 注：由于PostgreSQL操作接口使用Node.js实现，而Windows 10系统和Debian 9系统对于Node.js的支持完全一样，故此处只在Windows 10系统上进行测试 0x03-方案设计Electron通过Node.js使用 pg 模块和PostgreSQL连接 客户端方式每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。适用：客户端连接次数少、重复访问率低的数据 注：本文数据库操作接口使用客户端方式实现 连接池方式连接池允许应用程序从连接池中获得一个连接并使用这个连接，而不需要为每一个连接请求重新建立一个连接。一旦一个新的连接被创建并且放置在连接池中，应用程序就可以重复使用这个连接而不必实施整个数据库连接创建过程。当应用程序请求一个连接时，连接池为该应用程序分配一个连接而不是重新建立一个连接；当应用程序使用完连接后，该连接被归还给连接池而不是直接释放。适用：大量、重复访问率高的数据 0x04-实践验证创建数据库 插入数据 安装pg模块Node.js中有专门的模块可以用来连接PostgreSql数据库，首先从npm资源库中获取数据库模块，名为”pg”： npm install pg npm ls --depth 0//查看已安装模块 接口测试增删改查接口测试 SELECT接口测试对增删改查接口中查询接口进行了改进 Node.js测试 Electron测试 0x05-总结分析 在函数实现里面，我们采用了回调函数的形式实现，根据输出信息可以很号的看出node.js的主要特性：非阻塞 数据库的查询接口改进后使用指定行列进行操作，查询比较具体，由于Node.js使用非阻塞式 I/O 的模型，故多个查询之间不会冲突 PostgreSQL操作接口是连接了前后端之间的桥梁，使得前端页面和后端数据库之间的通信变得简单直观。 0x06-程序源码创建数据库脚本create table Log_Inf(id character varying(10),type character varying(10),rank character varying(10)); 插入数据脚本insert into Log_Inf values(&apos;1&apos;,&apos;C01&apos;,&apos;G01&apos;); insert into Log_Inf values(&apos;2&apos;,&apos;C02&apos;,&apos;G02&apos;); insert into Log_Inf values(&apos;3&apos;,&apos;C03&apos;,&apos;G03&apos;); insert into Log_Inf values(&apos;4&apos;,&apos;C04&apos;,&apos;G04&apos;); 增删改查操作的封装Client.jsvar f = require(&apos;./PG&apos;); var pg = require(&apos;pg&apos;); //var conString = &quot;tcp://postgres:postgres@localhost/test&quot;; var conString = &quot;tcp://postgres:111111@localhost:5432/test&quot;; var client = new pg.Client(conString); var value = [&apos;9&apos;,&apos;C09&apos;,&apos;G09&apos;]; insertSQLString = &apos;insert into Log_Inf values($1,$2,$3)&apos;; selectSQLString = &apos;select * from Log_Inf&apos;; updateSQLString = &quot;update Log_Inf set TYPE=&apos;C07&apos; where ID=&apos;4&apos;&quot;; deleteSQLString = &quot;delete from Log_Inf where ID=&apos;9&apos;&quot;; client.connect(function(error, results) { if(error){ console.log(&apos;ClientConnectionReady Error: &apos; + error.message); client.end(); return; } console.log(&apos;connection success...\\n&apos;); f._select(client,selectSQLString); f._insert(client,insertSQLString,value); f._update(client,updateSQLString); f._delete(client,deleteSQLString); }); PG.jsfunction _insert(client,insertSQLString,value) { console.log(&quot;insert beginning&quot;); client.query(insertSQLString, value, function(error, results) { if(error) { console.log(&quot;ClientReady Error: &quot; + error.message), client.end(); return; } console.log(&apos;Inserted: &apos; + results.affectedRows + &apos; row.&apos;), console.log(&apos;insert success...\\n&apos;); }); console.log(&quot;insert end\\n&quot;); } function _select(client,selectSQLString) { console.log(&quot;select beginning&quot;); client.query(selectSQLString, function selectCb(error, results, fields) { console.log(&quot;in select callback function&quot;); if (error) { console.log(&apos;GetData Error: &apos; + error.message), client.end(); return; } if(results.rowCount &gt; 0) { var firstResult, resultSet = &apos;&apos;; for(var i = 0, len = results.rowCount; i &lt; len; i++) { firstResult = results.rows[i]; resultSet += &apos;id:&apos; + firstResult[&apos;id&apos;] + &apos; &apos; + &apos;type:&apos; + firstResult[&apos;type&apos;] + &apos; &apos; + &apos;rank:&apos; + firstResult[&apos;rank&apos;] + &apos;\\n&apos;; } } console.log(resultSet); /* 添加功能：使查询结果集返回到客户端并保证此函数的通用性. */ }); console.log(&quot;select end\\n&quot;); } function _update(client,updateSQLString) { console.log(&quot;update beginning&quot;); client.query(updateSQLString,function(error, results) { if(error) { console.log(&quot;ClientReady Error: &quot; + error.message), client.end(); return; } console.log(&apos;update success...\\n&apos;); }); console.log(&quot;update end\\n&quot;); } function _delete(client,deleteSQLString) { console.log(&quot;delete beginning&quot;); client.query(deleteSQLString, function(error, results) { if(error) { console.log(&quot;ClientReady Error: &quot; + error.message), client.end(); return; } console.log(&apos;delete success...\\n&apos;); }); console.log(&quot;delete end\\n&quot;); } exports._insert = _insert; exports._select = _select; exports._update = _update; exports._delete = _delete; SELECT接口的封装Node.js测试Client.jsvar f = require(&apos;./SELECT&apos;); var pg = require(&apos;pg&apos;); var conString = &quot;tcp://postgres:111111@localhost:5432/test&quot;;//1.连接 var client = new pg.Client(conString); Table_Name=&apos;Log_Inf&apos;;//2.表名 Row_Number=0;//2.行数，默认从0开始 Col_Name=&apos;id&apos;;//2.列名 client.connect(function(error, results) { if(error){ console.log(&apos;ClientConnectionReady Error: &apos; + error.message); client.end(); return; } //f._select(client,Table_Name,Row_Number,Col_Name); f._select(client,&apos;Log_Inf&apos;,3,&apos;rank&apos;);//2.all }); SELECT.jsfunction _select(client,Table_Name,Row_Number,Col_Name) { selectSQLString = &apos;select * from &apos;+Table_Name; client.query(selectSQLString, function selectCb(error, results, fields) { if (error) { console.log(&apos;GetData Error: &apos; + error.message), client.end(); return; } if(results.rowCount &gt; 0) { resultSet = results.rows[Row_Number][Col_Name]; } console.log(resultSet); /* 添加功能：使查询结果集返回到客户端并保证此函数的通用性. */ }); } exports._select = _select; 打包后的Node.js测试SELECT接口 密码：mg3w Electron测试测试代码是在我写的Electron开发流程中的electron-v1.0.0（密码：dkes）基础上进行修改 修改方式： electron-v1.0.0文件夹重命名为Electron_PostgreSQL，并将Node.js测试中SELECT.js和Client.js文件放到Electron_PostgreSQL的文件夹下 在index.html的body标签中加入： &lt;div&gt; 数据库数据： &lt;span id=&quot;pg_data&quot;&gt;&lt;/span&gt; &lt;script src=&quot;./Client.js&quot;&gt;&lt;/script&gt; &lt;/div&gt; 在SELECT.js中console.log(&#39;resultSet&#39;);的下一行加入 ： document.getElementById(&apos;pg_data&apos;).innerHTML = resultSet; 打包后的Electron测试:Electron_PostgreSQL(密码：8hcf) 0x07-参考资料 PostgreSQL 官网 Node.js 中文网 Node.js v10.7.0 文档 Node.js 中文网 Electron 官网","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yoursite.com/tags/PostgreSQL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}],"keywords":[]},{"title":"日志分析及数据库表的设计","slug":"日志分析及数据库表的设计","date":"2018-07-29T16:00:00.000Z","updated":"2018-09-23T03:30:56.000Z","comments":true,"path":"日志分析及数据库表的设计/","link":"","permalink":"http://yoursite.com/日志分析及数据库表的设计/","excerpt":"","text":"赵岩——2018-08-02——项目周报告——日志分析及数据库表的设计 0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 项目要求日志分析大量日志情况下，写程序（服务形式），定期不断产生日志消息，写入数据库。消息内容至少包括有主机分组、主机id、日志时间、日志类型、日志等级、日志消息。 数据库设计在大量的电脑日志情况下，HTML应用对日志进行条件查询、分析、产生各类型报表。数据库设计要依照数据参考和数据展示来进行设计。 数据操作 在产生大量日志数据的情况下需要项数据库中写入这些数据，而要写入的数据不止日志消息。要知道是哪台计算机产生的日志消息，需要主机的id和主机的分组，而产生的日志包括日志的类型、日志等级、和日志的消息内容，还有日志产生的时间。 在测试阶段，需要把日志的信息写入数据库即有一个数据库表的插入操作，此操作只需要在后台实现，利用postgreSQL数据库桌面工具写入测试数据。还有一个数据查询操作，此操作需要在HTML界面进行展示，将查询的数据通过整合，按照一定的要求进行展示。 知识储备数据库简介数据库可以实现数据共享、减少数据的冗余度、提高数据的独立性、使得数据实现集中控制、增加数据一致性和可维护性、有利于数据的故障恢复。 PostgreSQL基础 PostgreSQL是一个功能强大的开源对象关系数据库系统，它使用并扩展了SQL语言，并结合了许多安全存储和扩展最复杂数据工作负载的功能。 PostgreSQL的起源可以追溯到1986年，作为加州大学伯克利分校POSTGRES项目的一部分，并在核心平台上进行了30多年的积极开发。 PostgreSQL凭借其经过验证的架构，可靠性，数据完整性，强大的功能集，可扩展性以及软件背后的开源社区的奉献精神赢得了良好的声誉，以始终如一地提供高性能和创新的解决方案。 PostgreSQL在所有主要操作系统上运行，自2001年以来一直是符合ACID标准的，并且具有强大的附加功能，例如流行的PostGIS地理空间数据库扩展器。毫无疑问，PostgreSQL已经成为许多人和组织的首选开源关系数据库。 数据库视图视图的概述视图是从一个或者多个表中导出的，它的行为与表非常相似，但视图是一个虚拟表。在视图中，用户可以使用SELECT语句查询语句，以及使用INSERT、UPDATE、和DELETE语句修改记录。在PostgreSQL中，使用视图可以使用户操作方便，而且可以保障数据库系统的安全。我们通过视图看到的数据只是存放在基本表中的数据。当对通过视图看到的数据进行修改时，相应的基本表的数据也要发生变化，同时，若基本表的数据发生变化，则这种变化也可以自动地反映到视图中。 视图的作用与直接从数据库表中读取数据相比，视图具有以下优点： 简单化看到的就是需要的。视图不仅可以简单化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全性通过视图，用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见、也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特殊的行和特殊的列上。通过视图，用户可以被限制在数据的不同子集上，如下：● 使用权限可被限制在基表的行的子集上。● 使用权限可被限制在基表的列的子集上。● 使用权限可被限制在基表的行和列的子集上。● 使用权限可被限制在多个基表的连接所限定的行上。● 使用权限可被限制在基表中的数据的统计汇总上。● 使用权限可被限制在另一视图的一个子集上，或是一些视图和基表合并后的子集上。 逻辑数据独立性视图可以帮助用户屏蔽真实表结构变化带来的影响。 数据库表设计数据库表的设计根据提供的数据进行分析，由于现阶段只是前期的测试阶段，所采用的数据不是最终的数据，只是项目测试需要的数据，而且日志又分了等级和类型，主机也有自己的分组，我就考虑将主机分组、日志类型和日志等级分别建表，便于以后的修改，于是乎就一共有四张表产生。分别为：日志表、类型表、等级表和主机分组表（红色下划线表示主键，蓝色下划线表示外键） 类型表（日志类型、类型名称） 等级表（日志等级、等级名称） 主机分组表（主机分组、分组名称） 日志表（主机id、日志类型、日志等级、日志时间、日志消息、主机分组） 字段类型设计其中各个表的字段大多对应的是计算机产生的数据，大多数应为字符串，字段的对应的类型再次设置为 character varying ，这个类型为可变长的字符串型，日志时间设置为date类型。 测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 Debian 9系统 PostgreSQL 注：由于PostgreSQL操作使用pgAdmin实现，而Windows 10系统使用pgAdmin 4，Debian 9系统使用pgAdmin3，两者几乎完全一样，故此处只在Windows 10系统上进行测试 创建数据库表类型表的创建语句CREATE TABLE public.&quot;Class&quot; ( &quot;日志类型&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;类型名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, CONSTRAINT &quot;Class_pkey&quot; PRIMARY KEY (&quot;日志类型&quot;) ) WITH ( OIDS = FALSE ) TABLESPACE pg_default; ALTER TABLE public.&quot;Class&quot; OWNER to postgres; 等级表的创建语句CREATE TABLE public.&quot;Grade&quot; ( &quot;日志等级&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;等级名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, CONSTRAINT &quot;Grade_pkey&quot; PRIMARY KEY (&quot;日志等级&quot;) ) WITH ( OIDS = FALSE ) TABLESPACE pg_default; ALTER TABLE public.&quot;Grade&quot; OWNER to postgres; 主机分组表的创建语句CREATE TABLE public.&quot;Group&quot; ( &quot;主机分组&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;分组名称&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, CONSTRAINT &quot;Group_pkey&quot; PRIMARY KEY (&quot;主机分组&quot;) ) WITH ( OIDS = FALSE ) TABLESPACE pg_default; ALTER TABLE public.&quot;Group&quot; OWNER to postgres; 日志表创建语句CREATE TABLE public.&quot;Mess&quot; ( &quot;主机id&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;日志类型&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;日志等级&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;日志时间&quot; date NOT NULL, &quot;日志消息&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, &quot;主机分组&quot; character varying COLLATE pg_catalog.&quot;default&quot; NOT NULL, CONSTRAINT &quot;Mess_pkey&quot; PRIMARY KEY (&quot;主机id&quot;), CONSTRAINT &quot;CFkey&quot; FOREIGN KEY (&quot;日志类型&quot;) REFERENCES public.&quot;Class&quot; (&quot;日志类型&quot;) MATCH FULL ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED NOT VALID, CONSTRAINT &quot;Fkey&quot; FOREIGN KEY (&quot;主机分组&quot;) REFERENCES public.&quot;Group&quot; (&quot;主机分组&quot;) MATCH FULL ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED NOT VALID, CONSTRAINT &quot;GFkey&quot; FOREIGN KEY (&quot;日志等级&quot;) REFERENCES public.&quot;Grade&quot; (&quot;日志等级&quot;) MATCH FULL ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED NOT VALID ) WITH ( OIDS = FALSE ) TABLESPACE pg_default; ALTER TABLE public.&quot;Mess&quot; OWNER to postgres; 写入数据首先先确定日志类型、日志等级和主机分组的信息 类型表INSERT INTO public.&quot;Class&quot;( &quot;日志类型&quot;, &quot;类型名称&quot;) VALUES (&apos;C01&apos;, &apos;A&apos;),(&apos;C02&apos;,&apos;B&apos;),(&apos;C03&apos;,&apos;C&apos;),(&apos;C04&apos;,&apos;D&apos;); 等级表INSERT INTO public.&quot;Grade&quot;( &quot;日志等级&quot;, &quot;等级名称&quot;) VALUES (&apos;G01&apos;, &apos;A级&apos;),(&apos;G02&apos;,&apos;B级&apos;),(&apos;G03&apos;,&apos;C级&apos;),(&apos;G04&apos;,&apos;D级&apos;); 主机分组表INSERT INTO public.&quot;Group&quot;( &quot;主机分组&quot;, &quot;分组名称&quot;) VALUES (&apos;F01&apos;, &apos;A组&apos;),(&apos;F02&apos;,&apos;B组&apos;),(&apos;F03&apos;,&apos;C组&apos;),(&apos;F04&apos;,&apos;D组&apos;); 日志表INSERT INTO public.&quot;Mess&quot;( &quot;主机id&quot;, &quot;日志类型&quot;, &quot;日志等级&quot;, &quot;日志时间&quot;, &quot;日志消息&quot;, &quot;主机分组&quot;) VALUES(&apos;00000001&apos;,&apos;C01&apos;,&apos;G01&apos;,&apos;2018-03-14&apos;,&apos;asjdgahsfhdsvbjhdsvbcxnvvbjdfvbdsfjvbdsfbds&apos;, &apos;F01&apos;), (&apos;00000002&apos;,&apos;C02&apos;,&apos;G03&apos;,&apos;2018-03-14&apos;,&apos;asjdgahsfhdsvbjhdsvbcx215641462273412424&apos;,&apos;F04&apos;), (&apos;00000003&apos;,&apos;C04&apos;,&apos;G02&apos;,&apos;2018-03-21&apos;,&apos;12jdgahsfhdsvbjhdsvbcx215641462273412424&apos;,&apos;F03&apos;), (&apos;00000004&apos;,&apos;C03&apos;,&apos;G02&apos;,&apos;2018-03-26&apos;,&apos;12jdgahsfhd123456dsvbcx215641462273412424&apos;,&apos;F04&apos;), (&apos;00000005&apos;,&apos;C01&apos;,&apos;G04&apos;,&apos;2018-03-26&apos;,&apos;12jdgahsfhd123456dsvbcx215641462273412424&apos;,&apos;F02&apos;); 视图操作创建视图info_log视图的创建语句 CREATE OR REPLACE VIEW public.info_log AS SELECT &quot;Mess&quot;.&quot;主机id&quot;, &quot;Group&quot;.&quot;分组名称&quot;, &quot;Class&quot;.&quot;类型名称&quot;, &quot;Grade&quot;.&quot;等级名称&quot;, &quot;Mess&quot;.&quot;日志时间&quot;, &quot;Mess&quot;.&quot;日志消息&quot; FROM &quot;Mess&quot;, &quot;Group&quot;, &quot;Grade&quot;, &quot;Class&quot; WHERE &quot;Mess&quot;.&quot;主机分组&quot;::text = &quot;Group&quot;.&quot;主机分组&quot;::text AND &quot;Mess&quot;.&quot;日志类型&quot;::text = &quot;Class&quot;.&quot;日志类型&quot;::text AND &quot;Mess&quot;.&quot;日志等级&quot;::text = &quot;Grade&quot;.&quot;日志等级&quot;::text; ALTER TABLE public.info_log OWNER TO postgres; 视图查询通过视图进行所有日志信息的查询 SELECT &quot;主机id&quot;, &quot;分组名称&quot;, &quot;类型名称&quot;, &quot;等级名称&quot;, &quot;日志时间&quot;, &quot;日志消息&quot; FROM public.info_log; 总结分析 通过数据库表的设计和创建，加深了对数据库的理解，掌握了数据库基本操作技能 主键和外键的设置可以帮助我们理清各个表之间的关系，最后通过视图操作将其在一张表上显示，清晰明了 通过对视图的操作即可实现对各个表数据的操作，提升了操作效率 视图操作使得数据库其它表的修改变得方便、安全，通过视图，用户只能查询和修改他们所能见到的数据。 参考资料 PostgreSQL文档 PostgreSQL 9从零开始学","categories":[],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yoursite.com/tags/PostgreSQL/"}],"keywords":[]},{"title":"Electron开发流程","slug":"Electron开发流程","date":"2018-07-23T12:54:27.000Z","updated":"2018-10-06T01:40:42.000Z","comments":true,"path":"Electron开发流程/","link":"","permalink":"http://yoursite.com/Electron开发流程/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践操作 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的 使用Electron开发一个简单桌面应用Demo 了解Electron原理及开发逻辑、流程(编写→运行→打包) 文章前景 将网站构建为桌面应用程序，需求较为广泛 打通了B/S架构与跨平台桌面应用程序之间的界限 为后续开发复杂应用理清业务逻辑，探索开发方式 0x01-知识储备Node.js基础npm包管理安装：npm install moduleName # 安装模块到项目目录下 npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。 npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。 npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖 卸载：npm remove moduleName # 卸载项目目录下模块 npm remove -g moduleName # -g 的意思是全局卸载模块 npm remove -save moduleName # -save 的意思是卸载项目目录下模块，并在package文件的dependencies节点删除依赖。 npm remove -save-dev moduleName # -save-dev 的意思是卸载项目目录下模块 ，并在package文件的devDependencies节点删除依赖 注意：devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。 package-lock.json 文件 锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致 根据官方文档，这个package-lock.json 是在 npm install时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。 npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖 Electron基础Electron介绍如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 Electron文档由 指南、API参考、高级 组成，详细介绍了Electron的使用、接口、开发等一些了问题，是Electron学习必备的文档。 Electron特点Web技术Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。这是一个整合了Node，Chromium，V8的一个框架，通过它可以使用JavaScript，HTML, CSS技术来开发桌面应用程序 开源Electron 是一个由 GitHub 及众多贡献者组成的活跃社区共同维护的开源项目。 跨平台Electron 兼容 Mac, Windows 和 Linux， 它构建的应用可在这三个操作系统上面运行。 混合开发随着前端技术的发展，现在越来越多的桌面应用程序会嵌入一些Web技术来进行混合开发，结合了web端和传统桌面软件各自的优点。 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 PostgreSQL Node.js 0x03-方案设计electron-packager打包创建一个简单页面，通过Electron打开、打包、更改图标、整合成安装包、更新 electron-builder打包进一步优化，使得可以打包成安装程序，生成文件尽可能小，并且支持自动升级 0x04-实践操作Electron安装由于国外镜像不能访问的原因，所以使用国内淘宝npm镜像进行安装。 npm install -g package --registry=https://registry.npm.taobao.org 也可以使用淘宝NPM开发的cnpm进行package的安装 //首先安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org //使用cnpm进行安装，使用方法和npm相同，全局安装 cnpm install -g electron //查看electron版本 electron -v 使用npm通过淘宝镜像安装和cnpm安装，均可成功安装electron（原electron-prebuilt）。 创建应用创建一个electron应用。我们现在仅仅需要3个文件。 index.html main.js package.json index.html使我们想要显示的页面，main.js为此应用的入口，package.json为npm项目的配置文件。 新建一个名为electron的文件夹，进入项目目录进行初始化产生package.json文件 mkdir electron cd electron npm init 使得package.json为中名称为：HelloElectron；描述为：a simple application；scripts中添加”start”: “electron .”；署名为：xiafei_xupt,其余默认即可 新建一个index.html, 使得页面标题为：HelloElectron！；页面内容为：Hello Electron！ 新建一个main.js, 内容如下：（main.js的文件名对应package.json中main的值），同时关闭调试工具。 运行应用在Electron目录下执行npm start 或electron .即可运行 如果你是局部安装，则运行： ./node_modules/.bin/electron . npm start 应用打包electron-packager打包安装electron-packager它也是一个npm模块，是一个用于打包electron应用的工具 npm install -g electron-packager electron-packager --version 开始打包打包格式如下： electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 但是这样并不够，会提示： Unable to determine Electron version. Please specify an Electron version需要指明Electron version，改进为: electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] --electron-version=&lt;electron version&gt; eg: electron-packager . HelloElectron win32 x64 --electron-version=2.0.6 或 electron-packager . HelloElectron --platform=win32 --arch=x64 --electron-version=2.0.6 打包结束即在当前目录下生成了一个116M的HelloElectron文件夹，该文件夹内有一个65M大小的HelloElectron.exe通过图形界面进入该文件夹，双击即可运行。 通过查看resources\\app目录，可以查看到项目的源代码。 补充 最简单一键打包命令会打包生成所有你需要的各种platform各种arch的包 electron-packager ./ –all 即： electron-packager ./ –all –electron-version=2.0.6 分平台分arch打包 platform 取值有：darwin, linux, mas, win32 。命令： electron-packager ./ --platform=darwin electron-packager ./ --platform=linux electron-packager ./ --platform=mas electron-packager ./ --platform=win32 不写arch的情况下，arch的取值就是打包的电脑的arch值。一般可以取值有： ia32,x64,armv7l,arm64 electron-packager ./ --arch=ia32 electron-packager ./ --arch=x64 electron-packager ./ --arch=armv7l electron-packager ./ --arch=arm64 新生成的包，如果你想继续实验其他选项的话，可能是难以删除的。可以增加个--overwrite参数，会覆盖原有的build。有关其他可选标志的概述，请运行electron-packager --help或查看 usage.txt。有关详细说明，请参阅API文档。 如果我们想要更改窗口左上角的图标和任务栏的图标，只需要在打包的命令上加个icon参数 --icon= &lt;ico_address&gt;eg: --icon=./app/img/icon.ico electron-builder打包安装electron-builder npm install electron-builder -g electron-builder --version 开始打包 实际上打包过程会各种超时,建议挂代理 打包结束打开应用 安装应用 运行应用 补充 一键构建所有安装包electron-builder -mwlelectron-builder –platform=allelectron-builder –win –x64 分平台构建安装包 mac： electron-builder -m electron-builder -o electron-builder --mac electron-builder --macos electron-builder --platform=mac electron-builder --platform=darwin win: electron-builder -w electron-builder --win electron-builder --windows electron-builder --platform=win electron-builder --platform=win32 linux: electron-builder -l electron-builder --linux electron-builder --platform=linux 参数说明 –platform 这个参数是过期废弃的参数，不建议使用。同样，还有 –arch （取值是ia32/x64/all）也是一个过期参数。替代参数是 –x64 或者 –ia32 或者 –armv7l 。 当 –platform 或者 –arch 没有指定的时候，就会build当前系统的platform，当前系统的arch。也就是说，下面的命令在不同的系统下，命令是不一样的。（没有指定platform和arch）。 electron-builder –help 可查看相关用法 latest.yml为与更新相关文件，了打包时生成latest.yml文件，需要在 build 参数中添加 publish 配置，即： “publish”: [ { “provider”: “generic”, “url”: “http://localhost:4000/version&quot;//更新服务器地址 } ]则： 注意 devDependencies与dependencies的区别dependencies 表示我们要在生产环境下使用该依赖，devDependencies 则表示我们仅在开发环境使用该依赖。在打包时，一定要分清哪些包属于生产依赖，哪些属于开发依赖，尤其是在项目较大，依赖包较多的情况下。若在生产环境下错应或者少引依赖包，即便是成功打包，但在使用应用程序期间也会报错，导致打包好的程序无法正常运行。 npm与cnpm的区别说到npm与cnpm的区别，可能大家都知道，但大家容易忽视的一点，是cnpm装的各种node_module，这种方式下所有的包都是扁平化的安装。一下子node_modules展开后有非常多的文件。导致了在打包的过程中非常慢。但是如果改用npm来安装node_modules的话，所有的包都是树状结构的，层级变深。由于这个不同，对一些项目比较大的应用，很容易出现打包过程慢且node内存溢出的问题（这也是在解决electron打包过程中困扰我比较久的问题，最后想到了npm与cnpm的这点不同，解决了node打包内存溢出的问题，从打包一次一小时优化到打包一次一分钟，极大的提高了效率）。所以建议在打包前，将使用cnpm安装的依赖包删除，替换成npm安装的依赖包。 0x05-总结分析文章结论electron-packager打包 支持平台有：Windows (32/64 bit)、OS X (also known as macOS)、Linux (x86/x86_64); 进行应用更新时，使用electron内置的autoUpdate进行更新 支持CLI和JS API两种使用方式； electron-builder打包 electron-builder 可以打包成msi、exe、dmg文件，macOS系统，只能打包dmg文件，window系统才能打包exe，msi文件； 几乎支持了所有平台的所有格式； 支持Auto Update； 支持CLI和JS API两种使用方式； electron应用整合成一个安装包另外可以使用下面两种方法： NSIS打包Electron grunt打包Electron 文章分析本文使用Electron创建一个简单页面，实现了打开、打包、更改图标、整合成安装包等功能，展示了Electron应用开发的简单流程，使得开发逻辑更加清晰，开发过程更加具体，开发目的更加明确。 使用electron-packager打包生成文件较大，且是以文件夹形式生成，较为臃肿；源码暴露，不安全 使用electron-builder打包应用是安装包方式，而不像electron-packager打包之后直接是一个文件夹，里面所有的文件暴露出来。 其中关于应用打包工具，推荐使用electron-builder打包，相比electron-packager有以下优点： 支持更多的平台 支持了自动更新 打出的包更为轻量 打出的包不暴露源码 可以打包出setup安装程序 0x06-程序源码package.json{ &quot;name&quot;: &quot;HelloElectron&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a simple application&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot; }, &quot;author&quot;: &quot;xiafei_xupt&quot;, &quot;license&quot;: &quot;ISC&quot; } index.html&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;HelloElectron！&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Electron!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; main.jsconst {app, BrowserWindow} = require(&apos;electron&apos;); let win; let windowConfig = { width:800, height:600 }; function createWindow(){ win = new BrowserWindow(windowConfig); win.loadURL(`file://${__dirname}/index.html`);//接口 //开启调试工具 //win.webContents.openDevTools(); win.on(&apos;close&apos;,() =&gt; { //回收BrowserWindow对象 win = null; }); win.on(&apos;resize&apos;,() =&gt; { win.reload(); }) } app.on(&apos;ready&apos;,createWindow); app.on(&apos;window-all-closed&apos;,() =&gt; { app.quit(); }); app.on(&apos;activate&apos;,() =&gt; { if(win == null){ createWindow(); } }) Electron Demo打包为避免命名冲突，重命名为electron-v1.0.0（密码：dkes） 0x07-参考资料 electron-packager文档 Electron官网 Electron 文档 打造你第一个 Electron 应用 electron-packager打包工具的最简化使用 electron打包：electron-packager及electron-builder两种方式实现","categories":[],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}],"keywords":[]},{"title":"PostgreSQL语法学习","slug":"PostgreSQL语法学习","date":"2018-07-15T16:00:00.000Z","updated":"2018-08-11T05:43:28.000Z","comments":true,"path":"PostgreSQL语法学习/","link":"","permalink":"http://yoursite.com/PostgreSQL语法学习/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-参考资料 0x00-文章前言文章目的 熟悉数据库操作基本流程、数据操作命令、编程接口 建立一个简单表格，可以通过SELECT语句查询出来 了解PostgreSQL的相关语法，为后期项目开发做准备 文章前景 有益于对数据库基本操作的掌握 有助于对PostgreSQL语法的学习 有利于对后期相关项目的顺利进展 0x01-知识储备Debian 9上pgadmin3和Windows 10上pgAdmin 4类似，SQL命令完全一样，故此处仅在Windows 10上进行相关学习即可，以下内容为PostgreSQL语法学习所需基础知识。 PostgreSQL命令大全可以使用help语句来获取帮助信息。 按照以下步骤查看PostgreSQL中相关命令的使用。 安装postgreSQL后，打开psql为：程序文件 -&gt; PostgreSQL 10 -&gt; SQL Shell(psql)，输入相关信息即可启动数据库。 获取帮助信息 postgres=＃help 显示发行条款 postgres=＃\\copyright 显示 SQL 命令的说明 postgres=＃\\h 显示 pgsql 命令的说明 postgres=＃\\? …… PostgreSQL语法大全数据库操作 创建数据库: create database database_name; 查看数据库: \\l 删除数据库: drop database database_name; 表格操作 创建表格 CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ….. columnN datatype, PRIMARY KEY( one or more columns ) ); 删除表格 DROP TABLE table_name; 插入数据 INSERT INTO TABLE_NAME (column1, column2, column3,…columnN) VALUES (value1, value2, value3,…valueN); 查询数据 SELECT “column1”, “column2”..”column” FROM “table_name”; 更新数据 UPDATE table_name SET column1 = value1, column2 = value2…., columnN = valueN WHERE [condition]; 删除数据 DELETE FROM table_name WHERE [condition]; 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G 软件 Windows 10系统 Debian 9系统 PostgreSQL 0x03-方案设计UI操作操作起来较为简单，适合于小量数据，用户体验度高 命令操作使用SQL语句操作，由于使用命令，可复用操作大量数据，效率高 0x04-实践验证创建数据库在PostgreSQL中，可以使用CREATE DATABASE命令创建数据库。 语法： CREATE DATABASE database_name; 这里，database_name是指定要创建的数据库的名称。 打开开始菜单，然后单击pgAdmin,第一次打开可能需要你输入密码，结果如下右键单击PostgreSQL 10并将PostgreSQL连接到本地主机服务器。右键单击数据库(Databases)，转到新数据库，将出现一个弹出框，如下图所示 - 然后键入您要的数据库名称，这里创建的数据库名称是：test_db，如下图所示点击保存(Save)就可以了。创建新的数据库(test_db)如下图所示 PostgreSQL使用查询工具创建数据库打开SQL Shell(psql)，执行以下创建语句 create database testdb; 执行结果如下 查看数据库或者在 pgAdmin 的左侧中查看，结果如下 删除数据库使用pgAdmin删除数据库 test_db右键单击数据库：test_db，左键单击delete/drop选项。将收到以下弹出框。点击“是(Yes)”完全删除数据库“test_db” 看到结果： 在PostgreSQL中，可以使用DROP DATABASE命令删除数据库。语法： DROP DATABASE database_name; 这里，database_name是指定要创建的数据库的名称。 PostgreSQL使用查询工具删除数据库打开SQL Shell(psql)，执行以下创建语句 drop database testdb; 查看数据库： 执行语句如下 看到结果： 创建表格在PostgreSQL中，CREATE TABLE语句用于在任何给定的数据库中创建一个新表。 语法： CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); UI操作 首先选择要创建表的数据库。 左键单击与所选数据库关联的框类型结构,将看到目录和模式(架构)。 左键单击与模式(架构)关联的框类型结构。现在可以看到public。 左键单击与公共(public)关联的框类型结构，就可以看到有数据表。 选择数据表，右键单击数据表，会得到一个新的弹出表框，创建所需的表。参见示例：创建test_db2数据库，然后创建表:student添加数据 查看SQL脚本 命令操作PostgreSQL使用SQL命令创建表：student2查看所创表格： 删除表格UI操作右键单击所选表，这里选择表为：student2。找到表并选择点击完成。现在应该会看到这样的：点击确定(OK),则该表被删除。现在可以看到没有那个student2的表了。 命令操作 插入数据在PostgreSQL中，INSERT查询用于在表中插入新行。 您可以一次插入单行或多行到表中。 语法： INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN); 注意：column1, column2, column3,…columnN是要插入数据的表中的列的名称。 UI操作 命令操作操作成功 查询数据在PostgreSQL中，SELECT语句用于从数据库表中检索数据。 数据以结果表格的形式返回。 这些结果表称为结果集。 语法： SELECT &quot;column1&quot;, &quot;column2&quot;..&quot;column&quot; FROM &quot;table_name&quot;; 这里，column1，column2，.. columnN指定检索哪些数据的列。 如果要从表中检索所有字段，则必须使用以下语法： SELECT * FROM &quot;table_name&quot;; 使用SQL语句操作：操作成功 更新数据在PostgreSQL中，UPDATE语句用于修改表中现有的记录。 要更新所选行，您必须使用WHERE子句，否则将更新所有行。 语法： 以下是update语句的基本语法： UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; 使用SQL语句操作：操作成功 删除数据DELETE语句用于从表中删除现有记录。 “WHERE”子句用于指定删除所选记录的条件，如是不指定条件则将删除所有记录。 语法： 以下是DELETE语句的基本语法： DELETE FROM table_name WHERE [condition]; 使用SQL语句操作：操作成功 0x05-总结分析 PostgreSQL的语法和其它数据库语法基本一样，可以说，几乎所有的数据库语法都是通用的 使用SQL脚本方便了数据表格的创建，可以跨平台使用，从而使得数据库迁移变得较为方便 0x06-参考资料 PostgreSQL文档 PostgreSQL教程","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yoursite.com/tags/PostgreSQL/"}],"keywords":[]},{"title":"PostgreSQL环境搭建","slug":"PostgreSQL环境搭建","date":"2018-07-09T12:54:27.000Z","updated":"2018-08-11T05:11:58.000Z","comments":true,"path":"PostgreSQL环境搭建/","link":"","permalink":"http://yoursite.com/PostgreSQL环境搭建/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-参考资料 0x00-文章前言文章目的 熟悉数据库设计基本原理，安装数据库开发环境 了解PostgreSQL的特点及工具，为后期项目开发做准备 文章前景 对于规范开发具有参考意义 有利于对PostgreSQL的理解 0x01-知识储备数据库原理是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序共享。数据库存放数据是按数据所提供的数据模式存放的，具有集成与共享的特点。 PostgreSQL简介PostgreSQL是什么PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。 它是开源的，其源代码是免费提供的。PostgreSQL是跨平台的，可以在许多操作系统上运行，如Linux，FreeBSD，OS X，Solaris和Microsoft Windows等。自从MySQL被Oracle收购以后，PostgreSQL逐渐成为开源关系型数据库的首选。 PostgreSQL的历史PostgreSQL由计算机科学教授Michael Stonebraker在UCB创建。 它最初叫做Postgres。 1986年由Michael Stonebraker教授作为后续项目和Ingres项目启动，克服了当代数据库系统的问题。 PostgreSQL现在是任何地方都很先进的开源数据库。 PostgreSQL的特点PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。 PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。 PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。 在PostgreSQL中，表可以设置为从“父”表继承其特征。 可以安装多个扩展以向PostgreSQL添加附加功能。 PostgreSQL的工具有一些开放源码以及付费工具可用作PostgreSQL的前端工具。 这里列出几个被广泛使用的工具： psql：它是一个命令行工具，也是管理PostgreSQL的主要工具。 pgAdmin是PostgreSQL的免费开源图形用户界面管理工具。 phpPgAdmin:它是用PHP编写的PostgreSQL的基于Web的管理工具。 它基于phpMyAdmin工具管理MySQL功能来开发。它可以用作PostgreSQL的前端工具。 pgFouine：它是一个日志分析器，可以从PostgreSQL日志文件创建报告。 0x02-测试环境硬件 处理器：i7 内存：8G 显示器：VGA 或更高 硬盘空间：128G软件 Windows 10系统 Debian 9系统 0x03-方案设计图形安装使用鼠标操作完成安装（适用于Windows 10系统） 命令安装使用shell命令完成安装（适用于Debian 9系统） 0x04-实践验证实践操作Windows 10下图形安装 选择合适的PostgreSQL的版本号以及对应系统，并从这里下载并下载：http://www.enterprisedb.com/products-services-training/pgdownload#windows由于我的系统是 Windows 10 64位，所以选择以下对应的版本 - PostgreSQL 10.4 Windows x86-64 以管理员身份运行下载的postgresql-10.4-1-windows-x64来安装PostgreSQL。 与安装其它软件一样，没有什么特别之处，选择下一步就好。 选择要安装的位置。 默认情况下，它安装在程序文件夹(C:\\Program File)中。 设置将要求您输入密码，因此请您输入密码，这里我输入的密码是：password。 设置PostgreSQL服务器的端口，保持默认，点击下一步。 安装过程就绪。完成安装过程需要一些时间。 完成安装过程后，您将看到以下屏幕取消选中复选框按钮，然后单击完成按钮完成安装。Debian 9下命令安装以root用户进行安装： root@bogon:/home/debian/Downloads# apt-get install postgres root@bogon:/home/debian/Downloads# apt-get install pgadmin3安装pgadmin（以pgAdmin3为例）实践结果Windows 10下图形安装在开始菜单点击SQL Shell (psql)，输入相关信息即可启动数据库。安装成功！Debian 9下命令安装安装成功！0x05-总结分析 PostgreSQL兼容性强，可以跨平台使用 PostgreSQL安装过程较为简单，环境搭建较为方便 0x06-参考资料 PostgreSQL文档 PostgreSQL教程 PostgreSQL在debian下安装、使用","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yoursite.com/tags/PostgreSQL/"}],"keywords":[]},{"title":"Linux /proc目录下信息提取","slug":"proc目录下信息提取","date":"2018-06-24T16:00:00.000Z","updated":"2018-08-11T05:50:32.000Z","comments":true,"path":"proc目录下信息提取/","link":"","permalink":"http://yoursite.com/proc目录下信息提取/","excerpt":"","text":"0x00-文章前言 0x01-知识储备 0x02-测试环境 0x03-方案设计 0x04-实践验证 0x05-总结分析 0x06-程序源码 0x07-参考资料 0x00-文章前言文章目的了解proc文件系统即/proc目录，获取该目录下内核运行状态的一系列系统状态信息，并将其以文档形式导出。 文章前景可以更加及时、准确地获得系统状态信息，以便后续对其进行分析、评估、预测、态势感知等。 0x01-知识储备proc文件系统简介proc的全称为process data system ，proc文件系统是一种无存储的文件系统，当读其中的文件时，其内容动态生成，当写文件时，文件所关联的写函数被调用。每个proc文件都关联的字节特定的读写函数，因而它提供了另外的一种和内核通信的机制：内核部件可以通过该文件系统向用户空间提供接口来提供查询信息、修改软件行为，因而它是一种比较重要的特殊文件系统。 Linux系统上的/proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。proc文件系统属于虚拟文件系统，即该文件系统的数据，由内核动态生成，并不会存放在持久存储数据中。“即时”产生文件信息，换句话说，只有发出读操作请求时，才会产生信息。它以文件系统的方式为访问系统内核数据的操作提供接口。 proc文件系统，使得内核可以生成与系统状态和配置有关的信息。该信息可以由用户和系统程序从普通文件读取，而无需专门的工具与内核通信。从内核开发趋势来看，正在远离用proc文件系统提供的信息，而倾向于采用特定与问题的虚拟文件系统来导出数据。一个很好的例子就是USB文件系统，将与USB子系统有关的许多状态信息导出到用户空间，而没有给proc增加新的负担。但这并不意味这，proc文件系统变的多余，当今，/proc依旧重要，不仅在安装新的发布版时，而且也用于支持（自动化的）系统管理。 procfs 是进程文件系统(file system) 的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 /proc 目录。由于 /proc 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。 proc目录中的常见文件介绍静态生成：静态生成、动态变化动态生成：动态变化 /proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。/proc/[pid] /proc/[pid]/attr / proc / [pid] / attr / current 该文件的内容代表当前的安全性过程的属性。 / proc / [pid] / attr / exec（自Linux 2.6.0开始该文件表示要分配给进程的属性 / proc / [pid] / attr / fscreate（自Linux 2.6.0开始）该文件表示要分配给创建的文件的属性 / proc / [pid] / attr / keycreate（自Linux 2.6.18开始） 如果一个进程将安全上下文写入这个文件，全部随后创建的键（add_key（2））将被标记这个背景。 /proc/cpu/infocat /proc/cpuinfo / proc / [pid] / stat 有关进程的状态信息。这由ps（1）使用。 它在内核源文件fs / proc / array.c中定义。 这些字段按顺序带有适当的scanf（3）格式speci- 以下列出。是否某些这些 字段显示有效信息由ptrace管理 访问模式PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT 检查（参考ptrace（2））。如果支票拒绝访问，那么 字段值显示为0.受影响的字段为 用标记[PT]表示。 （1）pid ％d 进程ID。 （2）通讯 ％s 可执行文件的文件名，括号中。 无论可执行文件是否可见，这都是可见的 换出。 （3）状态 ％c 指示过程的以下字符之一 州： R运行 S睡在可中断的等待中 D正在等待不间断磁盘睡眠 Z Zombie T停止（在信号上）或（在Linux 2.6.33之前） 追踪停止 t跟踪停止（Linux 2.6.33以上） W Paging（仅在Linux 2.6.0之前） X Dead（从Linux 2.6.0开始） x Dead（仅Linux 2.6.33至3.13） K Wakekill（仅适用于Linux 2.6.33至3.13） W醒来（仅适用于Linux 2.6.33至3.13） P停放（仅适用于Linux 3.9至3.13） （4）ppid ％d 此进程的父进程的PID。 （5）pgrp ％d 进程的进程组ID。 （6）会话 ％d 进程的会话ID。 （7）tty_nr ％d 过程的控制终端。（未成年人 设备编号包含在组合中 位31至20和7至0; 主要的设备编号是 在位15至8中） （8）tpgid ％d con的前台进程组的ID 流程的终端。 （9）标志 ％u 内核标记进程的单词。对于位平均 - 请参阅Linux内核中的PF_ *定义 源文件include / linux / sched.h。细节取决于 在内核版本上。 此字段的格式为Linux 2.6之前的％lu。 （10）minflt ％lu 过程所做的轻微故障的数量 不需要从中加载内存页面 磁盘。 （11）cminflt ％lu 该进程的小错误数量 等待的孩子们已经做出了决定。 （12）majflt ％lu 过程所造成的重大故障的数量 这需要从磁盘加载一个内存页面。 （13）cmajflt ％lu 该进程的主要故障数量 等待的孩子们已经做出了决定。 （14）utime ％lu 此进程已计划的时间量 在用户模式下，以时钟滴答度量（除以 sysconf（_SC_CLK_TCK））。这包括访客时间， guest_time（运行虚拟CPU所花费的时间，请参阅 下面），以便不知道的应用程序 来宾时间字段不会从那时失去 他们的计算。 （15）stime ％lu 此进程已计划的时间量 在内核模式下，以时钟滴答度量（除以 sysconf（_SC_CLK_TCK））。 （16）cutime ％ld 这个进程等待的时间量， dren已经安排在用户模式下，以英寸计量 时钟滴答（除以sysconf（_SC_CLK_TCK））。（看到 也包括时间（2））。这包括访客时间， cguest_time（运行虚拟CPU所用的时间，请参阅 下面）。 （17）cstime ％ld 这个进程等待的时间量， dren已经在内核模式下进行了安排， 时钟滴答（除以sysconf（_SC_CLK_TCK））。 （18）优先级 ％ld （针对Linux 2.6的解释）对于正在运行的进程 实时调度策略（以下策略 ;请参见 sched_setscheduler（2）），这是否定的schedul- 优先级，减1; 那就是一个数字 范围-2到-100，对应于实时优先级 - 关系1到99.对于在non- 实时调度策略，这是非常好的 值（setpriority（2）），如内核中所示。 内核在数据中存储很好的值 范围0（高）到39（低），对应于 用户可见的-20至19的好范围。 在Linux 2.6之前，这是基于的一个缩放值 调度程序给予这个过程的权重。 （19）nice ％ld 好的值（请参阅setpriority（2）），这是一个值 范围19（低优先级）至-20（高优先级）。 （20）num_threads ％ld 此过程中的线程数（自Linux 2.6开始）。 在内核2.6之前，这个字段被硬编码为0 先前移除的字段的占位符。 （21）itrealvalue ％ld 在下一个SIGALRM之前jiffies的时间发送 归因于间隔计时器的过程。由于ker- nel 2.6.17，这个字段不再维护，并且 被硬编码为0。 （22）starttime ％llu 系统启动后进程启动的时间。在 Linux 2.6之前的内核，表达了这个值 在jiffies。从Linux 2.6开始，数值被表达出来 在时钟周期中（除以sysconf（_SC_CLK_TCK））。 此字段的格式为Linux 2.6之前的％lu。 （23）vs ％lu 虚拟内存大小（字节）。 （24）rss ％ld 驻留集大小：进程拥有的页数 在真实的记忆中。这只是计数的页面 朝向文本，数据或堆栈空间。这不是 包括未被请求加载的页面， 或哪些被换出。 （25）rsslim ％lu 当前在软件rss上的软限制 处理; 看到的描述RLIMIT_RSS在 getrlimit（2） 。 （26）startcode ％lu [PT] 程序文本可以运行的地址。 （27）endcode ％lu [PT] 程序文本可以运行的地址。 （28）startstack ％lu [PT] 开始的地址（即底部） 叠加。 （29）kstkesp ％lu [PT] 发现ESP（堆栈指针）的当前值 在进程的内核堆栈页面中。 （30）kstkeip ％lu [PT] 当前的EIP（指令指针）。 （31）信号 ％lu 未决信号的位图显示为deci- mal号码。已过时，因为它不提供 有关实时信号的信息; 使用 / proc / [pid] / status。 （32）阻止 ％lu 被阻塞信号的位图显示为一个deci- mal号码。已过时，因为它不提供 有关实时信号的信息; 使用 / proc / [pid] / status。 （33）sigignore ％lu 忽略信号的位图，显示为一个deci- mal号码。已过时，因为它不提供 有关实时信号的信息; 使用 / proc / [pid] / status。 （34）sigcatch ％lu 捕获信号的位图，以小数形式显示 数。已过时，因为它不提供 有关实时信号的信息; 使用 / proc / [pid] / status。 （35）wchan ％lu [PT] 这是进程等待的“通道” ING。它是内核中某个位置的地址 进程在睡觉的地方。相应的 符号名称可以在/ proc / [pid] / wchan中找到。 （36）nswap ％lu 交换页数（不保留）。 （37）cnswap ％lu子进程的 累积nswap（不是main- tained）。 （38）exit_signal ％d（自Linux 2.1.22开始） 当我们死亡时，信号被发送给父母。 （39）处理器 ％d（自Linux 2.2.8开始） 上次执行的CPU号码。 （40）rt_priority ％U（因为Linux 2.5.19） 实时调度优先级，范围内的一个数字 1到99用于实时调度的进程 策略或0，用于非实时进程（请参阅 sched_setscheduler（2））。 （41）策略 ％u（自Linux 2.5.19开始） 调度策略（请参阅sched_setscheduler（2））。 使用linux / sched.h中的SCHED_ *常量进行解码。 这个字段的格式是Linux之前的％lu 2.6.22。 （42）delayacct_blkio_ticks ％llu（自Linux 2.6.18开始） 累计块I / O延迟，以时钟滴答度量 （厘秒）。 （43）guest_time ％lu（自Linux 2.6.24起） 过程的访客时间（运行vir- 用于客户操作系统的双CPU），以英寸计算 时钟滴答（除以sysconf（_SC_CLK_TCK））。 （44）cguest_time ％ld（自Linux 2.6.24起） 该过程的孩子的访客时间，以英寸计 时钟滴答（除以sysconf（_SC_CLK_TCK））。 （45）start_data ％lu（自Linux 3.3起）[PT] 程序初始化和unini- tialized（BSS）数据被放置。 （46）end_data ％lu（自Linux 3.3起）[PT] 地址在哪个程序初始化和unini- tialized（BSS）数据被放置。 （47）start_brk ％lu（自Linux 3.3起）[PT] 程序堆的地址可以扩展 与brk（2）。 （48）arg_start ％lu（自Linux 3.5起）[PT] 程序命令行参数上面的地址 （argv）被放置。 （49）arg_end ％lu（自Linux 3.5起）[PT] 程序命令行参数（argv）下的地址 摆放在。 （50）env_start ％lu（自Linux 3.5起）[PT] 在上面放置程序环境的地址。 （51）env_end ％lu（自Linux 3.5起）[PT] 地址在哪个程序环境下放置。 （52）exit_code ％d（自Linux 3.5起）[PT] 线程的退出状态以表格形式报告 waitpid（2）。 / proc / [pid] / status 提供/ proc / [pid] / stat和 / proc / [pid] / statm中的大部分信息， 解析。这是一个例子： $ cat / proc / $$ / status Name: bash Umask: 0022 State: S (sleeping Tgid：17248 Ngid：0 Pid：17248 PPid：17200 TracerPid：0 Uid：1000 1000 1000 1000 Gid：100 100 100 100 FDSize：256 Groups：16 33 100 NStgid：17248 NSpid：17248 NSpgid：17248 NSsid：17200 VmPeak：131168 kB VmSize：131168 kB VmLck：0 kB VmPin：0 kB VmHWM：13484 kB VmRSS：13484 kB RssAnon：10264 kB RssFile：3220 kB RssShmem：0 kB VmData：10332 kB VmStk：136 kB VmExe：992 kB VmLib：2104 kB VmPTE：76 kB VmPMD：12 kB VmSwap：0 kB HugetlbPages：0 kB＃4.4 Threads：1 SigQ: 0/3067 SigPnd: 0000000000000000 ShdPnd: 0000000000000000 SigBlk: 0000000000010000 SigIgn: 0000000000384004 SigCgt: 000000004b813efb CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: ffffffffffffffff CapAmb: 0000000000000000 NoNewPrivs：0 Seccomp：0 Cpus_allowed：00000001 Cpus_allowed_list：0 Mems_allowed：1 Mems_allowed_list：0 volunte_ctxt_switches：150 nonvoluntary_ctxt_switches：545 这些字段如下所示： * 名称：由此进程运行的命令。 * Umask：处理umask，用八进制表示一个领先的 零; 见umask（2）。（从Linux 4.7开始）。 * 状态：进程的当前状态。其中一个“R（跑步）”， “S（睡眠）”，“D（磁盘睡眠）”，“T（停止）”，“T（追踪 停止）“，”Z（僵尸）“或”X（死亡）“。 * Tgid：线程组ID（即进程ID）。 * Ngid：NUMA组ID（如果没有，则为0;自Linux 3.13以来）。 * Pid：线程ID（请参阅gettid（2））。 * PPid：父进程的PID。 * TracerPid：进程跟踪此进程的PID（如果不是，则为0） 被追踪）。 * Uid，Gid：真实，有效，保存的设置和文件系统UID （GID的）。 * FDSize：当前分配的文件描述符插槽的数量。 * 团体：补充小组名单。 * NStgid：每个PID中的线程组ID（即PID） 其中[pid]是其成员的名称空间。最左边的条目 显示相对于PID命名空间的值 读取过程，接着是值 嵌套的内部命名空间。（从Linux 4.1开始） * NSpid：每个PID名称空间中的线程ID，其中 [pid]是其成员。这些字段按照NStgid排序。 （从Linux 4.1开始） * NSpgid：在每个PID名称空间中处理组ID 哪个[pid]是成员。这些字段按照Nst- gid排序。（从Linux 4.1开始） * NSsid：后代命名空间会话ID层次结构会话ID 在其中[pid]是其成员的每个PID名称空间中。 这些字段按照NStgid排序。（从Linux 4.1开始） * VmPeak：峰值虚拟内存大小。 * VmSize：虚拟内存大小。 * VmLck：锁定内存大小（请参阅mlock（3））。 * VmPin：固定的内存大小（自Linux 3.2以来）。这些是 因某些需要而无法移动的页面 直接访问物理内存。 * VmHWM：高峰居民组大小（“高水位”）。 * VmRSS：居民组大小。请注意，这里的值是 总和RssAnon，RssFile和RssShmem。 * RssAnon：驻留匿名内存的大小。（自Linux以来 4.5）。 * RssFile：常驻文件映射的大小。（自Linux 4.5以来）。 * RssShmem：驻留共享内存的大小（包括System V 共享内存，来自tmpfs（5）的映射和共享匿名 映射）。（自Linux 4.5以来）。 * VmData，VmStk，VmExe：数据，堆栈和文本的大小seg- 发言：。 * VmLib：共享库代码大小。 * VmPTE：页表条目大小（自Linux 2.6.10起）。 * VmPMD：第二级页面表的大小（自Linux 4.0开始）。 * VmSwap：由匿名私人交换虚拟内存大小 页; 不包括shmem交换使用（因为Linux 2.6.34）。 * HugetlbPages：hugetlb内存部分的大小。（自Linux以来 4.4）。 * 线程数：包含这个的进程中的线程数 线。 * SigQ：该字段包含两个以斜线分隔的数字 与排队信号有关的真实用户ID 处理。其中第一个是当前的数量 排队的信号为这个真实的用户ID，第二个是 对此的排队信号数量的资源限制 处理（参照的描述RLIMIT_SIGPENDING在 getrlimit（2） ）。 * SigPnd，ShdPnd：线程和for的待处理信号的数量 作为一个整体（见pthreads（7）和signal（7））。 * SigBlk，SigIgn，SigCgt：指示信号的掩码 被阻止，被忽略并被捕获（见信号（7））。 * CapInh，CapPrm，CapEff：启用的功能掩码 可继承的，允许的和有效的集合（参见 能力（7））。 * CapBnd：Capability Bounding集合（自Linux 2.6.26起，参见 能力（7））。 * CapAmb：环境能力集（自Linux 4.3起，参见 能力（7））。 * NoNewPrivs：no_new_privs位的值（自Linux 4.10开始， 参见prctl（2））。 * Seccomp：进程的Seccomp模式（自Linux 3.8起，请参阅 seccomp（2））。0表示SECCOMP_MODE_DISABLED ; 1表示SEC- COMP_MODE_STRICT ; 2表示SECCOMP_MODE_FILTER。这个领域 仅当内核是在启用CON- FIG_SECCOMP内核配置选项的情况下生成的。 * Cpus_allowed：可以运行此进程的CPU的掩码 （从Linux 2.6.24开始，请参阅cpuset（7））。 * Cpus_allowed_list：与之前相同，但是以“列表格式” （从Linux 2.6.26开始，请参阅cpuset（7））。 * Mems_allowed：此进程允许的内存节点掩码 （从Linux 2.6.24开始，请参阅cpuset（7））。 * Mems_allowed_list：与之前相同，但是以“列表格式” （从Linux 2.6.26开始，请参阅cpuset（7））。 * voluntary_ctxt_switches，nonvoluntary_ctxt_switches：号码 自愿和非自愿的上下文切换（自Linux以来 2.6.23）。 11010091031041061071081111111311341212913131513231328133313541359136413661371393141401140314071414143614511455145914631476148514891494149915152115611572158415881590161602160316051611162216231626163516501664171725181851861922079208209021218222234232367237242526272829833535387338844041410424426427433447550050150250450550995100510251585160548550855095510551255625645705570857145905601860416050611617628635693695772373173574757689915936968980997 /proc/acpi； /proc/asound /proc/buddyinfo用于诊断内存碎片问题的相关信息文件； /proc/bus /cgroups /proc/cmdline在启动时传递至内核的相关参数信息，这些信息通常由lilo或grub等启动管理工具进行传递；/proc/consoles /proc/cpuinfo处理器的相关信息的文件； /proc/crypto /proc/devices /proc/diskstats /proc/dma /proc/driverdriverexecdomainsfbfilesystemsfsinterruptsiomemioportsirqkallsymskcorekeyskey-userskmsgkpagecgroupkpagecountkpageflagsloadavglocksmeminfomiscmodulesmountsmptmtrrnetpagetypeinfopartitionssched_debugschedstatselfslabinfosoftirqsstatswapssyssysrq-triggersysvipcthread-selftimer_listttyuptimeversionvmallocinfovmstatzoneinfo… proc的数据结构与Ext2一样，proc大量使用了VFS数据结构，因为作为一种文件系统，它必须集成到内核的VFS抽象层中。但，毕竟proc只是用于获取内核的数据为主要目的，所以在其设计的过程中，遵循简单实用的特性，较Ext2简单。 proc文件系统API内核为创建proc文件提供了一套API，相关API如下： struct proc_dir_entry proc_mkdir(const char name, struct proc_dir_entry *parent); 该函数用于在proc文件系统中创建一个目录项，大多数时候，当我们期望实现自己的proc文件时，都要先创建一个自己的目录，然后在该目录里创建自己的文件，当然我们也可以直接在已经存在的proc文件系统目录里创建自己的文件。该函数的各个参数含义如下：name：该目录的名字parent：该目录的父目录的名字void proc_remove(struct proc_dir_entry de);该函数用于删除一个目录。struct proc_dir_entry proc_create(const char name, umode_t mode, struct proc_dir_entry parent, const struct file_operations proc_fops);该函数用于在proc文件系统中创建一个proc文件，其参数含义如下：name：proc文件的名字，表现在proc文件系统中，就是文件的名字mode：proc文件的访问模式，表现在proc文件系统中，就是文件的访问模式parent：该proc文件所在的目录proc_fops：指向用于操作该文件的文件操作的指针这些参数提供了一个文件所需要的关键信息，包括文件名，访问模式，目录项（用于指定文件在文件系统中的位置），以及文件操作指针。当要删除一个文件时，需要使用API：void remove_proc_entry(const char name, struct proc_dir_entry *parent)；参数的含义是显然的，该函数用于从proc文件系统的指定目录删除指定的proc文件。还有一些其它的API，都定义在include/linux/prof_fs.h中。在proc文件系统中创建文件或者目录时，最终都会调到proc_register，该函数会为新创建的文件或目录指定正确的file_operations和inode_operations，它们将在访问文件时被使用。 深入理解计算机系统操作系统原理0x02-测试环境硬件环境软件环境0x03-方案设计方案A/proc目录下所有文件按目录形式复制出来，再进行选择性地提取有效信息。 方案B手动导出 方案C使用shell脚本直接提取目的信息，按合适格式导出到文档中。 方案D通过内核模块获取目的信息，按合适格式导出到文档中。 方案E代码直接调用mysql API, 方案FNode.js 直接调用系统API接口 0x04-实践验证实践操作实践结果方案Adf -a 显示为0ls -lh /proc/kcoredu -hs /proc/kcorels /proc/kcore -lhhexdump（或od）-r——– 1 root root 128T Jun 30 12:50 /proc/kcore /proc是伪文件系统，内核想报告多大就多大。又不用分配出来不可行。 方案B暂时先提取十条进程的信息/proc/17256/stat 1725 (gvfsd-metadata) S 693 1725 1725 0 -1 4194304 746 0 174 0 10 20 0 0 20 0 3 0 8235 198119424 479 18446744073709551615 94113580531712 94113580601292 140721845185440 0 0 0 0 4096 0 0 0 0 17 0 0 0 238 0 0 94113582698760 94113582702612 94113598459904 140721845193626 140721845193655 140721845193655 140721845194715 0即： 安装linux-header apt-get install -y linux-headers-$(uname -r) dmesg -C 0x05-总结分析文章结论文章分析0x06-程序源码代码A代码B0x07-参考资料 Linux Programmer’s Manual PROC(5) 百度一下 Markdown用法 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 0x05-参考资料Linux下Proc文件系统的编程剖析_郭松http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFD2010&amp;filename=HQDB201005010&amp;uid=WEEvREcwSlJHSldRa1FhcTdWajFtZk1DY3hvZmUvYk10TGtFRmcwaDkyTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjA1NzN5RGxVN3pJTFR6UGJMRzRIOUhNcW85RVpJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTEtmWWVSb0Y=","categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://yoursite.com/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"简单的linux设备驱动程序","slug":"简单的linux设备驱动程序","date":"2018-06-17T16:00:00.000Z","updated":"2018-08-11T05:52:40.000Z","comments":true,"path":"简单的linux设备驱动程序/","link":"","permalink":"http://yoursite.com/简单的linux设备驱动程序/","excerpt":"","text":"简单的linux设备驱动程序","categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://yoursite.com/tags/Kernel/"}],"keywords":[]},{"title":"Hexo主题修改","slug":"hexo主题修改","date":"2018-05-29T11:48:21.000Z","updated":"2018-06-04T22:23:56.000Z","comments":true,"path":"hexo主题修改/","link":"","permalink":"http://yoursite.com/hexo主题修改/","excerpt":"","text":"https://blog.csdn.net/com_ma/article/details/76039859","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"keywords":[]},{"title":"内存管理之伙伴算法","slug":"伙伴算法","date":"2018-05-29T11:48:21.000Z","updated":"2018-06-04T22:22:42.000Z","comments":true,"path":"伙伴算法/","link":"","permalink":"http://yoursite.com/伙伴算法/","excerpt":"","text":"Buddy算法的优缺点：1）尽管伙伴内存算法在内存碎片问题上已经做的相当出色，但是该算法中，一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。 2）算法中有一定的浪费现象，伙伴算法是按2的幂次方大小进行分配内存块，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。比如原来是1024个块，申请了16个块，再申请600个块就申请不到了，因为已经被分割了。 3）另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。 Buddy（伙伴的定义）：这里给出伙伴的概念，满足以下三个条件的称为伙伴：1）两个块大小相同；2）两个块地址连续；3）两个块必须是同一个大块中分离出来的； Buddy算法的分配原理：假如系统需要4(22)个页面大小的内存块，该算法就到free_area[2]中查找，如果链表中有空闲块，就直接从中摘下并分配出去。如果没有，算法将顺着数组向上查找free_area[3],如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去，free_area[3]中也没有，就再向上查找，如果free_area[4]中有，就将这16(2222)个页面等分成两份，前一半挂如free_area[3]的链表头部，后一半的8个页等分成两等分，前一半挂free_area[2]的链表中，后一半分配出去。假如free_area[4]也没有，则重复上面的过程，知道到达free_area数组的最后，如果还没有则放弃分配。 Buddy算法的释放原理：内存的释放是分配的逆过程，也可以看作是伙伴的合并过程。当释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块(222222222个页面)。 整个过程中，位图扮演了重要的角色，如图2所示，位图的某一位对应两个互为伙伴的块，为1表示其中一块已经分配出去了，为0表示两块都空闲。伙伴中无论是分配还是释放都只是相对的位图进行异或操作。分配内存时对位图的是为释放过程服务，释放过程根据位图判断伙伴是否存在，如果对相应位的异或操作得1，则没有伙伴可以合并，如果异或操作得0，就进行合并，并且继续按这种方式合并伙伴，直到不能合并为止。 代码实现：心得体会 #：参考资料：Github：https://github.com/hurley25/hurlex-II/blob/master/mm/buddy_mm.c","categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://yoursite.com/tags/Kernel/"}],"keywords":[]},{"title":"实验-内存管理(FF、BF、WF)","slug":"实验-内存管理","date":"2018-05-28T01:48:11.000Z","updated":"2018-06-04T22:11:46.000Z","comments":true,"path":"实验-内存管理/","link":"","permalink":"http://yoursite.com/实验-内存管理/","excerpt":"","text":"一. 实验目的及实验环境(一)、实验环境硬件处理器：i7；内存：8G；显示器：VGA 或更高；硬盘空间：128G。 软件Centos 7下gcc编译器、gdb调试工具。 (二)、实验目的 掌握内存分配FF，BF，WF策略及实现的思路； 掌握内存回收过程及实现思路； 参考本程序思路，实现内存的申请、释放的管理程序，调试运行，总结程序设计中出现的问题并找出原因。二、实验内容 补充完整FF，BF，WF等算法的代码； 掌握内存回收过程及实现思路； 实现内存的申请和释放。三．方案设计(一)、实现功能 Set memory size (default=1024) Select memory allocation algorithm New process Terminate a process Display memory usage Exit(二)、关键算法思想设计与分析首次适应算法（First Fit）从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 最佳适应算法（Best Fit）它从全部空闲区中找出能满足作业要求的、 且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分 区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到 第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的 空闲区。 最差适应算法（Worst Fit）它从全部空闲区中找出能满足作业要求的、 且大小最大的空闲分区，从而使链表中的结点大小趋于均匀，适用于请求分 配的内存大小范围较窄的系统。为适应此算法，空闲分区表（空闲区链）中 的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留小的空闲区，尽量减少小的碎片产生。 四．测试数据及运行结果 设置内存大小 选择算法 创建进程 选择杀死进程 查看内存以及进程退出程序并释放内存空间五．总结这次实验刚开始的时候不知道整个实验的思路，还好老师在课堂上大概讲解了一下，并且给出了大部分代码，剩下的工作就是填写部分代码，这样实验就简单多了。通过本次的内存实验我了解到了内存的管理模型的知识，在内存紧缩合并回收部分还遇到了一些问题，最终通过查资料解决了问题，虽然对内存的管理掌握得不是很熟练，但这激励了我下来后看书，努力学习不懂的知识，通过让我对其有了更加深入的了解，让我认识到了，操作系统是一项真正实用，而且很有意义的学科，增加了我对操作系统的兴趣，也为以后的学习打下理论基础。 六. 源代码#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;unistd.h&gt; #include&lt;stdlib.h&gt; #define PROCESS_NAME_LEN 32 //进程名长度 #define MIN_SLICE10 //最小碎片的大小 #define DEFAULT_MEM_SIZE 1024//内存大小 #define DEFAULT_MEM_START 0 //起始位置 /*内存分配算法*/ #define MA_FF 1 #define MA_BF 2 #define MA_WF 3 /*描述每一个空闲块的数据结构*/ struct free_block_type { int size;//空闲块大小 int start_addr;//空闲块起始地址 struct free_block_type *next;//指向下一个空闲块 }; /*指向内存中空闲块链表的首指针*/ struct free_block_type *free_block = NULL; /*每个进程分配到的内存块的描述*/ struct allocated_block { int pid;//进程标识符 int size;//进程大小 int start_addr;//进程分配到的内存块的起始地址 char process_name[PROCESS_NAME_LEN];//进程名 struct allocated_block *next;//指向下一个进程控制块 }; /*进程分配内存块链表的首指针*/ struct allocated_block *allocated_block_head = NULL; int free_block_count = 0;//空闲块个数 int mem_size = DEFAULT_MEM_SIZE; //内存大小 int current_free_mem_size = 0;//当前空闲内存大小 int ma_algorithm = MA_FF; //当前分配算法 static int pid = 0; //初始PID int flag = 0;//设置内存大小标志,表示内存大小是否设置 /*函数声明*/ struct free_block_type* init_free_block(int mem_size); void display_menu(); int set_mem_size(); void set_algorithm(); void rearrange(int algorithm); int rearrange_WF(); int rearrange_BF(); int rearrange_FF(); int new_process(); int allocate_mem(struct allocated_block *ab); void kill_process(); int free_mem(struct allocated_block *ab); int dispose(struct allocated_block *free_ab); int display_mem_usage(); struct allocated_block *find_process(int pid); int do_exit(); int allocate_FF(struct allocated_block *ab); int allocate_BF(struct allocated_block *ab); int allocate_WF(struct allocated_block *ab); int allocate(struct free_block_type *pre, struct free_block_type *allocate_free_nlock, struct allocated_block *ab); int mem_retrench(struct allocated_block *ab); // 通过内存紧缩技术给新进程分配内存空间 int mem_retrench(struct allocated_block *ab) { struct allocated_block *allocated_work, *allocated_pre = allocated_block_head; struct free_block_type *free_work, *free_pre = free_block-&gt;next; if(allocated_pre == NULL) return -1; allocated_pre-&gt;start_addr = 0; allocated_work = allocated_pre-&gt;next; while(allocated_work != NULL) { allocated_work-&gt;start_addr = allocated_pre-&gt;start_addr + allocated_pre-&gt;size; allocated_pre = allocated_work; allocated_work = allocated_work-&gt;next; } free_block-&gt;start_addr = allocated_pre-&gt;start_addr + allocated_pre-&gt;size; free_block-&gt;size = current_free_mem_size; free_block-&gt;next = NULL; free_work = free_pre; while(free_pre != NULL) { free(free_pre); free_pre = free_work; if(free_pre != NULL) free_work = free_work-&gt;next; } allocate(NULL, free_block, ab); return 1; } // 给新进程分配内存空间 int allocate(struct free_block_type *pre, struct free_block_type *allocate_free_block, struct allocated_block *ab) { struct allocated_block *p = allocated_block_head; ab-&gt;start_addr = allocate_free_block-&gt;start_addr; if(allocate_free_block-&gt;size - ab-&gt;size &lt; MIN_SLICE) { ab-&gt;size = allocate_free_block-&gt;size; if(pre != NULL) { pre-&gt;next = allocate_free_block; } else { free_block = allocate_free_block-&gt;next; } free(allocate_free_block); } else { allocate_free_block-&gt;start_addr += ab-&gt;size; allocate_free_block-&gt;size -= ab-&gt;size; } if(p == NULL) { allocated_block_head = ab; } else { while(p-&gt;next != NULL) p = p-&gt;next; p-&gt;next = ab; } current_free_mem_size -= ab-&gt;size; if(current_free_mem_size == 0) free_block = NULL; return 0; } //按照最坏适应算法给新进程分配内存空间 int allocate_WF(struct allocated_block *ab) { int ret; struct free_block_type *wf = free_block; if(wf == NULL) return -1; if(wf-&gt;size &gt;= ab-&gt;size) allocate(NULL, wf, ab); else if(current_free_mem_size &gt;= ab-&gt;size) ret = mem_retrench(ab); else ret = -2; rearrange_WF(); return ret; } // 按照最佳适应算法给新进程分配内存空间 int allocate_BF(struct allocated_block *ab) { int ret; struct free_block_type *pre = NULL, *bf = free_block; if(bf == NULL) return -1; while(bf != NULL) { if(bf-&gt;size &gt;= ab-&gt;size) { ret = allocate(pre, bf,ab); break; } pre = bf; pre = pre-&gt;next; } if(bf == NULL &amp;&amp; current_free_mem_size &gt; ab-&gt;size) ret = mem_retrench(ab); else ret = -2; rearrange_BF(); return ret; } // 按照首次适应算法给新进程分配内存空间 int allocate_FF(struct allocated_block *ab) { int ret; struct free_block_type *pre = NULL, *ff = free_block; if(ff == NULL) return -1; while(ff != NULL) { if(ff-&gt;size &gt;= ab-&gt;size) { ret = allocate(pre, ff,ab); break; } pre = ff; pre = pre-&gt;next; } if(ff == NULL &amp;&amp; current_free_mem_size &gt; ab-&gt;size) ret = mem_retrench(ab); else ret = -2; rearrange_FF(); return ret; } //分配内存模块 int allocate_mem(struct allocated_block *ab) { int ret ; struct free_block_type *fbt, *pre; int request_size = ab-&gt;size; fbt = pre = free_block; switch(ma_algorithm) { case MA_FF : ret = allocate_FF(ab); break; case MA_BF : ret = allocate_BF(ab); break; case MA_WF : ret = allocate_WF(ab); break; default : break; } return ret; } // 创建一个新的进程。 int new_process() { struct allocated_block *ab; int size; int ret; ab = (struct allocated_block *)malloc(sizeof(struct allocated_block)); if(!ab) exit(-5); ab-&gt;next = NULL; pid++; sprintf(ab-&gt;process_name, &quot;PROCESS-%02d&quot;, pid);//sprintf()函数将格式化的数据写入某字符串中 ab-&gt;pid = pid; printf(&quot;Memory for %s:&quot;, ab-&gt;process_name); for(; ; ) { scanf(&quot;%d&quot;, &amp;size); getchar(); if(size &gt; 0) { ab-&gt;size = size; break; } else printf(&quot;The size have to greater than zero! Please input again!&quot;); } ret = allocate_mem(ab); //从空闲区分配内存，ret==1表示分配ok if((ret == 1) &amp;&amp; (allocated_block_head == NULL))//如果此时allocated_block_head尚未赋值，则赋值 { //进程分配链表为空 allocated_block_head = ab; return 1; } else if(ret == 1) //分配成功，将该已分配块的描述插入已分配链表 { ab-&gt;next = allocated_block_head;//头插法 allocated_block_head = ab; return 2; } else if(ret == -1) //分配不成功 { printf(&quot;Allocation fail\\n&quot;); free(ab); return -1; } return 3; } //退出程序并释放内存空间。 int do_exit() { struct allocated_block *allocated_ab, *allocated_pre; struct free_block_type *free_ab, *free_pre; free_pre = free_block; allocated_pre = allocated_block_head; if(free_pre != NULL) { free_ab = free_pre-&gt;next; while(free_ab != NULL) { free(free_pre); free_pre = free_ab; free_ab = free_ab-&gt;next; } } if(allocated_pre != NULL) { allocated_ab = allocated_pre-&gt;next; while(allocated_ab != NULL) { free(allocated_pre); allocated_pre = allocated_ab; allocated_ab = allocated_ab-&gt;next; } } allocated_ab = allocated_ab-&gt;next; return 0; } //在进程分配链表中寻找指定进程。 struct allocated_block *find_process(int pid) { struct allocated_block *ab = allocated_block_head; if(ab == NULL) { printf(&quot;Here??????111111111\\n&quot;); return NULL; } while(ab-&gt;pid != pid &amp;&amp; ab-&gt;next != NULL) ab = ab-&gt;next; if(ab-&gt;next == NULL &amp;&amp; ab-&gt;pid != pid) { printf(&quot;Here??????2222222\\n&quot;); return NULL; } return ab; } //显示当前内存的使用情况，包括空闲区的情况和已经分配的情况。 int display_mem_usage() { struct free_block_type *fbt = free_block; struct allocated_block *ab = allocated_block_head; printf(&quot;----------------------------------------------------------\\n&quot;); //显示空闲区 printf(&quot;Free Memory:\\n&quot;); printf(&quot;%20s %20s\\n&quot;, &quot; start_addr&quot;, &quot; size&quot;); while(fbt != NULL) { printf(&quot;%20d %20d\\n&quot;, fbt-&gt;start_addr, fbt-&gt;size); fbt = fbt-&gt;next; } //显示已分配区 printf(&quot;\\nUsed Memory:\\n&quot;); printf(&quot;%10s %20s %10s %10s\\n&quot;, &quot;PID&quot;, &quot;ProcessName&quot;, &quot;start_addr&quot;, &quot; size&quot;); while(ab != NULL) { printf(&quot;%10d %20s %10d %10d\\n&quot;, ab-&gt;pid, ab-&gt;process_name, ab-&gt;start_addr, ab-&gt;size); ab = ab-&gt;next; } printf(&quot;----------------------------------------------------------\\n&quot;); return 1; } // 释放ab数据结构节点。 int dispose(struct allocated_block *free_ab) { struct allocated_block *pre, *ab; if(free_block == NULL) return -1; if(free_ab == allocated_block_head)//如果要释放第一个节点 { allocated_block_head = allocated_block_head-&gt;next; free(free_ab); } else { pre = allocated_block_head; ab = allocated_block_head-&gt;next; //找到free_ab while(ab != free_ab) { pre = ab; ab = ab-&gt;next; } pre-&gt;next = ab-&gt;next; free(ab); } return 1; } /*将ab所表示的已分配区归还，并进行可能的合并*/ int free_mem(struct allocated_block *ab) { int algorithm = ma_algorithm; struct free_block_type *fbt, *pre, *work; fbt = (struct free_block_type*)malloc(sizeof(struct free_block_type)); if(!fbt) return -1; pre = free_block; fbt-&gt;start_addr = ab-&gt;start_addr; fbt-&gt;size = ab-&gt;size; fbt-&gt;next = NULL; if(pre != NULL) { while(pre-&gt;next != NULL) pre = pre-&gt;next; pre-&gt;next = fbt; } else { free_block = fbt; } rearrange_FF(); pre = free_block; work = pre-&gt;next; while(work != NULL) { if(pre-&gt;start_addr + pre-&gt;size == work-&gt;start_addr) { pre-&gt;size += work-&gt;size; free(work); work = pre-&gt;next; } else { pre = work; work = work-&gt;next; } } current_free_mem_size += ab-&gt;size; return 1; } // 删除进程，归还分配的存储空间，并删除描述该进程内存分配的节点。 void kill_process() { struct allocated_block *ab; int pid; printf(&quot;Kill Process, pid=&quot;); scanf(&quot;%d&quot;, &amp;pid); getchar(); ab = find_process(pid); if(ab != NULL) { free_mem(ab); /*释放ab所表示的分配区*/ dispose(ab); /*释放ab数据结构节点*/ } } //按FF算法重新整理内存空闲块链表,按空闲块首地址排序。 int rearrange_FF() { struct free_block_type *head = free_block; struct free_block_type *forehand, *pre, *rear; int i; if(head == NULL) return -1; //冒泡排序 for(i = 0; i &lt; free_block_count-1; i++) { forehand = head; pre = forehand-&gt;next; rear = pre-&gt;next; while(pre-&gt;next != NULL) { if(forehand == head &amp;&amp; forehand-&gt;start_addr &gt;= pre-&gt;start_addr)//比较空闲链表中第一个空闲块与第二个空闲块的开始地址的大小 { head-&gt;next = pre-&gt;next; pre-&gt;next = head; head = pre; forehand = head-&gt;next; pre = forehand-&gt;next; rear = pre-&gt;next; } else if(pre-&gt;start_addr &gt;= rear-&gt;start_addr)//比较链表中其他相邻两节点的开始地址的大小 { pre-&gt;next = rear-&gt;next; forehand-&gt;next = rear; rear-&gt;next = pre; forehand = rear; rear = pre-&gt;next; } else { forehand = pre; pre = rear; rear = rear-&gt;next; } } } return 0; } // 按BF算法重新整理内存空闲块链表,按空闲块大小从小到大排序。 int rearrange_BF() { struct free_block_type *head = free_block; struct free_block_type *forehand, *pre, *rear; int i; if(head == NULL) return -1; //冒泡排序 for(i = 0; i &lt; free_block_count-1; i++) { forehand = head; pre = forehand-&gt;next; rear = pre-&gt;next; while(pre-&gt;next != NULL) { if(forehand == head &amp;&amp; forehand-&gt;size &lt;= pre-&gt;size)//比较空闲链表中第一个空闲块与第二个空闲块的空间的大小 { head-&gt;next = pre-&gt;next; pre-&gt;next = head; head = pre; forehand = head-&gt;next; pre = forehand-&gt;next; rear = pre-&gt;next; } else if(pre-&gt;size &lt;= rear-&gt;size)//比较链表中其他相邻两节点的空间的大小 { pre-&gt;next = rear-&gt;next; forehand-&gt;next = rear; rear-&gt;next = pre; forehand = rear; rear = pre-&gt;next; } else { forehand = pre; pre = rear; rear = rear-&gt;next; } } } return 0; } //按WF算法重新整理内存空闲块链表,按空闲块大小从大到小排序。 int rearrange_WF() { struct free_block_type *head = free_block; struct free_block_type *forehand, *pre, *rear; int i; if(head == NULL) return -1; //冒泡排序 for(i = 0; i &lt; free_block_count-1; i++) { forehand = head; pre = forehand-&gt;next; rear = pre-&gt;next; while(pre-&gt;next != NULL) { if(forehand == head &amp;&amp; forehand-&gt;size &gt;= pre-&gt;size)//比较空闲链表中第一个空闲块与第二个空闲块空间的大小 { head-&gt;next = pre-&gt;next; pre-&gt;next = head; head = pre; forehand = head-&gt;next; pre = forehand-&gt;next; rear = pre-&gt;next; } else if(pre-&gt;size &gt;= rear-&gt;size)//比较链表中其他相邻两节点的空间的大小 { pre-&gt;next = rear-&gt;next; forehand-&gt;next = rear; rear-&gt;next = pre; forehand = rear; rear = pre-&gt;next; } else { forehand = pre; pre = rear; rear = rear-&gt;next; } } } return 0; } //按指定的算法整理内存空闲块链表。 void rearrange(int algorithm) { switch(algorithm) { case MA_FF: rearrange_FF(); break; case MA_BF: rearrange_BF(); break; case MA_WF: rearrange_WF(); break; } } //设置当前的分配算法 void set_algorithm() { int algorithm; //system(&quot;clear&quot;); printf(&quot;\\t1 - First Fit\\n&quot;);//首次适应算法 printf(&quot;\\t2 - Best Fit \\n&quot;);//最佳适应算法 printf(&quot;\\t3 - Worst Fit \\n&quot;);//最坏适应算法 printf(&quot;\\nPlease choose(1~3):&quot;); for(; ; ) { scanf(&quot;%d&quot;, &amp;algorithm); getchar(); if(algorithm &gt;= 1 &amp;&amp; algorithm &lt;= 3) { ma_algorithm = algorithm; break; } else { printf(&quot;\\nCannot input %d, Please input 1~3 : &quot;, algorithm); } } //按指定算法重新排列空闲区链表 rearrange(ma_algorithm); } //设置内存的大小 int set_mem_size() { int size; if(flag != 0)//防止重复设置 { printf(&quot;Cannot set memory size again\\n&quot;); return 0; } printf(&quot;Total memory size = &quot;); for(; ; ) { scanf(&quot;%d&quot;, &amp;size); getchar(); if(size &gt; 0) { current_free_mem_size = size; mem_size = size;//设置内存大小为size free_block-&gt;size = mem_size;//设置空闲块大小为size break; } else { printf(&quot;The size must greater than zero! Please input again:&quot;); } } flag = 1;//内存大小已经设置 return 1; } //显示主菜单 void display_menu() { printf(&quot;\\n&quot;); //system(&quot;clear&quot;); printf(&quot;1 - Set memory size (default=%d)\\n&quot;, DEFAULT_MEM_SIZE); printf(&quot;2 - Select memory allocation algorithm\\n&quot;); printf(&quot;3 - New process \\n&quot;); printf(&quot;4 - Terminate a process \\n&quot;); printf(&quot;5 - Display memory usage \\n&quot;); printf(&quot;0 - Exit\\n&quot;); } // 初始化空闲块，默认为一块，可以指定大小及起始地址 struct free_block_type* init_free_block(int mem_size) { struct free_block_type *fb; fb = (struct free_block_type *)malloc(sizeof(struct free_block_type)); if(fb == NULL)//初始化失败 { printf(&quot;No mem\\n&quot;); return NULL; } current_free_mem_size = mem_size; fb-&gt;size = mem_size;//设置空闲块大小 fb-&gt;start_addr = DEFAULT_MEM_START;//空闲块起始地址 fb-&gt;next = NULL;//首地址指向NULL return fb; } /*主函数*/ int main(void) { char choice; pid = 0; free_block = init_free_block(mem_size); //初始化空闲区 while(1) { display_menu();//显示菜单 fflush(stdin); choice = getchar();//获取用户输入 getchar(); switch(choice) { case &apos;1&apos;: //设置内存大小 set_mem_size(); break; case &apos;2&apos;: //设置算法 set_algorithm(); flag = 1; break; case &apos;3&apos;: //创建新进程 new_process(); flag = 1; break; case &apos;4&apos;://删除进程 kill_process(); flag = 1; break; case &apos;5&apos;://显示内存使用 display_mem_usage(); flag = 1; break; case &apos;0&apos;: //释放链表并退出 do_exit(); exit(0); default: break; } } } 七、改进 内存整理： 删除空闲内存，重新过一遍算法","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}],"keywords":[]},{"title":"面试-操作系统","slug":"面试-操作系统","date":"2018-05-23T07:38:44.000Z","updated":"2018-06-04T22:18:16.000Z","comments":true,"path":"面试-操作系统/","link":"","permalink":"http://yoursite.com/面试-操作系统/","excerpt":"","text":"1.请问下面的程序一共输出多少个“-”？#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { int i; for(i=0;i&lt;2;i++){ fork(); printf(&quot;-&quot;); } wait(NULL); wait(NULL); return 0; } 输出：8个“-” 若：\\n#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { int i; for(i=0;i&lt;2;i++){ fork(); printf(&quot;-\\n&quot;); } wait(NULL); wait(NULL); return 0; } 输出：6个“-” 若：fflush(stdout);#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { int i; for(i=0;i&lt;2;i++){ fork(); printf(&quot;-&quot;); fflush(stdout); } wait(NULL); wait(NULL); return 0; } 输出：6个“-” 若：EOF#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; int main() { int i; int c; for(i=0;i&lt;2;i++){ fork(); printf(&quot;-&quot;); c=getchar(); } wait(NULL); wait(NULL); return 0; } 输出：6个“-” 为什么？- //产生两个进程 i=0 - - //2个 i=1 - - - - //4个 总结 因为printf（“-”）语句有buffer，把“-”放在了缓存中，并没有真正的输出，在fork的时候，缓存被复制了子进程空间，就成了8个。 Unix下的设备有“块设备”，就是以一块一块的数据存取的设备，如磁盘和内存；“字符设备”是一个存取一个字符设备，如键盘和串口。块设备一般都有缓存，而字符设备一般没有缓存。 遇到“\\n”、主动flush、EOF、缓存区满、文件描述符关闭、程序退出，等就会把数据刷出缓存区 2.在物理内存为1G的计算机中能否malloc(1.2G)？问题：不同平台上去测试malloc()最多能分配多大内存空间时，为什么结果有时不同？ 测试：Linux环境下：Windows环境：结论代码：#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned maximum=1024*1024*1024; int main(int argc, char *argv[]) { unsigned blocksize[]={1024*1024,1024,1}; int i,count; void *block; for(i=0;i&lt;sizeof(blocksize)/sizeof(unsigned);i++) { for(count=1; ;count++) { block=malloc(maximum+blocksize[i]*count); if(block!=NULL) { maximum=maximum+blocksize[i]*count; free(block); } else { break; } } } /*printf(&quot;maximummalloc size=%u bytes\\n&quot;,maximum);*/ printf(&quot;2&quot;); return 0; }","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}],"keywords":[]},{"title":"FAQ","slug":"FAQ","date":"2018-05-02T16:00:00.000Z","updated":"2018-08-11T05:11:00.000Z","comments":true,"path":"FAQ/","link":"","permalink":"http://yoursite.com/FAQ/","excerpt":"","text":"Q1:浏览器报Uncaught ReferenceError: require is not definedA1:这个时候你需要看下你是不是在浏览器中运行node.js的模块了.不要把node.js和js搞混了,两个的运行环境是不相同.所以,你再浏览器环境下使用node.js的方法显示的not defined.Q2:Ajax A2:服务端渲染随着单页面应用以及Restful接口的兴起，Ajax逐渐成为目前前后端交流最为频繁的方式。 Ajax的核心是XmlHttpRequest。我们通过对该对象的操作来进行异步的数据请求。 实际上我们接触到最多jQuey就有很好的封装，比如$.ajax，$.post等，如果用Angular的话我们可以用$http服务， 除了这些之外，我们可以使用第三方的Ajax库qwest等。","categories":[],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://yoursite.com/tags/FAQ/"}],"keywords":[]},{"title":"实验-进程管理(线程、进程、互斥与死锁)","slug":"实验-进程管理","date":"2018-04-28T01:48:11.000Z","updated":"2018-06-04T22:10:42.000Z","comments":true,"path":"实验-进程管理/","link":"","permalink":"http://yoursite.com/实验-进程管理/","excerpt":"","text":"一. 实验目的及实验环境实验环境硬件处理器：i7；内存：8G；显示器：VGA 或更高；硬盘空间：128G。 软件Centos 7下gcc编译器、gdb调试工具。 实验目的进程通过观察、分析实验现象，深入理解多进程并发执行的过程、fork函数在创建子进程时对内存的操作；加深对进程概念的理解，明确进程和程序的区别；进一步认识并发执行的实质；分析进程争用资源的现象，学习解决进程互斥的方；了解Linux系统中进程通信的基本原理。 线程理解多线程的概念，学会Linux编程中的线程的创建与终止。理解多线程并发工作时对资源的抢占，通过本实验掌握在Linux操作系统中遵循Posix线程标准接口进行多线程程序编程，熟练掌握线程的创建pthread_create()。 互斥与死锁理解死锁的产生原因与Linux编程中对临界资源进行加锁使得多进程或多线程对临界资源进行互斥访问。 利用信号量或者互斥锁实现线程间的同步。 二、实验内容进程1、你最初认为运行结果会怎么样？ 答：会持续输出0-9号进程，直到输入数字键+回车，则会杀死该进程，接下来的输出将不会有该进程号，当输入q+回车，则退出程序。 2、实际的结果什么样？有什么特点？试对产生该现象的原因进行分析。 答：实际的结果与预期差不多。因输入进程总数3小于设定的最大进程数，因此按进程数3来处理。随机输出0-2号进程，sleep(SLEEP_INTERVAL)，循环输出，输入数字键，则会杀死该数字对应的进程，直到输入q退出循环，然后kill杀死本组所有进程。分析：每创建一个子进程时，将其pid存储在pid[i]中，i存储在proc_number，然后调用死循环函数do_something()，输出该进程的代号proc_number；当输入数字键时，主进程会执行kill(pid[ch-‘0’],SIGTERM)，从而杀死（ch-‘0’）号进程。当输入q时循环退出，kill(0,SIGTERM)，杀死本组所有进程，程序退出。 3、proc_number 这个全局变量在各个子进程里的值相同吗？为什么？ 答：相同，因为子进程相互独立，资源互不影响。 4、kill 命令在程序中使用了几次？每次的作用是什么？执行后的现象是什么？ 答：kill命令在程序中使用了2次：kill(pid[ch-‘0’],SIGTERM)和kill(0,SIGTERM);第一次是杀死该进程号pid[ch-‘0’]，执行后接下来的结果中不会有该进程号，就会使该子进程真正结束。第二次是杀死本组所有进程。即主进程以及它创建的所有子进程。执行后程序退出，进程结束。 5、使用kill 命令可以在进程的外部杀死进程。进程怎样能主动退出？这两种退出方式哪种更好一些？ 答：进程在main函数中return，或调用exit()函数都可以正常退出。 而使用kill命令则是异常退出。 当然是正常退出比较好，若在子进程退出前使用kill命令杀死其父进程，则系统会让init进程接管子进程。当用kill命令使得子进程先于父进程退出时，而父进程又没有调用wait函数等待子进程结束，子进程处于僵死状态，并且会一直保持下去，直到系统重启。子进程处于僵死状态时，内核只保存该进程的必要信息以被父进程所需，此时子进程始终占着资源，同时减少了系统可以创建的最大进程数。 6、在do_something()输出pro_number的地址，把do_something里的死循环改成10次，问实际创建的子进程个数有什么变化？ 答：pro_number的地址不变，当把死循环改成10次后，子进程个数只有10个，并且杀死后的进程还是会重新输出。 线程1、你最初认为前三列数会相等吗？最后一列斜杠两边的数字是相等，还是大于或者小于关系？ 答：我认为前三列数不会相等，因为线程之间在抢占cpu资源，三个线程运行次数是随机的，最后一列的数字左边等于右边。 2、最后的结果如你所料吗？有什么特点？试对原因进行分析。 答：最后的结果不是我所预料的，最后斜杠两边的数字时一样的，原因在与我在程序中添加了信号量。 3、thread 的CPU 占用率是多少？为什么会这样？答：在我的电脑上cpu占用率147%,一个方面是线程执行的都是无限循环的代码，另一方面是线程之间抢占资源很激烈。 4、thread_worker()内是死循环，它是怎么退出的？你认为这样退出好吗？ 答：thread_worker()函数内是死循环，退出时因为主函数中设置的输入q时循环退出。整个进程的终止导致了所有线程的结束，这样结束线程不好，因为如果线程使用临界资源的时候没有释放就结束了，那么这个临界资源就会被认为是被已经退出的线程占用着，从而得不到释放。 互斥与死锁1、你预想deadlock.c 的运行结果会如何？ 答：运行结果可能会发生中止现象，我认为thread1和thread2会相互争抢资源，有一定的概率发生死锁，因为他们的运行顺序是抢占式的。 2、deadlock.c 的实际运行结果如何？多次运行每次的现象都一样吗？为什么会这样？ 答：实际的运行结果是：开始几次运行正常，但是经过多次的运行之后，其中一次会让程序卡死，无法再执行。这是因为thread1锁定了资源1，thread2锁定了资源2，两个线程又同时需要对方的资源，这样导致了死锁。 三．方案设计进程利用fork( )函数创建进程，并将每个进程的进程号保存在主进程中保存进程号的数组。每个进程输出自己是第几个进程与自己的进程号。当用户输入’q’时，主进程向每个进程发送终止信号，杀死所有进程；学习fork与kill的用法，补全程序代码，调试运行，观察并 分析实验结果。 线程主进程创建三个线程并发工作。这三个线程都对main_counter进程修改(没执行一次循环将main_counter加1)，也将属于自己线程的变量counter[i]加1，最后比较三个线程counter值之和与main_counter的大小。补全程序代码，调试运行，观察并 分析实验结果。 互斥与死锁准备好上节实验3完成的程序。阅读参考资料，了解互斥锁的加锁机制 及相关的系统调用。找到实验3程序的代码临界区，用临界区解决 main_counter 与sum 不同步的问题。对main_counter与sum加锁实现三个线程的互斥访问。 四．测试数据及运行结果进程：线程：互斥与死锁：五．总结在本次实验中，我学会了创建进程和杀死进程，创建线程和杀死线程，线程的种类，和线程创建及管理机制并且了解了线程互斥锁的类型。重新理解了互斥与同步的概念以及死锁及其相关内容。更进一步认识死锁的发生条件和预防死锁发生的方法。死锁发生的条件有互斥条件，占有且等待条件，不可抢占条件等。我们只要破坏死锁发生条件之一我们就可以预防死锁的发生！本实验采用破坏占有且等待条件预防死锁发生！处理及调度的算法有一定的难度，因为其理论上的难度，但是通过学习让我对其有了更加深入的了解，让我认识到了，操作系统是一项真正实用，而且很有意义的学科，增加了我对操作系统的兴趣，也为以后的学习打下理论基础。 六、源代码进程#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; #include&lt;signal.h&gt; #include&lt;ctype.h&gt; #define MAX_CHILD_NUMBER 10 #define SLEEP_INTERVAL 2 int proc_number=0; void do_something(); main(int argc,char* argv[]) { int child_proc_number=MAX_CHILD_NUMBER; int i; char ch; pid_t child_pid; pid_t pid[10]={0};/*存放每个子进程的id*/ if(argc&gt;1) { child_proc_number=atoi(argv[1]); child_proc_number=(child_proc_number&gt;10)?10:child_proc_number; } for(i=0;i&lt;child_proc_number;i++) { child_pid=fork(); if(child_pid==-1) { perror(&quot;fork&quot;); } else if(child_pid==0) { proc_number=i; do_something(); } else pid[i]=child_pid; } /*用户选择杀死进程，数字表示杀死该进程,q表示退出*/ printf(&quot;请输入要杀死进程的编号(q退出):\\n&quot;); while((ch=getchar())!=&apos;q&apos;) { if(isdigit(ch)) { kill(pid[ch-&apos;0&apos;],SIGTERM); } } /*杀死本组的所有进程*/ for(i=0;i&lt;=proc_number;i++) { kill(pid[i],SIGTERM); } kill(0,SIGTERM); return; } void do_something() { for(;;) { printf(&quot;This is process No.%d and its pid is %d\\n&quot;,proc_number,getpid()); sleep(SLEEP_INTERVAL); } } 线程#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;ctype.h&gt; #include &lt;pthread.h&gt; #include&lt;semaphore.h&gt; #define MAX_THREAD 3 /* 线程的个数 */ unsigned long long main_counter, counter[MAX_THREAD]; /* unsigned long long是比long还长的整数 */ sem_t S1,S2; void* thread_worker(void*); void *thread_worker(void *p){ int thread_num; thread_num=(int)p; for(;;){ sem_wait(&amp;S1); sem_wait(&amp;S2); counter[thread_num]++;/* 本线程的counter加一 */ main_counter++;/* 主counter 加一 */ sem_post(&amp;S2); sem_post(&amp;S1); } } int main(int argc,char *argv[]) { int i,rtn,ch; pthread_t pthread_id[MAX_THREAD]={0}; sem_init(&amp;S1,0,1); sem_init(&amp;S2,0,1); for(i=0;i&lt;MAX_THREAD;i++) { rtn=pthread_create(&amp;pthread_id[i],NULL,thread_worker,(void*)i); } do { unsigned long long sum=0; sem_wait(&amp;S1); sem_wait(&amp;S2); for(i=0;i&lt;MAX_THREAD;i++){/* 求所有counter的和 */ sum+=counter[i]; printf(&quot;第%d个counter的值是%llu\\n&quot;,i+1,counter[i]); } printf(&quot;main_counter的值:%llu sum的值%llu\\n&quot;,main_counter,sum); sem_post(&amp;S2); sem_post(&amp;S1); }while((ch=getchar())!=&apos;q&apos;); return 0; } 互斥锁#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; # include &lt;ctype.h&gt; #include &lt;pthread.h&gt; #define LOOP_TIMES 10000 pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER; void* thread_worker(void*); void critical_section(int thread_num, int i); void *thread_worker(void *p) { int i; for(i=0;i&lt;LOOP_TIMES;i++) { //对互斥锁上锁 pthread_mutex_lock(&amp;mutex1); pthread_mutex_lock(&amp;mutex2); critical_section(2,i); //对互斥锁解锁 pthread_mutex_unlock(&amp;mutex2); pthread_mutex_unlock(&amp;mutex1); } } void critical_section(int thread_num,int i) { printf(&quot;Thread%d:%d\\n&quot;,thread_num,i); } int main() { int rtn,i; pthread_t pthread_id=0; rtn=pthread_create(&amp;pthread_id,NULL,thread_worker,NULL); if(rtn!=0) { printf(&quot;pthread_create ERROR!\\n&quot;); return -1; } for(i=0;i&lt;LOOP_TIMES;i++) { pthread_mutex_lock(&amp;mutex1); pthread_mutex_lock(&amp;mutex2); critical_section(1,i); pthread_mutex_unlock(&amp;mutex2); pthread_mutex_unlock(&amp;mutex1); } //互斥锁销毁 pthread_mutex_destroy(&amp;mutex1); pthread_mutex_destroy(&amp;mutex2); return 0; } 信号量#include&lt;stdio.h&gt; #include&lt;sys/types.h&gt; #include&lt;ctype.h&gt; #include&lt;unistd.h&gt; #include&lt;pthread.h&gt; #include&lt;semaphore.h&gt; #define LOOP_TIMES 10000 sem_t S1,S2; void *thread_worker(void *); void critical_section(int thread_num,int i); void *thread_worker(void *p) { int i; for(i=0;i&lt;LOOP_TIMES;i++) { //信号量减一 sem_wait(&amp;S2); sem_wait(&amp;S1); critical_section(2,i); //信号量加一 sem_post(&amp;S1); sem_post(&amp;S2); } } void critical_section(int thread_num,int i) { printf(&quot;Thread%d:%d\\n&quot;,thread_num,i); } int main() { int rtn,i; sem_init(&amp;S1,0,1); sem_init(&amp;S2,0,1); pthread_t pthread_id=0; rtn=pthread_create(&amp;pthread_id,NULL,thread_worker,NULL); if(rtn!=0) { printf(&quot;pthread_create ERROR!\\n&quot;); return -1; } for(i=0;i&lt;LOOP_TIMES;i++) { sem_wait(&amp;S1); sem_wait(&amp;S2); critical_section(1,i); sem_post(&amp;S1); sem_post(&amp;S2); } //销毁信号量 sem_destroy(&amp;S1); sem_destroy(&amp;S2); return 0; } 七、改进","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}],"keywords":[]},{"title":"Kernel前辈教C小子探案  3.18-3.20","slug":"Kernel前辈教C小子探案","date":"2018-03-20T05:05:00.000Z","updated":"2018-04-15T01:20:34.000Z","comments":true,"path":"Kernel前辈教C小子探案/","link":"","permalink":"http://yoursite.com/Kernel前辈教C小子探案/","excerpt":"","text":"111与221C小子：int main(){int n=1;printf(&quot;%d %d %d\\n&quot;,n,++n,n--);}Kernel前辈，请问它怎么在不同的编译器下答案不一样Kernel前辈:C小子，你自己的答案是什么？C小子：官方答案1 1 1Kernel前辈:为什么会不一样，这很有意思。回答一下这个问题C小子：好Kernel前辈:学习Linux内核，需要具备的知识基础，非常熟练的C，数据结构，编译原理，操作系统，软件工程，计算机原理，如果要了解网络，还需要网络知识。如果没有这些基础，真的学的很痛苦，就像空中楼阁，还有汇编语言。考试与实际代码还有相当的距离的，你看过Linux的一点代码，应该有感觉的。还有shell脚本语言C小子：是的，坚持了理论有时就要放弃实践，坚持了实践就有时就要放弃理论。shell之前也写过Kernel前辈:学内核这块，必须在理论和实践之间来回转换，因为，必须拿出东西才能给自己信心C小子：是的。技术是基本功!C小子：#include &lt;stdio.h&gt;int main(){ int n=1; printf(&quot;%d %d %d\\n&quot;,n,++n,n--);} vc++ ：2 2 1Turbo C: 1 1 1 VC++环境下连续自增(自减)运算规则在一般表达式中和在函数参数中计算的结果相同;规则：1.先参考运算优先级;（++n的优先级高）2.然后再从右至左依次对每个表达式求解;（n–=1，n=1;++n=2，n=2;n=2）3.然后再从左到右输出每个表达式的值;（2 2 1 ）4.最后变量n的值再自减1次。 Turbo C环境中当自增、自减运算出现在函数参数中时，计算方法采用扫描格式决定;规则：1.Turbo C编译环境中在从右至左依次对每个表达式求解时，先得到n–的值，然后n的值减1;（n–=1，n=0）2.然后n加上1，得到++n的值;（n=0+1=1,++n=1）3.最后n为1。（n=1）C小子：Kernel前辈:（1）把这些汇编指令解释一下 （2）从编译角度说明二者这样做的理以及带来的问题 （3）在实际项目中遇到这样的问题如何解决 （4）在Linux 下运行看看结果 （5）谁遵循了标准 CC小子：好的C小子：（1）把这些汇编指令解释一下汇编代码： int n=1;00401028 mov dword ptr [ebp-4],1//将1存放到ebp-4中，ebp-4此时为1 printf(&quot;%d %d %d\\n&quot;,n,++n,n--);// 2 2 10040102F mov eax,dword ptr [ebp-4]//把ebp-4的值存放到寄存器eax中，eax此时为100401032 mov dword ptr [ebp-8],eax//将寄存器的值存放到地址为ebp-8的临时量中，此临时量ebp-8保存的值是100401035 mov ecx,dword ptr [ebp-8]//将ebp-8的值存放到寄存器ecx中，ecx此时是100401038 push ecx//将ecx的值压入栈中，100401039 mov edx,dword ptr [ebp-4]//将ebp-4的值放到edx中，edx此时为10040103C add edx,1//对寄存器edx的值进行+1操作，edx为20040103F mov dword ptr [ebp-4],edx//将寄存器edx的值重新写到ebp-4中，ebp-4此时为200401042 mov eax,dword ptr [ebp-4]//将ebp-4的值取出来放到寄存器eax中，eax为200401045 push eax//将eax的值压入栈中,1 200401046 mov ecx,dword ptr [ebp-4]//将ebp-4的值放到ecx中，ecx为200401049 push ecx////将ecx的值压入栈中， 1 2 20040104A push offset string &quot;%d&quot; (0042201c)//压入字符串参数0040104F mov edx,dword ptr [ebp-4]//将ebp-4的值放到edx中，edx 为200401052 sub edx,1//对edx寄存器进行-1操作，edx 为100401055 mov dword ptr [ebp-4],edx//将eax放到ebp-4中00401058 call printf (00401090)//开始执行printf函数 2 2 10040105D add esp,10h//释放局部变量空间 （2）从编译角度说明二者这样做的理由以及带来的问题理由：编译时不同编译器处理方法不同，在vc++中编译时，需要考虑优先级，（add edx,1）。编译角度很底层，规则不同，或许是因为更底层的一些东西限制，我再查查 问题：会出现歧义， 使得一些程序不能很好的移植，不能跨平台使用 （3）在实际项目中遇到这样的问题如何解决应避免歧义，以稳定兼容为原则，将自增自减运算用变量代替，根据要求改写,可写成：#include &lt;stdio.h&gt;int main(){ int i,j,k; int n=1; i=n; j=++n; k=n--; printf(&quot;%d %d %d\\n&quot;,n,++n,n--);} （4）在Linux 下运行看看结果1 1 1（5）谁遵循了标准 Clinux 下的编译器gcc遵循了标准 cKernel前辈:回答的不错，还有一个问题，为什么要压栈？C小子：压栈可能是为何后面便于一条输出语句可以输出多个结果吧Kernel前辈:不对C小子：那是为什么呀，从右向左的压栈，从左向右的输出，多个结果保证顺序。编译系统我不是非常了解Kernel前辈:手上要有一本深入理解计算机系统的书，查看函数的执行过程就明白了C小子：嗯嗯，我了解的深度不够Kernel前辈:不是不够，皮毛尚未触及Kernel前辈:刚才你回答问题的思路和方法是正确的C小子：Kernel前辈，虽然我用户态的程序不太了解，但不是完全不可用学内核，只要方法正确，对比着学，内核态用户态相互验证，这样更好。那到底为什么要压栈呀？Kernel前辈:这个需要你系统的去了解，不能等答案。会涉及到编译程序如何对函数进程编译处理。执行程序如何执行函数C小子：是一种约定的规则Kernel前辈:对，计算机中有很多的标准和接口C小子：会不会编译程序对函数处理 在不同的条件下也不同，就像不同的编译器那个程序结果也不同。就是说有不同的规则Kernel前辈:编译器不一样，处理规则上有差异C小子：好有意思呀，一切可定义Kernel前辈:但业界也有统一标准，这些标准相当于基类，是最低原则，各家还会定自己的规则C小子：各家自己定义是为了便于自己的一些应用，统一标准是为了传播交流。多谢Kernel前辈指点。 20001与19496Kernel前辈:一个加1操作就可以把计算机方方面面的知识都带出来。加1操作系统会引发很多有趣的话题，在并发环境下又发生什么不可思议的事？写一个简单的程序，两个线程共享变量n, 初值为1，分别对N加1000次后，结果是什么，为什么C小子：#include &lt;stdio.h&gt;#include &quot;windows.h&quot;int n = 1;bool p1 = false;bool p2 = false;DWORD WINAPI proc1(LPVOID lparentet){for(int i = 0;i&lt;1000;i++){n++;}p1= true;return 0;}DWORD WINAPI proc2(LPVOID lparentet){for(int i = 0;i&lt;1000;i++){n++;}p2 = true;return 0;}int main(){CreateThread(NULL,0,proc1,NULL,0,NULL);CreateThread(NULL,0,proc2,NULL,0,NULL);while(1){if(p1 &amp;&amp; p2){printf(&quot;%d\\n&quot;,n);break;}}return 0;}1000次，运行结果一直都是2001，没有发现异常，但是1W次有时会有异常，按理说是20001，但有时就是其它数，10W次的话经常异常。好奇怪，次数越多，异常现象越明显1000次很难发现异常。这和处理器性能有没有关系？Kernel前辈:这个问题，自己探索，如果方向对了，再给你说C小子：好，会不会是一个线程访问这个全局变量时而另一个线程将其修改，从而产生异常。而异常结果小于正常结果是因为是n++这个运算。如果是n–则会大于正常结果。异常结果与正常结果之差不一定是发生异常的次数，一个线程访问这个全局变量时而另一个线程或许会将其修改再修改。次数越多，异常现象越明显，这和处理器性能应该没有关系，因为执行的次数一定。全局变量为1，n– 1000次后应是-1999，异常结果大于正常结果Kernel前辈:从线程的并发执行考虑C小子：一个线程访问这个全局变量时而另一个线程将其修改，从而产生异常Kernel前辈:同步机制C小子：多谢Kernel前辈指点Kernel前辈:为什么异常还没说到根本上C小子：没有上锁，经常无序执行，虽然效率高，但是容易出错。再次感谢Kernel前辈的指点。","categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://yoursite.com/tags/Kernel/"}],"keywords":[]},{"title":"安全 中华人民共和国网络安全法 5.28-6.1","slug":"diary-2017-0528-0601","date":"2017-06-01T02:36:00.000Z","updated":"2017-06-01T06:34:00.000Z","comments":true,"path":"diary-2017-0528-0601/","link":"","permalink":"http://yoursite.com/diary-2017-0528-0601/","excerpt":"中华人民共和国网络安全法(2016年11月7日第十二届全国人民代表大会常务委员会第二十四次会议通过,2017年6月1日正式实施） 目 录 第一章 总 则 第二章 网络安全支持与促进 第三章 网络运行安全 第一节 一般规定 第二节 关键信息基础设施的运行安全 第四章 网络信息安全 第五章 监测预警与应急处置 第六章 法律责任 第七章 附 则","text":"中华人民共和国网络安全法(2016年11月7日第十二届全国人民代表大会常务委员会第二十四次会议通过,2017年6月1日正式实施） 目 录 第一章 总 则 第二章 网络安全支持与促进 第三章 网络运行安全 第一节 一般规定 第二节 关键信息基础设施的运行安全 第四章 网络信息安全 第五章 监测预警与应急处置 第六章 法律责任 第七章 附 则 第一章 总 则第一条 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。第二章 网络安全支持与促进第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。第三章 网络运行安全第一节 一般规定第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；（四）采取数据分类、重要数据备份和加密等措施；（五）法律、行政法规规定的其他义务。第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。第二节 关键信息基础设施的运行安全第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务：（一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查；（二）定期对从业人员进行网络安全教育、技术培训和技能考核；（三）对重要系统和数据库进行容灾备份；（四）制定网络安全事件应急预案，并定期进行演练；（五）法律、行政法规规定的其他义务。第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施：（一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估；（二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力；（三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享；（四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。第四章 网络信息安全第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。第五章 监测预警与应急处置第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施：（一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测；（二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度；（三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。第六章 法律责任第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款：（一）设置恶意程序的；（二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的；（三）擅自终止为其产品、服务提供安全维护的。第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款：（一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的；（二）拒绝、阻碍有关部门依法实施的监督检查的；（三）拒不向公安机关、国家安全机关提供技术支持和协助的。第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。第七章 附 则第七十六条 本法下列用语的含义：（一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。（二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。（三）网络运营者，是指网络的所有者、管理者和网络服务提供者。（四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。第七十八条 军事网络的安全保护，由中央军事委员会另行规定。第七十九条 本法自2017年6月1日起施行。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"红线","slug":"红线","permalink":"http://yoursite.com/tags/红线/"}],"keywords":[]},{"title":"安全 全国高校电脑遭病毒绑架 5.10-5.13","slug":"diary-2017-0510-0513","date":"2017-05-13T02:36:00.000Z","updated":"2017-05-13T07:35:18.000Z","comments":true,"path":"diary-2017-0510-0513/","link":"","permalink":"http://yoursite.com/diary-2017-0510-0513/","excerpt":"​​​本周五，一次迄今为止最大规模的勒索病毒网络攻击席卷全球。据卡巴斯基统计，在过去的十几个小时里，全球共有74个国家的至少4.5万电脑中招。而杀毒软件Avast统计的数据更为惊人：病毒已感染全球至少5.7万台电脑，并仍在迅速蔓延中。截至13日凌晨，全球被该病毒感染的国家与地区。","text":"​​​本周五，一次迄今为止最大规模的勒索病毒网络攻击席卷全球。据卡巴斯基统计，在过去的十几个小时里，全球共有74个国家的至少4.5万电脑中招。而杀毒软件Avast统计的数据更为惊人：病毒已感染全球至少5.7万台电脑，并仍在迅速蔓延中。截至13日凌晨，全球被该病毒感染的国家与地区。 在此提醒广大校园网用户： 为计算机安装最新的安全补丁，微软已发布补丁MS17-010修复了“永恒之蓝”攻击的系统漏洞，请尽快安装此安全补丁，网址为https://technet.microsoft.com/zh-cn/library/security/MS17-010。 关闭445、135、137、138、139端口，关闭网络共享。 强化网络安全意识：不明链接不要点击，不明文件不要下载，不明邮件不要打开。 尽快（今后定期）备份自己电脑中的重要文件资料到移动硬盘、U盘，备份完后脱机保存该磁盘。 建议仍在使用windows xp， windows 2003操作系统的用户尽快升级到window 7/windows 10，或windows 2008/2012/2016操作系统。 安装正版操作系统、Office软件等。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}],"keywords":[]},{"title":"旧事 曾经的愿望 4.10-4.16","slug":"diary-2017-0410-0416","date":"2017-04-16T02:36:00.000Z","updated":"2017-05-13T18:29:54.000Z","comments":true,"path":"diary-2017-0410-0416/","link":"","permalink":"http://yoursite.com/diary-2017-0410-0416/","excerpt":"","text":"当时想着考上研究生，就可以放下手中的笔，与键盘相依相伴，虚拟在线办公。把电脑当分为主系统娱乐和多个分系统独立的工作室。忘却一切烦恼与不安，去自己想去的地方看那些陌生的风景。 当计划被打乱，梦想被搁浅时，还要在凡间呆上一年，渡渡劫难 买台台式机，多买几个显示器，这样工作学习起来就方便多了，多装几个虚拟机，配置各种不同的环境，配远程，以后就可以完全的随时随地远程办公，最重要的是工作完后可以继续以一个孩子的心态去玩耍。可必须成熟，责任还有去承担，你是男生，没有任性的资本女生还可以随随便便找个工作，以后期望着婚姻能够改变命运，而男生，必须去担当了孩子的幼稚，想象力是许多成人都不具备的，网络时代亦如此鱼与熊掌不可兼得当你拿到offer时，却发现这个岗位你真的不喜欢，再坚持一年，一定坚持，时间到了，不管喜不喜欢，该干嘛干嘛 做每一个项目，你都能找到最快的方法，不读研，找工作我很难找的提升自己的机会,再考一年，如果再报西邮，就真的一点追求都没有，自己也没动力 二战西电的这一年你该如何度过？ 是想过去那样打打擦边球，然后用剩余时间去记录自己的一些关于计算机体系的一些想法还是沉浸于答案套路的海洋，我，没有选择 很遗憾没能读陈莉君老师的研究生 对不起她，机试面试都还算不错，期望着在她坛求道，聆听大师对计算机体系，大数据安全的理解，对内核的感悟，对哲学禅学等的一些心得体会。命运如此，能否扼住她的喉咙？以后做事情细心点，慢点，别一直为那些为那些闲余时间被浪费而感到遗憾。 做一个好吃懒做贪财好色的人不好吗 稳稳当当的 把自己应该做的事情先做完，然后再考虑自己喜欢做的。至少稳定点，只是可能会牺牲所谓的一些创新能力，但至少会变得稳定了许多，对家庭好。 还没到愿望实现的时候时 Back with silence","categories":[],"tags":[{"name":"旧事","slug":"旧事","permalink":"http://yoursite.com/tags/旧事/"}],"keywords":[]},{"title":"安全 计算机的各种端口关闭方法 2.10-3.09","slug":"diary-2016-0210-0309","date":"2016-03-09T02:36:00.000Z","updated":"2017-05-13T07:30:54.000Z","comments":true,"path":"diary-2016-0210-0309/","link":"","permalink":"http://yoursite.com/diary-2016-0210-0309/","excerpt":"有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在 的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。​​​","text":"有人曾经把服务器比作房子，而把端口比作通向不同房间（服务）的门，如果不考虑细节的话，这是一个不错的比喻。入侵者要占领这间房子，势必要破门而入（物理入侵另说），那么对于入侵者来说，了解房子开了几扇门，都是什么样的门，门后面有什么东西就显得至关重要。入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在 的漏洞，因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。​​​ 常见各端口： 关闭139端口的方法是在“网络和拨号连接”中“本地连接”中选取“Internet协议(TCP/IP)”属性，进入“高级TCP/IP设置”“WinS设置”里面有一项“禁用TCP/IP的NETBIOS”，打勾就关闭了139端口。 445端口的关闭:修改注册表，添加一个键值HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\NetBT\\Parameters在右面的窗口建立一个SMBDeviceEnabled 为REG_DWORD类型键值为 0这样就ok了 135端口关闭方法 Windows XP系统运行dcomcnfg，展开“组件服务”→“计算机”，在“我的电脑”上点右键选“属性”，切换到“默认属性”，取消“启用分布式COM”；然后切换到“默认协议”，删除“面向连接的TCP/IP”。以上选项有对应的注册表键值，因此也可通过注册表来修改： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ole\\EnableDCOM的值改为“N” HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Rpc\\DCOM Protocols 中删除“ncacn_ip_tcp”此外，还需要停用“Distributed Transaction Coordinator”服务，重启之后， 135端口就没有了。Windows 2000系统前面的步骤和在XP下相同，只是需要多停用一个服务，“Task Scheduler”注意dcomcnfg的界面稍有不同，不过内容是一样的。Windows 2003以上方法在2003下无效，目前我只找到一个折中的方法。默认情况下，135端口是在所有地址上监听的，如果只在本机回环地址上监听，也不失为一种解决办法。要想改变135监听的地址，需要Windows Server 2003 Resource Kit tools中的rpccfg.exe。首先看一下网卡上都有哪些网段：rpccfg -l，一般情况下输出如下： 1 127.0.0.0 1 MS TCP Loopback interface 2 192.168.0.0 1 Realtek RTL8139/810x Family Fast Ethernet NIC然后输入；rpccfg -a 1。这样只有本机回环地址才开放135端口。 关闭23端口23端口主要用于Telnet（远程登录）服务，是Internet上普遍采用的登录和仿真程序。端口说明：23端口主要用于Telnet（远程登录）服务，是Internet上普遍采用的登录和仿真程序。同样需要设置客户端和服务器端，开启Telnet服务的客户端就可以登录远程Telnet服务器，采用授权用户名和密码登录。登录之后，允许用户使用命令提示符窗口进行相应的操作。在Windows中可以在命令提示符窗口中，键入“Telnet”命令来使用Telnet远程登录。操作建议：利用Telnet服务，黑客可以搜索远程登录Unix的服务，扫描操作系统的类型。而且在Windows 2000中Telnet服务存在多个严重的漏洞，比如提升权限、拒绝服务等，可以让远程服务器崩溃。Telnet服务的23端口也是TTS（Tiny Telnet Server）木马的缺省端口。所以，建议关闭23端口。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}],"keywords":[]},{"title":"安全 360云盘免费扩容100T空间 4.10-4.14","slug":"diary-2014-0410-0414","date":"2014-04-14T07:54:00.000Z","updated":"2017-05-13T07:56:10.000Z","comments":true,"path":"diary-2014-0410-0414/","link":"","permalink":"http://yoursite.com/diary-2014-0410-0414/","excerpt":"​​​云盘是一种专业的网络存储工具，随时随地的安全存放数据和重要资料。云盘相对于传统的实体磁盘来说，更方便，用户不需要把储存重要资料的实体磁盘带在身上。却一样可以通过互联网，轻松从云端读取自己所存储的信息。最近身边有好几个朋友让帮忙升级，终于闲了下来，下面教大家免费获得360云盘领100T免费空间。","text":"​​​云盘是一种专业的网络存储工具，随时随地的安全存放数据和重要资料。云盘相对于传统的实体磁盘来说，更方便，用户不需要把储存重要资料的实体磁盘带在身上。却一样可以通过互联网，轻松从云端读取自己所存储的信息。最近身边有好几个朋友让帮忙升级，终于闲了下来，下面教大家免费获得360云盘领100T免费空间。 简易教程： 打开浏览器，输入网址 http://sehd.360.cn/turntable/base/draw/?active=0434a1&amp;qid=XXXX 后面的XXXX表示的是32个十六进制数，要求大写并只要0-9 A-F 中随机32位值即可，比如我随意输的C5CA1ACBBBEFCAB299CD9B73E87C7B4A 修改好后直接回车，打开的网站中，找到卡号即可，一串大写的字母 如果出现下面情况，那就是XXX的与别人的重复，在修改下即可 找到卡号后，去360的“空间升级卡”，复制刚刚的卡号，升级即可","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2014-03-01T02:36:00.000Z","updated":"2018-06-04T21:42:54.000Z","comments":true,"path":"hello-world/","link":"","permalink":"http://yoursite.com/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"keywords":[]}]}